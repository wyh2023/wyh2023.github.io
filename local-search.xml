<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>COA-指令集</title>
    <link href="/2020/12/10/COA-%E6%8C%87%E4%BB%A4%E9%9B%86/"/>
    <url>/2020/12/10/COA-%E6%8C%87%E4%BB%A4%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h3 id="Instruction-Cycle"><a href="#Instruction-Cycle" class="headerlink" title="Instruction Cycle"></a>Instruction Cycle</h3><p><img src="/img/COA/Fetch.jpg" alt=""></p><p><img src="/img/COA/instr.jpg" alt=""></p><p><img src="/img/COA/iter.jpg" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>WeeklyReview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WeeklyReview</tag>
      
      <tag>COA</tag>
      
      <tag>Instruction Set</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MultiSet</title>
    <link href="/2020/12/07/MultiSet/"/>
    <url>/2020/12/07/MultiSet/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>After learning binary search trees in algorithm class, Nezzar challenges you with the following task.</p><p>Given a <strong>multiset</strong> 𝑆S which is intially emtpy, Nezzar may do one of the following operations in each round, and your algorithm should support these features.</p><ul><li>0 $x$, insert $x$ to $S$;</li><li>1 $x$, output the number of copies of $x$ in $S$, and remove exactly <strong>one copy</strong> of $x$ from $S$ if $S$ contains at least one copy of $x$;</li><li>2 $l,r$, output $∑x∈S,l&lt;x≤r$. For example, if $S={3,5,5,7},l=3,r=7$, then output should be $17$ as $5+5+7=17$.</li></ul><p>To disallow some shortcut solutions (offline solutions), Nezzar will fix a positive integer 𝑚𝑜𝑑mod, and provide input in the following way (𝑙𝑎𝑛𝑠lans is 00 initially).</p><ul><li>0 $y$ where $0≤y&lt;mod$, let $x=(y+lans)$ mod $mod$ and insert $x$ to $S$;</li><li>1 $y$ where $0≤y&lt;mod$, let $x=(y+lans)$ mod $mod$ and output the number of copies of $x$ in $S$, then remove exactly <strong>one copy</strong> of $x$ from $S$ if $S$ contains at least one copy of $x$;</li><li>2 $u,v$ where $0≤u,v&lt;mod$, let <ul><li>$l=(u+lans)$ mod $mod$ and $r=(v+lans)$ mod $mod$, swap $l$ and $r$ if $l&gt;r$, output $∑x∈S,l&lt;x≤r$ and finally update $lans$ with output.</li></ul></li></ul><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of input contains two integers $Q$ and $mod$, where $1≤Q≤5⋅10^5$ and $1≤mod≤10^13$.</p><p>Each of the following $Q$ lines contains an operation described above.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each type 1 and type 2 query, output one line with the required value.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code class="hljs python"><span class="hljs-number">7</span> <span class="hljs-number">15</span><span class="hljs-number">1</span> <span class="hljs-number">2</span><span class="hljs-number">0</span> <span class="hljs-number">3</span><span class="hljs-number">0</span> <span class="hljs-number">6</span><span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">7</span><span class="hljs-number">0</span> <span class="hljs-number">5</span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span></code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code class="hljs python"><span class="hljs-number">0</span><span class="hljs-number">9</span><span class="hljs-number">14</span><span class="hljs-number">0</span></code></pre><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>Initially, $S={}$.</p><p>Parameter for the first query is $x=(y+lans)$ mod $mod=2$. Hence, output for this query should be 0, and $S={}$ after first query.</p><p>Parameter for the second query is $x=(y+lans)$ mod $mod=3$. Hence, $S={3}$ after the second query.</p><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>Your algorithm should answer each query in $O(log⁡n)$ time to get accepted. If you have no idea how to debug, first write a naive algorithm (i.e., a straightforward but slow algorithm), then generate some small random test cases, finally compare the naive algorithm’s output with your final fast algorithm’s output.</p><h3 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h3><p>维护一个数据结构，使得它可以进行以下的三个操作：</p><ul><li>向一个集合内插入元素；</li><li>查询一个多重集中某元素的多少个，若存在，则在查询之后删除一个；</li><li>查询区间和；</li></ul><p>要求：每个操作都在$O(logn)$的时间内进行——【意味着我们要使用高效数据结构】。</p><h3 id="Naive-Solution"><a href="#Naive-Solution" class="headerlink" title="Naive Solution"></a>Naive Solution</h3><p>提示中说，我们可以先获得一个Naive的做法。在C++中，<code>Set</code>这个常用的容器是用红黑树来维护的，因此考虑到增和删的高效，一开始使用了这个数据结构。基本上是简单模拟了题意中的要求，并且同时维护了一个<code>map</code>用来存储对应<code>value</code>的次数。</p><ul><li>增：<code>map</code>中次数为0则在<code>set</code>中添加，否则在对于的<code>numMap</code>中+1；</li><li>删：<code>map</code>中次数为1则在<code>set</code>中删除，为0则不操作，否则在对于的<code>numMap</code>中-1；</li><li>查区间：用到了<code>upper_bound</code>因此要在<code>set</code>中添加一个最大的元素MAX防止上界的位置跑偏；</li></ul><p>很遗憾，这样的操作的“查区间”的最大时间复杂度是$O(n)$，不满足需求，在2操作较多且数据比较分散的情况下很显然会TLE；</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;cstdio&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;set&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;iterator&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;map&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX 2147483647</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> Q;<span class="hljs-keyword">int</span> mod;<span class="hljs-keyword">int</span> choice;<span class="hljs-keyword">int</span> x;<span class="hljs-keyword">int</span> u, v;<span class="hljs-keyword">int</span> l, r;<span class="hljs-keyword">int</span> lans=<span class="hljs-number">0</span>;<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt;S;<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; numMap;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">multiS</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;Q, &amp;mod);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;Q; i++)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;choice);        <span class="hljs-keyword">switch</span> (choice) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);                <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">0</span>&amp;&amp;x&lt;mod)&#123;x = (x+lans)%mod;&#125;                <span class="hljs-keyword">if</span>(S.count(x)==<span class="hljs-number">0</span>) numMap.insert(&#123;x, <span class="hljs-number">0</span>&#125;);                numMap[x]++;                S.insert(x);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);                <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">0</span>&amp;&amp;x&lt;mod)&#123;x = (x+lans)%mod;&#125;                <span class="hljs-keyword">if</span>(numMap[x]&gt;<span class="hljs-number">0</span>)&#123;                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, numMap[x]);                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0\n&quot;</span>);                &#125;                <span class="hljs-keyword">if</span>(numMap[x]==<span class="hljs-number">1</span>)&#123;                    S.erase(x);                &#125;                <span class="hljs-keyword">if</span>(numMap[x]&gt;<span class="hljs-number">0</span>)&#123;                    numMap[x]--;                &#125;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);                <span class="hljs-keyword">if</span>(u&gt;=<span class="hljs-number">0</span>&amp;&amp;u&lt;mod)&#123;l = (u+lans)%mod;&#125;                <span class="hljs-keyword">if</span>(v&gt;=<span class="hljs-number">0</span>&amp;&amp;v&lt;mod)&#123;r = (v+lans)%mod;&#125;                <span class="hljs-keyword">if</span>(l&gt;r)&#123;                    <span class="hljs-keyword">int</span> tmp = l;                    l = r;                    r = tmp;                &#125;                <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;                <span class="hljs-built_in">pair</span>&lt;<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt;::const_iterator,<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt;::const_iterator&gt; pr;                pr = S.equal_range(l);                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i=pr.second; i!=S.upper_bound(r); i++)&#123;                    <span class="hljs-keyword">int</span> t = numMap[*i];                    sum += (*i)*t;                &#125;                lans = sum;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, sum);                <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    S.insert(MAX);    multiS();&#125;</code></pre><h3 id="维护Treap解法"><a href="#维护Treap解法" class="headerlink" title="维护Treap解法"></a>维护Treap解法</h3><blockquote><p>treap 是一种弱平衡的二叉搜索树。treap 这个单词是 tree 和 heap 的组合，表明 treap 是一种由树和堆组合形成的数据结构。treap 的每个结点上要额外储存一个值$priority$。treap 除了要满足二叉搜索树的性质之外，还需满足父节点的</p><p>$priority$大于等于两个儿子的$priority$。而$priority$是每个结点建立时随机生成的，因此 treap 是期望平衡的。</p></blockquote><p>treap 分为旋转式和无旋式两种。两种 treap 都易于编写，但无旋式 treap 的操作方式使得它天生支持维护序列、可持久化等特性。这里以重新实现 <code>set&lt;int&gt;</code> （不可重集合）为例，介绍无旋式 treap。</p><p>在众多高效数据结构中，我选择了Treap。（因为不想写红黑树，也不会用跳表）这道题使用了一个<a href="https://oi-wiki.org/ds/treap/">模板</a>——来自于课程助教。使用数组存了几个关于Treap的关键信息——<code>w[maxn]</code>存入每个结点出现的次数、<code>size</code>是以当前结点为根的树的结点之和、<code>val</code>等都是结点信息；</p><p>这个问题的关键是利用了平衡树求得了前缀和，因此可以<code>ll sum = T.querySum(T.rt, r) - T.querySum(T.rt, l);</code> 对于二叉搜索树来说，其中一种情况，左子结点全部比根节点小，右节点全部比根节点大，因此左子树+根节点就是前缀和。还有一种情况，如果根节点是父母节点的右子节点，那么父母节点也在前缀和中。因此前缀和需要我们逐层递归查找，时间复杂度为$O(n)$。所以，为了满足这个条件，我们需要将<strong>树的和</strong>记录下来。因此在增和删的操作中，我们需要维护子树和。</p><ul><li>增：在查找位置的过程中，每到一层即为当前根结点的根数和加上当前<code>x</code>的<code>value</code>。</li><li>删：我额外维护了一个set，便于判断是否向下查找。如果set中没有该数，那么不进行删除操作，如果有则在沿途减去当前<code>value</code>。并且当这个结点需要删除的同时，<code>set.erase(x)</code>。</li></ul><p>等于上面的操作将累加和摊销到了增和删的操作中；</p><p>这样，前缀和就十分好获得了（已经存储过），区间和直接就可以得到。最后不忘记更新<code>lans</code>就结束了。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;set&quot;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxn 1000005</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF (1 &lt;&lt; 30)</span><span class="hljs-keyword">int</span> n;ll mod;ll lans=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> l[maxn], r[maxn], rnd[maxn], w[maxn];ll  size[maxn], val[maxn];<span class="hljs-built_in">set</span>&lt;ll&gt;S;<span class="hljs-comment">//w是权重 //l是左子节点的索引 //r是右子结点的索引 //rnd是优先级 //val是对应的索引 //size是树的节点总数-&gt;前缀和</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treap</span> &#123;</span>  <span class="hljs-keyword">int</span> sz, rt;  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; size[x] = size[l[x]] + size[r[x]] + w[x]*val[x]; &#125;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lrotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;k)</span> </span>&#123;    <span class="hljs-keyword">int</span> t = r[k];    r[k] = l[t];    l[t] = k;    size[t] = size[k];    pushup(k);    k = t;  &#125;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rrotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;k)</span> </span>&#123;    <span class="hljs-keyword">int</span> t = l[k];    l[k] = r[t];    r[t] = k;    size[t] = size[k];    pushup(k);    k = t;  &#125;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;k, ll x)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!k) &#123;      sz++;      k = sz;      size[k] = x;      w[k] = <span class="hljs-number">1</span>;      val[k] = x;      rnd[k] = rand();      <span class="hljs-keyword">return</span>;    &#125;    size[k]+=x;    <span class="hljs-keyword">if</span> (val[k] == x) &#123;      w[k]++;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val[k] &lt; x) &#123;      insert(r[k], x);      <span class="hljs-keyword">if</span> (rnd[r[k]] &lt; rnd[k]) lrotate(k);    &#125; <span class="hljs-keyword">else</span> &#123;      insert(l[k], x);      <span class="hljs-keyword">if</span> (rnd[l[k]] &lt; rnd[k]) rrotate(k);    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;k, ll x)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!S.count(x))        <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span> (val[k] == x) &#123;      <span class="hljs-keyword">if</span> (w[k] &gt; <span class="hljs-number">1</span>) &#123;        w[k]--;        size[k]-=x;        <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-keyword">if</span> (l[k] == <span class="hljs-number">0</span> || r[k] == <span class="hljs-number">0</span>) &#123;          S.erase(x);          k = l[k] + r[k];      &#125;      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rnd[l[k]] &lt; rnd[r[k]]) &#123;        rrotate(k);        del(k, x);      &#125; <span class="hljs-keyword">else</span> &#123;        lrotate(k);        del(k, x);      &#125;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val[k] &lt; x) &#123;      size[k]-=x;      del(r[k], x);    &#125; <span class="hljs-keyword">else</span> &#123;      size[k]-=x;      del(l[k], x);    &#125;  &#125;  <span class="hljs-function">ll <span class="hljs-title">querySum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, ll x)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!k) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (val[k] == x)      <span class="hljs-keyword">return</span> size[l[k]] + w[k]*val[k];    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; val[k]) &#123;      <span class="hljs-keyword">return</span> size[l[k]] + w[k]*val[k] + querySum(r[k], x);    &#125; <span class="hljs-keyword">else</span>      <span class="hljs-keyword">return</span> querySum(l[k], x);  &#125;  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">querynum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, ll x)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!k) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (x == val[k])&#123;        <span class="hljs-keyword">return</span> w[k];    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &lt; val[k])&#123;        <span class="hljs-keyword">return</span> querynum(l[k], x);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> querynum(r[k], x);    &#125;  &#125;&#125; T;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    srand(<span class="hljs-number">123</span>);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;mod);    <span class="hljs-keyword">int</span> opt;    ll x;    ll v;    ll l, r;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%lld&quot;</span>, &amp;opt, &amp;x);        <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">0</span>&amp;&amp;x&lt;mod) x = (x + lans) % mod;            S.insert(x);            T.insert(T.rt, x);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">0</span>&amp;&amp;x&lt;mod) x = (x + lans) % mod;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, T.querynum(T.rt, x));            T.del(T.rt, x);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">2</span>) &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;v);            <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">0</span>&amp;&amp;x&lt;mod) l = (x+lans)%mod;            <span class="hljs-keyword">if</span>(v&gt;=<span class="hljs-number">0</span>&amp;&amp;v&lt;mod) r = (v+lans)%mod;            <span class="hljs-keyword">if</span>(l&gt;r)&#123;                ll tmp = l;                l = r;                r = tmp;            &#125;            ll sum = T.querySum(T.rt, r) - T.querySum(T.rt, l);            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, sum);            lans = sum;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="测试生成Python代码"><a href="#测试生成Python代码" class="headerlink" title="测试生成Python代码"></a>测试生成Python代码</h3><p>以下是debug过程中用到的生成测试数据的代码，欢迎取用( ´ ▽ ` )ﾉ！</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> cyaron <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> random<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genTest</span>(<span class="hljs-params">n</span>):</span>    test_data = IO(file_prefix=<span class="hljs-built_in">str</span>(n))    t = randint(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>)    mod = randint(<span class="hljs-number">1</span>, <span class="hljs-number">1000000</span>)    test_data.input_write(t)    test_data.input_write(<span class="hljs-string">&quot; &quot;</span>)    test_data.input_writeln(mod)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, t):        a = randint(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)        test_data.input_write(a)        test_data.input_write(<span class="hljs-string">&quot; &quot;</span>)        test_data.input_write(randint(<span class="hljs-number">1</span>, <span class="hljs-number">1000000</span>))        <span class="hljs-keyword">if</span> a==<span class="hljs-number">2</span>:            test_data.input_write(<span class="hljs-string">&quot; &quot;</span>)            test_data.input_writeln(randint(<span class="hljs-number">1</span>, <span class="hljs-number">1000000</span>))        <span class="hljs-keyword">else</span>:            test_data.input_writeln()    test_data.output_gen(<span class="hljs-string">&quot;...&quot;</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>):        genTest(i)</code></pre>]]></content>
    
    
    <categories>
      
      <category>OJ</category>
      
      <category>数据结构</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>OJ</tag>
      
      <tag>平衡树</tag>
      
      <tag>Treap</tag>
      
      <tag>BST</tag>
      
      <tag>模板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BalanceSegmentPainting</title>
    <link href="/2020/12/05/BalanceSegmentPainting/"/>
    <url>/2020/12/05/BalanceSegmentPainting/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>There’s a segment 𝐼=[0,𝑛] initially painted with color white. Nezzar chooses a permutation 𝑝p of [𝑛]={1,2,⋯,𝑛}, and repaint the segment in the following way.</p><ul><li>In the 𝑖-th day, he repaints segment [𝑝𝑖−1,𝑝𝑖] with color black.</li></ul><p>Define the balance of segment 𝐼 as the length of the largest continuous subsegment 𝐼′ painted <strong>in black</strong>. Nezzar challenges you to calculate the balance of segment 𝐼 right after the 𝑖-th day for <em>1</em>≤𝑖≤𝑛.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input contains a single integer 𝑛 (1≤𝑛≤10<sup>6</sup>).</p><p>The following line contains 𝑛 integers 𝑝<sub>1</sub>,𝑝<sub>2</sub>,…,𝑝<sub>𝑛</sub> (1≤𝑝<sub>𝑖</sub>≤𝑛).</p><p>It is gauranteed that 𝑝<sub>1</sub>,𝑝<sub>2</sub>,…,𝑝<sub>𝑛</sub> forms a permutation of [𝑛].</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Output 𝑛 balance values in one line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code class="hljs python"><span class="hljs-number">5</span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span></code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code class="hljs python"><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span></code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>You might want to use the disjoint sets data structure.</p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个数组表示一段白色的布，它有$n$个格子，每天染黑一个格子，问每天最长的连续黑色段有多长？</p><ul><li>⬜️ ⬜️ ⬜️ ⬜️ ⬜️         0-day            0-balance</li><li>⬛️ ⬜️ ⬜️ ⬜️ ⬜️         1-day            1-balance            1</li><li>⬛️ ⬛️ ⬜️ ⬜️ ⬜️         2-day            2-balance            2</li><li>⬛️ ⬛️ ⬜️ ⬜️ ⬛️         3-day            2-balance            5</li><li>⬛️ ⬛️ ⬜️ ⬛️ ⬛️         4-day            2-balance            4</li><li>⬛️ ⬛️ ⬛️ ⬛️ ⬛️         5-day            5-balance            3</li></ul><p>提示中说，让我们使用并查集。这是一道很标准的并查集的模板题。只需要稍加修改就可以通过了。每个染黑的段是一个集合，每次染之和只需要查找能不能和左右两边的格子并成一个集合即可！</p><p>注意，为了减少内存的使用和时间消耗，我把每个并查集的结点数放在了根节点中，并以负数表示根节点。为了更加高效，我们还应该在查找的同时进行压缩。</p><p>应该是本次oj最容易解决的一道题了orz</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;iostream&quot;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; f;<span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> r;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span>&#123;    <span class="hljs-keyword">if</span>(f[k]==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//没被染黑</span>    <span class="hljs-keyword">if</span>(f[k]&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> k;   <span class="hljs-comment">//根节点是负数</span>    <span class="hljs-keyword">return</span> f[k]=Find(f[k]); <span class="hljs-comment">//集团染黑，同时压缩节点；</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;    <span class="hljs-keyword">int</span> fa = Find(a);    <span class="hljs-comment">//两个都是正数</span>    <span class="hljs-keyword">int</span> fb = Find(b);    <span class="hljs-comment">//fa和fb是a和b的根的位置</span>    <span class="hljs-keyword">if</span>(fa != fb)&#123;        <span class="hljs-keyword">int</span> numA = f[fa];  <span class="hljs-comment">//这个数是负的；</span>        <span class="hljs-keyword">int</span> numB = f[fb];  <span class="hljs-comment">//也是负的；</span>        <span class="hljs-keyword">int</span> numAll = numA + numB;        f[fa] = fb;      <span class="hljs-comment">//fa的根换成了fb</span>        f[fb] = numAll;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    f= <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;r);        f[r] = <span class="hljs-number">-1</span>;  <span class="hljs-comment">//新染色，自己是自己的根；</span>        <span class="hljs-keyword">int</span> left = Find(r<span class="hljs-number">-1</span>);  <span class="hljs-comment">//返回的是位置</span>        <span class="hljs-keyword">int</span> right = Find(r+<span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span>(left&gt;<span class="hljs-number">0</span>) Union(r, left);    <span class="hljs-comment">//两个位置Union</span>        <span class="hljs-keyword">if</span>(right&gt;<span class="hljs-number">0</span>) Union(r, right);        <span class="hljs-keyword">int</span> t = -f[Find(r)];        <span class="hljs-keyword">if</span>(t &gt; res) res = t;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, res);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>OJ</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
      <tag>数据结构与算法</tag>
      
      <tag>OJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GodMiner</title>
    <link href="/2020/12/04/GodMiner/"/>
    <url>/2020/12/04/GodMiner/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Nezzar is addicted to game Gold Miner recently.</p><p>Gold Miner is a game in which the player is in an 𝑛×𝑛n×n grid, and the goal is to collect gold without entering forbidden area. It is known that cell (𝑖,𝑗)(i,j) is forbidden to enter if and only if $i=j$ or $i=j+1$.</p><p>In one round, Nezzar may choose two non-empty sets $X,Y⊆[n]$, and collect gold in cell $(i,j)$ for all $i∈X,j∈Y$. However, he immediately fails if there exists $i∈X$ and $j∈Y$ such that $(i,j)$ is forbidden to enter.</p><p>As a greedy miner, Nezzar would like to enter all but forbidden cells to collect gold. However, he is running out of time! <strong>He can only play the game for at most $50$ rounds.</strong> Can you design an algorithm to solve this problem for him?</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>One line containing one integer $n (2≤n≤3000)$, the size of the grid.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p><strong>Please read this part carefully, as you may fail to pass the test cases if you have formating issues.</strong></p><p>For each round with subsets $X,Y$ being chosen, output elements in $X$ <strong>increasingly</strong> in the first line, and then output elements in $Y$ <strong>increasingly</strong> in the second line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code class="hljs c++"><span class="hljs-number">3</span></code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code class="hljs c++"><span class="hljs-number">1</span><span class="hljs-number">2</span> <span class="hljs-number">3</span><span class="hljs-number">1</span> <span class="hljs-number">2</span><span class="hljs-number">3</span><span class="hljs-number">3</span><span class="hljs-number">1</span></code></pre><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>It is <strong>allowed</strong> to enter some cells multiple times!</p><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>Believe it or not, we can use divide-and-conquer technique to solve this task.</p><p>Let $T(n)$ denote the number of rounds we need to solve the above task with parameter $n$. Notice that $T(n)=T(n/2)+O(1)$ implies $T(n)=O(log⁡n)$, and we may need an algorithm satisfying this recurrence to solve the problem.</p><h3 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h3><p>有一个$n×n$的棋盘，在主对角线的两排是不允许开采的禁区，如下图。每一次我们可以选两个横纵坐标的集合$X$和$Y$。对于两个集合所有元素组成的点$(x, y)$进行开采。注意，这个点不可以是禁区。可以重复开采同一个点，但是总选择次数不可以超过50次（最多选100个集合）。任何有效的开采方法都会被判对。</p><p><img src="/img/DS/棋盘.png" alt="矿区"></p><h3 id="Naive-Solution"><a href="#Naive-Solution" class="headerlink" title="Naive Solution"></a>Naive Solution</h3><p>刚开始看这道题，以为这道题非常简单。因为感觉一眼就可以看出分治为左上角和右下角两个部分。然后写出了以下这样的代码：</p><ul><li>对于只有一个可开采的区域，直接返回这个开采的结果（下面的代码没写出来。。。）</li><li>对于两个的情况，开采右上角；</li><li>然后分奇偶情况，做不同的分割；</li></ul><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;iostream&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">miner</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> up, <span class="hljs-keyword">int</span> down)</span></span>&#123;    <span class="hljs-keyword">if</span>(s == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span>(s == <span class="hljs-number">2</span>) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, up);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, right);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;cnt=%d\n&quot;</span>, cnt++);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> tmp = (s+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;    <span class="hljs-keyword">if</span>(s%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123;        miner(tmp, left, left+tmp<span class="hljs-number">-1</span>, up, down-tmp+<span class="hljs-number">1</span>);        miner(tmp, right-tmp+<span class="hljs-number">1</span>, right, up+tmp<span class="hljs-number">-1</span>, down);        <span class="hljs-comment">//右上</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;s-tmp; i++)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, up+i);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;s-tmp; i++)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, right-tmp+<span class="hljs-number">2</span>+i);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;cnt=%d\n&quot;</span>, cnt++);        <span class="hljs-comment">//左下</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;s-tmp; i++)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, up+tmp+i);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;s-tmp; i++)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, left+i);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;cnt=%d\n&quot;</span>, cnt++);    &#125;    <span class="hljs-keyword">if</span>(s%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;        miner(tmp+<span class="hljs-number">1</span>, left, left+tmp, up, up+tmp);        miner(tmp, right-tmp+<span class="hljs-number">1</span>, right, down-tmp+<span class="hljs-number">1</span>, down);        <span class="hljs-comment">//右上</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;tmp; i++)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, up+i);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;tmp<span class="hljs-number">-1</span>; i++)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, left+tmp+<span class="hljs-number">1</span>+i);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;cnt=%d\n&quot;</span>, cnt++);        <span class="hljs-comment">//左下</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;tmp<span class="hljs-number">-1</span>; i++)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, up+tmp+<span class="hljs-number">1</span>+i);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;tmp; i++)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, left+i);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;cnt=%d\n&quot;</span>, cnt++);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">cin</span> &gt;&gt; n;    miner(n, <span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>, n);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>然后不出意外会发现：这么做消耗的次数比一行一行遍历还要高——因为每一个禁区边缘的区域都转化成了一个小方格去开采。印象中这样的做法大概进行了8700多次……</p><h3 id="我们需要一个更好的方法"><a href="#我们需要一个更好的方法" class="headerlink" title="我们需要一个更好的方法"></a>我们需要一个更好的方法</h3><p>这不一定是更好的方法（因为重复挖了很多方格），但是是最节省集合选择次数（上限50次）的方法。</p><p>主要的思路是——<strong>同时搜索左上、右上、左下、右下，以节省次数</strong>，这样就</p><p>因为在使用分治递归调用的过程中，无法使得每一轮的$X$和$Y$对应被打印，也无法使得不干扰的区域之间同时被搜索，因此使用了<code>vector&lt;vector&lt;int&gt;&gt; solution(50, vector&lt;int&gt;())</code>将策略存储在容器之中；因为对答案有需求，所以我们在进行遍历的时候也要从小次序开始，使用<code>push_back</code>直接把元素放入末尾即可。</p><p>对于$n$比较小的情况，比如$n \leq 7$的情况，仍然是一行一行遍历的情况次数更少；因此并没有进行操作，直接暴力<code>push_back</code>(._.)</p><p>对于$n$比较大的情况我们就不能遍历了。</p><p>我还是使用了<strong>分奇偶</strong>的思路，并同时搜索四块区域。</p><p>先以偶数$n=10$为例：</p><p><img src="/img/DS/偶挖法.png" alt=""></p><p>跟明显：左上和右下是$n = 4$的情况，右上和左下是一个完整的正方形，中间有两行十字形的区域。我的处理策略是：递归处理左上和右下的子情况，耗时：<code>miner(4)</code>；左下和右上完整的正方形：2次（整个挖去正方形）；十字形直接遍历横竖：2次；</p><script type="math/tex; mode=display">log_23000 = 11.5</script><p>那么如果每轮进行4次的话，大致会进行46次；</p><p>至于奇数，以$n=11$为例：不多解释啦，看图就能明白啦</p><p><img src="/img/DS/奇挖法.png" alt=""></p><p>至于我的代码太过丑陋，甚至实现的还和以上说的有一些不一样……(._.)</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;iostream&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">solutionX</span><span class="hljs-params">(<span class="hljs-number">50</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;())</span></span>;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">solutionY</span><span class="hljs-params">(<span class="hljs-number">50</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;())</span></span>;<span class="hljs-keyword">int</span> check;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mineSq</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> up, <span class="hljs-keyword">int</span> down)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=up; i&lt;= down; i++)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left; i&lt;= right; i++)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">miner</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> up, <span class="hljs-keyword">int</span> down, <span class="hljs-keyword">int</span> opr)</span></span>&#123;    <span class="hljs-keyword">if</span>(s == <span class="hljs-number">3</span>)&#123;        solutionX[opr].push_back(up);        solutionY[opr].push_back(left+<span class="hljs-number">1</span>);        solutionY[opr].push_back(right);        opr++;        solutionX[opr].push_back(up+<span class="hljs-number">1</span>);        solutionY[opr].push_back(right);        opr++;        solutionX[opr].push_back(up+<span class="hljs-number">2</span>);        solutionY[opr].push_back(left);        opr++;        check = opr;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(s == <span class="hljs-number">4</span>)&#123;        solutionX[opr].push_back(up);        solutionY[opr].push_back(left+<span class="hljs-number">1</span>);        solutionY[opr].push_back(left+<span class="hljs-number">2</span>);        solutionY[opr].push_back(left+<span class="hljs-number">3</span>);        opr++;        solutionX[opr].push_back(up+<span class="hljs-number">1</span>);        solutionY[opr].push_back(left+<span class="hljs-number">2</span>);        solutionY[opr].push_back(left+<span class="hljs-number">3</span>);        opr++;        solutionX[opr].push_back(up+<span class="hljs-number">2</span>);        solutionY[opr].push_back(left);        solutionY[opr].push_back(left+<span class="hljs-number">3</span>);        opr++;        solutionX[opr].push_back(up+<span class="hljs-number">3</span>);        solutionY[opr].push_back(left);        solutionY[opr].push_back(left+<span class="hljs-number">1</span>);        opr++;        check = opr;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(s == <span class="hljs-number">5</span>)&#123;        solutionX[opr].push_back(up);        solutionY[opr].push_back(left+<span class="hljs-number">1</span>);        solutionY[opr].push_back(left+<span class="hljs-number">2</span>);        solutionY[opr].push_back(left+<span class="hljs-number">3</span>);        solutionY[opr].push_back(left+<span class="hljs-number">4</span>);        opr++;        solutionX[opr].push_back(up+<span class="hljs-number">1</span>);        solutionY[opr].push_back(left+<span class="hljs-number">2</span>);        solutionY[opr].push_back(left+<span class="hljs-number">3</span>);        solutionY[opr].push_back(left+<span class="hljs-number">4</span>);        opr++;        solutionX[opr].push_back(up+<span class="hljs-number">2</span>);        solutionY[opr].push_back(left);        solutionY[opr].push_back(left+<span class="hljs-number">3</span>);        solutionY[opr].push_back(left+<span class="hljs-number">4</span>);        opr++;        solutionX[opr].push_back(up+<span class="hljs-number">3</span>);        solutionY[opr].push_back(left);        solutionY[opr].push_back(left+<span class="hljs-number">1</span>);        solutionY[opr].push_back(left+<span class="hljs-number">4</span>);        opr++;        solutionX[opr].push_back(up+<span class="hljs-number">4</span>);        solutionY[opr].push_back(left);        solutionY[opr].push_back(left+<span class="hljs-number">1</span>);        solutionY[opr].push_back(left+<span class="hljs-number">2</span>);        opr++;        check = opr;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(s == <span class="hljs-number">6</span>)&#123;        solutionX[opr].push_back(up);        solutionY[opr].push_back(left+<span class="hljs-number">1</span>);        solutionY[opr].push_back(left+<span class="hljs-number">2</span>);        solutionY[opr].push_back(left+<span class="hljs-number">3</span>);        solutionY[opr].push_back(left+<span class="hljs-number">4</span>);        solutionY[opr].push_back(left+<span class="hljs-number">5</span>);        opr++;        solutionX[opr].push_back(up+<span class="hljs-number">1</span>);        solutionY[opr].push_back(left+<span class="hljs-number">2</span>);        solutionY[opr].push_back(left+<span class="hljs-number">3</span>);        solutionY[opr].push_back(left+<span class="hljs-number">4</span>);        solutionY[opr].push_back(left+<span class="hljs-number">5</span>);        opr++;        solutionX[opr].push_back(up+<span class="hljs-number">2</span>);        solutionY[opr].push_back(left);        solutionY[opr].push_back(left+<span class="hljs-number">3</span>);        solutionY[opr].push_back(left+<span class="hljs-number">4</span>);        solutionY[opr].push_back(left+<span class="hljs-number">5</span>);        opr++;        solutionX[opr].push_back(up+<span class="hljs-number">3</span>);        solutionY[opr].push_back(left);        solutionY[opr].push_back(left+<span class="hljs-number">1</span>);        solutionY[opr].push_back(left+<span class="hljs-number">4</span>);        solutionY[opr].push_back(left+<span class="hljs-number">5</span>);        opr++;        solutionX[opr].push_back(up+<span class="hljs-number">4</span>);        solutionY[opr].push_back(left);        solutionY[opr].push_back(left+<span class="hljs-number">1</span>);        solutionY[opr].push_back(left+<span class="hljs-number">2</span>);        solutionY[opr].push_back(left+<span class="hljs-number">5</span>);        opr++;        solutionX[opr].push_back(up+<span class="hljs-number">5</span>);        solutionY[opr].push_back(left);        solutionY[opr].push_back(left+<span class="hljs-number">1</span>);        solutionY[opr].push_back(left+<span class="hljs-number">2</span>);        solutionY[opr].push_back(left+<span class="hljs-number">3</span>);        opr++;        check = opr;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(s%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">int</span> mid = (s+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left+mid; i&lt;=right; i++)&#123;            solutionY[opr].push_back(i);        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=up; i&lt;=up+mid<span class="hljs-number">-2</span>; i++)&#123;            solutionX[opr].push_back(i);        &#125;        opr++;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left; i&lt;=left+mid<span class="hljs-number">-2</span>; i++)&#123;            solutionY[opr].push_back(i);        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=up+mid; i&lt;=down; i++)&#123;            solutionX[opr].push_back(i);        &#125;        opr++;        solutionX[opr].push_back(up+mid<span class="hljs-number">-1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left; i&lt;=right; i++)&#123;            <span class="hljs-keyword">if</span>(i==left+mid<span class="hljs-number">-2</span> || i==left+mid<span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;            solutionY[opr].push_back(i);        &#125;        opr++;        solutionY[opr].push_back(left+mid<span class="hljs-number">-1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=up; i&lt;=down; i++)&#123;            <span class="hljs-keyword">if</span>(i==up+mid<span class="hljs-number">-1</span> || i==up+mid) <span class="hljs-keyword">continue</span>;            solutionX[opr].push_back(i);        &#125;        opr++;        miner(mid<span class="hljs-number">-1</span>, left, left+mid<span class="hljs-number">-2</span>, up, up+mid<span class="hljs-number">-2</span>, opr);        miner(mid<span class="hljs-number">-1</span>, left+mid, right, up+mid, down, opr);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(s%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">int</span> mid = s/<span class="hljs-number">2</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left+mid<span class="hljs-number">-1</span>; i&lt;=right; i++)&#123;            solutionY[opr].push_back(i);        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=up; i&lt;=up+mid<span class="hljs-number">-2</span>; i++)&#123;            solutionX[opr].push_back(i);        &#125;        opr++;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left; i&lt;=left+mid; i++)&#123;            solutionY[opr].push_back(i);        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=up+mid+<span class="hljs-number">2</span>; i&lt;=down; i++)&#123;            solutionX[opr].push_back(i);        &#125;        opr++;        solutionX[opr].push_back(up+mid<span class="hljs-number">-1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left; i&lt;=right; i++)&#123;            <span class="hljs-keyword">if</span>(i==left+mid<span class="hljs-number">-2</span> || i==left+mid<span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;            solutionY[opr].push_back(i);        &#125;        opr++;        solutionX[opr].push_back(up+mid);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left; i&lt;=right; i++)&#123;            <span class="hljs-keyword">if</span>(i==left+mid || i==left+mid<span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;            solutionY[opr].push_back(i);        &#125;        opr++;        solutionX[opr].push_back(up+mid+<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left; i&lt;=left+mid<span class="hljs-number">-1</span>; i++)&#123;            solutionY[opr].push_back(i);        &#125;        opr++;        miner(mid<span class="hljs-number">-1</span>, left, left+mid<span class="hljs-number">-2</span>, up, up+mid<span class="hljs-number">-2</span>, opr);        miner(mid<span class="hljs-number">-1</span>, left+mid+<span class="hljs-number">1</span>, right, up+mid+<span class="hljs-number">1</span>, down, opr);        <span class="hljs-keyword">return</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">cin</span> &gt;&gt; n;    miner(n, <span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>, n, <span class="hljs-number">0</span>);    <span class="hljs-comment">//cout &lt;&lt; check &lt;&lt; endl;</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;check; i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;solutionX[i].size(); j++)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, solutionX[i][j]);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>; k&lt;solutionY[i].size(); k++)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, solutionY[i][k]);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="棋盘python生成代码"><a href="#棋盘python生成代码" class="headerlink" title="棋盘python生成代码"></a>棋盘python生成代码</h3><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grid</span>(<span class="hljs-params">n</span>):</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):            <span class="hljs-keyword">if</span> i==j <span class="hljs-keyword">or</span> i==j+<span class="hljs-number">1</span>:                print(<span class="hljs-string">&quot;ㄨ &quot;</span>, end=<span class="hljs-string">&quot;&quot;</span>)            <span class="hljs-keyword">else</span>:                print(<span class="hljs-string">&quot;⬜ &quot;</span>, end=<span class="hljs-string">&quot;&quot;</span>)        print()<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    grid(<span class="hljs-number">11</span>)</code></pre>]]></content>
    
    
    <categories>
      
      <category>OJ</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分治</tag>
      
      <tag>Divide and Conquer</tag>
      
      <tag>数据结构与算法</tag>
      
      <tag>OJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LargeSumSubarray</title>
    <link href="/2020/12/04/LargeSumSubarray/"/>
    <url>/2020/12/04/LargeSumSubarray/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Nezzar has recently learnt how to find maximum subarray in the algorithm class. However, he finds out that in many cases, subarray with large sum is sufficient. Thus, he would like to know the number of subarrays with sum <strong>greater than</strong> $t$ for a sequence $a$.</p><p>Formally, you are given a sequence $a_1,a_2, … ,a_n$. </p><p>you are required to calculate the number of pairs $(i,j)$ such that $1 \le i \le j \le n$ and $\sum_{k=i}^j a_k &gt; t$.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains integers $(n,t) ((1 \le n \le 10^6, -10^{15} \le t \le 10^{15}))$; that is, the length of the given sequence and the threshold. The next line contains $n$ integers $a_1,a_2, … ,a_n$ where $(-10^9 \le a_i \le 10^9)$, describing the given sequence.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Output one integer, the number of pairs $(i,j)$ satisfying the requirements mentioned above.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code class="hljs python"><span class="hljs-number">5</span> <span class="hljs-number">8</span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">-1</span> <span class="hljs-number">4</span></code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code class="hljs python"><span class="hljs-number">1</span></code></pre><h3 id="Hints"><a href="#Hints" class="headerlink" title="Hints"></a>Hints</h3><p>You may need to design an $O(n \log n)$ time divide-and-conquer algorithm to pass all testcases. It is recommended to use C/C++ instead of Python or Java.</p><h3 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h3><p>给定一串数列$a_n$和某个数$t$，求整串数列中有多少个连续的子串 which 和大于$t$。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先，可以直接使用权值线段数据结构解决本题。但这并非本次OJ的出题目的，因此不多赘述（主要因为我也不会😅）</p><p>所以这次考虑的是使用前缀和分治再用尺取法。</p><p>考虑子序列和时，前缀和$sum[0], sum[1], … , sum[n]$是常用到的方法。从而使得$p$到$q$的子列和可以表示$sum[q] - sum[p]$。对于此题中的情况，我们就需要考虑使得$sum[q] - sum[p] \gt t$，就这样可以转化为$sum[q] \gt t + sum[p]$。</p><p>接下来，考虑一个普通的情况。对于一个前缀和数列$sum[0], sum[1], … , sum[n]$，将它一分为二，左边一半的每个元素逐个与右边一半的每个元素与t之和比较。如果满足$sum[q] \gt t + sum[p]$。说明成立。我们还可以通过排序使得整个过程更加简单。我们在讲数组一分为二的同时还可以进行归并排序。使用C++库函数中的<code>inplace_merge</code>，在原数组的位置并排为升序。</p><p>关于<code>inplace_merge</code>函数，它接受三个位置参数——<code>start</code>，<code>mid</code>，<code>end</code>。操作之后将<code>start</code>到<code>end</code>的位置的数组归并排序。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;algorithm&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;ll n;ll t;ll a[<span class="hljs-number">1000001</span>];ll ans=<span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span>&#123;    <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> ;    <span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> i=l,j=m+<span class="hljs-number">1</span>;    merge(l,m);merge(m+<span class="hljs-number">1</span>,r);    <span class="hljs-keyword">for</span>(;i&lt;=m;i++,ans+=r-j+<span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">for</span>(;j&lt;=r&amp;&amp;a[j]&lt;=t+a[i];) j++;    &#125;    inplace_merge(a+l,a+m+<span class="hljs-number">1</span>,a+r+<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;n);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;t);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;a[i]);        a[i] += a[i - <span class="hljs-number">1</span>];    &#125;    merge(<span class="hljs-number">0</span>, n);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>如何保证不找到重复的字序列？因为二分的两个部分都是已经搜索结束的，他们内部已经搜索完毕，而不会在后续被重复搜索，因此不会出现多数一次的情况。</p><p>当我们拿到了已经排好序且统计过的两部分，对左边的部分中每一个元素遍历右边部分。因为两个部分已经是升序的，因此遍历的过程中只要找到$sum[q] \gt t + sum[p]$，就可以终止循环，并且将剩余的前缀和数量加入<code>ans</code>就可以了。</p>]]></content>
    
    
    <categories>
      
      <category>OJ</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分治</tag>
      
      <tag>Divide and Conquer</tag>
      
      <tag>数据结构与算法</tag>
      
      <tag>OJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>COA-Bus</title>
    <link href="/2020/12/03/COA-Bus/"/>
    <url>/2020/12/03/COA-Bus/</url>
    
    <content type="html"><![CDATA[<h3 id="仲裁"><a href="#仲裁" class="headerlink" title="仲裁"></a>仲裁</h3><ul><li>虽然在同一时刻连接总线的设备可以接受信息，但是只有一个设备可以发送信息；</li><li>多个设备想要发出信息，需要仲裁；</li></ul><h3 id="集中式"><a href="#集中式" class="headerlink" title="集中式"></a>集中式</h3><h4 id="硬件——总线控制器-仲裁器"><a href="#硬件——总线控制器-仲裁器" class="headerlink" title="硬件——总线控制器/仲裁器"></a>硬件——总线控制器/仲裁器</h4><h5 id="链式"><a href="#链式" class="headerlink" title="链式"></a>链式</h5><ul><li>用<strong>许可线</strong>将设备全部存起来；往前发送许可信号，接受到之后根据自己需不需要总线来处理事件，如果需要则将总线设为忙，不往下传；</li><li>反之向下继续传；</li><li>线最少，效率比较低，公平性差；</li></ul><h5 id="询问式"><a href="#询问式" class="headerlink" title="询问式"></a>询问式</h5><ul><li>一组线；报号；</li><li>好处：避免了原来的链式结构中，对电路设备不敏感，一旦有设备坏了，后面的设备再也拿不到信号；报数的顺序可以很灵活——优先级or公平性；</li><li>坏处：多了一些线，让设备需要<strong>识数</strong>，时间也不算很短；</li></ul><h5 id="独立请求式"><a href="#独立请求式" class="headerlink" title="独立请求式"></a>独立请求式</h5><ul><li>每一个都会向仲裁起发出申请；同一时间仲裁器会收到多个申请；</li><li>优先级or公平性；根据预设的算法判定该分给谁。</li><li>好处：每一个设备都可以在第一时间发出申请，不存在等待时间，响应时间就会比较快；可以自己决定优先级；</li><li>坏处：比较复杂；比较多的线；</li></ul><h3 id="自举式"><a href="#自举式" class="headerlink" title="自举式"></a>自举式</h3><p><img src="/img/COA/BUSSS.jpg" alt="箭头表示信息流动——查看信息是否忙"></p><p><code>Device3</code>的优先级最高。<code>Device0</code>只有在别人都不需要用总线的时候才能发出请求；</p><h3 id="冲突检测式"><a href="#冲突检测式" class="headerlink" title="冲突检测式"></a>冲突检测式</h3><p>总线不忙就直接“用”——发送信息，然后检测信息是不是自己发送，如果不是自己发的（有其他设备同时发送信息），就随机暂停一段时间，再重新发送。</p><h3 id="时序"><a href="#时序" class="headerlink" title="时序"></a>时序</h3><h4 id="同步：有时钟"><a href="#同步：有时钟" class="headerlink" title="同步：有时钟"></a>同步：有时钟</h4><ul><li>总线事物：地址+数据+……+数据</li><li><img src="/img/COA/同步.jpg" alt=""></li><li>好处：简单去实现和测试；</li><li>坏处：所有设备共用同一个时钟——所有设备都要等待最慢的；总线长度受限于时钟漂移（时钟信号传播过长时准确性会变差，产生偏差）</li></ul><h4 id="异步：没有时钟，通过协商机制相互配合；"><a href="#异步：没有时钟，通过协商机制相互配合；" class="headerlink" title="异步：没有时钟，通过协商机制相互配合；"></a>异步：没有时钟，通过协商机制相互配合；</h4><ul><li>约束；</li><li><img src="/img/COA/异步.jpg" alt="约束是蓝色的线——”三次握手“"></li><li>坏处：对噪声比较敏感——根据对方状态改变自己的状态；</li><li><img src="/img/COA/握手.jpg" alt="准备-撤"></li><li>保证对方接收了再撤退；</li><li>例如3-对方说撤了，对方：我知道你撤了——知道对方撤了自己再撤；</li><li>4-表示“地址”这件事情彻底传输完了。表示地址和数据传递之间有一个先后关系；</li><li>如果有很多数据则重复4567；</li></ul><h4 id="总线事务分割"><a href="#总线事务分割" class="headerlink" title="总线事务分割"></a>总线事务分割</h4><p><img src="/img/COA/总线事务分割.jpg" alt=""></p><ul><li>总线在传输过程中是完全占用的，准备数据需要时间，传地址和数据传输之间会有空闲的时间；</li><li>把传地址和传数据分成两步；</li><li>优点：利用率提高了；</li><li>缺点：完成一件事情的时间本身会变长——每一个总线事务的平均时长；</li></ul><h4 id="总线带宽和数据传输率"><a href="#总线带宽和数据传输率" class="headerlink" title="总线带宽和数据传输率"></a>总线带宽和数据传输率</h4><h4 id="总线带宽"><a href="#总线带宽" class="headerlink" title="总线带宽"></a>总线带宽</h4><p><strong>理想情况下，总线最大数据传输率；</strong>（不考虑额外开销）</p><ul><li>一次能传多少数据，多长时间传一次；</li></ul><h4 id="数据传输率"><a href="#数据传输率" class="headerlink" title="数据传输率"></a>数据传输率</h4><ul><li>非理想情况下……</li></ul><h4 id="总线宽度"><a href="#总线宽度" class="headerlink" title="总线宽度"></a>总线宽度</h4><ul><li>总线中有多少根弦；同一时刻能传多少位；</li></ul><h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4>]]></content>
    
    
    <categories>
      
      <category>WeeklyReview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WeeklyReview</tag>
      
      <tag>COA</tag>
      
      <tag>Bus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Diary-1</title>
    <link href="/2020/12/01/Diary/"/>
    <url>/2020/12/01/Diary/</url>
    
    <content type="html"><![CDATA[<h2 id="多少改写一点记录心情的东西"><a href="#多少改写一点记录心情的东西" class="headerlink" title="多少改写一点记录心情的东西"></a>多少改写一点记录心情的东西</h2><p>（现在是2020年12月1日晚9:28，争取在10:00之前搞定这篇……( ´▽` )ﾉ）</p><p>感觉自己说这些东西一直很没有条理，totally意识流（x</p><p>一切的起因好像都是wls的这一篇表白墙</p><p><img src="/img/wls.jpg" alt=""></p><p>本来一开始想去对线的，因为感觉除了wls很少有人有资格说出这段话（结果没想到真的是wls发的！</p><p>起因是一个学弟的迷茫，询问在软院如何“自救”。的确，经历了让人糟心的大一上，谁不会有这种感受——“靠，怎么这样？”“日，我完蛋了！”“nmd，我高考完就给我这？”</p><p>过了一个学期，经历了一些感人的难忘的好玩的事，也就淡忘了这种感受。紧接着发现自己身边数不清的能人强者过出了不一样的风采，愈发觉得自己又馋又懒又菜，开始萌生了不少混的想法。同样也因为类似的想法错失了许多的锻炼自己的机会……也许感觉自己在成绩上还勉强挽救，想彻彻底底“卷”一个学期。</p><p>然后就开始了这几乎毫无收获的大二上——知识没新学会什么；代码没写多少；除了体重什么都没涨……看着sicp时期的神神们做着我早已看不懂的工作，麻木地安慰自己：要是能卷一卷也行。然而，事实上，“自己就这水平，再复习也没用”。</p><p>感受到了线代的无尽恶意以及与微积分天上地下的反差；无数个ddl前糊弄好的作业和不走心的口语练习，象征着许多天来的得过且过；不断翻倍的开销也代表着没有长进的日日夜夜。没有奢望回忆这些能够使颓废的自己有任何改变，只是希望潜意识里的自己能够多少有些意识。再想想那些怀着“自救”理想的学弟学妹、同学学长以及曾经的自己，只能觉得自己“麻了麻了”。</p><p>今天的SICP夜聊也让自己受教许多，让我开始思考（质疑）自己设定的目标是否正确和合理。实话说，现在也没有一个很明确的答案……仍然只能是走一步看一步，毕竟……怎样的人生选择都不能算是完全错的吧。</p><p>刚开学（大概是国庆后），找樾哥聊了半个多小时，感觉不少话还是要细品一下（此前的自己理解太过片面，盲目追求rank的提升属实不太会有什么好下场。希望可以尽快学会点东西，再会樾哥（所谓提前的2021目标，目前看来现在是学不完了。</p><p>好像也没什么好说的了，对了，想发这么个说说实际上是因为在和园一点点面前的一句话——“我原本觉得我的2020什么都没干就要结束了，但是看了看你，我想起我还是干了件大事的！”</p><p>10点前没写完QAQ，而且还都是瞎写的（</p><p>P.S. wls万物之源！</p>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Diary</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>COA-Disk</title>
    <link href="/2020/11/28/COA-Disk/"/>
    <url>/2020/11/28/COA-Disk/</url>
    
    <content type="html"><![CDATA[<h2 id="COA-Disk"><a href="#COA-Disk" class="headerlink" title="COA-Disk"></a>COA-Disk</h2><h3 id="CRC"><a href="#CRC" class="headerlink" title="CRC"></a>CRC</h3><p><a href="https://blog.csdn.net/csdn_kou/article/details/82379438">原帖地址</a></p><h4 id="什么是CRC校验？"><a href="#什么是CRC校验？" class="headerlink" title="什么是CRC校验？"></a>什么是CRC校验？</h4><p>CRC即循环冗余校验码：是数据通信领域中最常用的一种查错校验码，其特征是信息字段和校验字段的长度可以任意选定。<strong>循环冗余检查（CRC）</strong>是一种数据传输检错功能，对数据进行多项式计算，并将得到的结果附在帧的后面，接收设备也执行类似的算法，以保证数据传输的正确性和完整性。</p><h4 id="CRC校验原理"><a href="#CRC校验原理" class="headerlink" title="CRC校验原理"></a>CRC校验原理</h4><p>其根本思想就是先在要发送的帧后面附加一个数（这个就是用来校验的校验码，但要注意，这里的数也是二进制序列的，下同），生成一个新帧发送给接收端。当然，这个附加的数不是随意的，它要使所生成的新帧能与发送端和接收端共同选定的某个特定数整除（注意，这里不是直接采用二进制除法，而是采用一种称之为“ <strong>模2除法</strong>”）。到达接收端后，再把接收到的新帧除以（同样采用“ <strong>模2除法</strong>”）这个选定的除数。因为在发送端发送数据帧之前就已通过附加一个数，做了“去余”处理（也就已经能整除了），所以结果应该是没有余数。如果有余数，则表明该帧在传输过程中出现了差错。</p><h4 id="模2除法："><a href="#模2除法：" class="headerlink" title="模2除法："></a>模2除法：</h4><p>模2除法与算术除法类似，<strong>但每一位除的结果不影响其它位，即不向上一位借位，所以实际上就是异或。</strong>在循环冗余校验码（CRC）的计算中有应用到模2除法。</p><h4 id="CRC校验步骤："><a href="#CRC校验步骤：" class="headerlink" title="CRC校验步骤："></a>CRC校验步骤：</h4><p>CRC校验中有两个关键点，一是<strong>预先确定一个发送送端和接收端都用来作为除数的二进制比特串（或多项式）</strong>，可以随机选择，也可以使用国际标准，<strong>但是最高位和最低位必须为1</strong>；二是<strong>把原始帧与上面计算出的除数进行模2除法运算，计算出CRC码。</strong></p><h4 id="具体步骤："><a href="#具体步骤：" class="headerlink" title="具体步骤："></a>具体步骤：</h4><ol><li>选择合适的除数</li><li>看选定除数的二进制位数，然后再要发送的数据帧上面<strong>加上这个位数-1位的0</strong>，然后用新生成的帧以模2除法的方式除上面的除数，<strong>得到的余数就是该帧的CRC校验码。</strong>注意，<strong>余数的位数一定只比除数位数少一位</strong>，也就是<strong>CRC校验码位数比除数位数少一位</strong>，如果前面位是0也不能省略。</li><li>将计算出来的CRC校验码附加在原数据帧后面，构建成一个新的数据帧进行发送；最后接收端在以模2除法方式除以前面选择的除数，如果没有余数，则说明数据帧在传输的过程中没有出错。</li></ol><h4 id="举例——编程作业："><a href="#举例——编程作业：" class="headerlink" title="举例——编程作业："></a>举例——编程作业：</h4><p><img src="/img/COA/CRC.jpg" alt=""></p><p>数据为$100011$，生成多项式为$1001$。开始之前要在<code>data</code>之前补上<strong>生成多项式位数-1的0</strong>。进行模二除法——除法的步骤进行<code>data.length</code>次，每一次根据当前余数的首位是否为1，确定是与生成多项式异或还是与全0异或。最后得到的<strong>生成多项式位数-1</strong>的余数就是我们要找到的CheckCode。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 模2除法</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> check 待检查的数据</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> polynomial 生成多项式</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> len 生成多项式的长度</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lenData 数据的长度</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> checkCode</span><span class="hljs-comment">     */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">mod2Div</span><span class="hljs-params">(String check, String polynomial, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">int</span> lenData)</span></span>&#123;  String zeros = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;len; i++)&#123;    zeros = zeros + <span class="hljs-string">&quot;0&quot;</span>;  &#125;  String checkCode = check.substring(<span class="hljs-number">0</span>, len);  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;lenData; i++)&#123;    String q = (checkCode.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">&#x27;1&#x27;</span>)? polynomial : zeros;    checkCode = alu.xor(checkCode, q);    checkCode = checkCode.substring(<span class="hljs-number">1</span>);    <span class="hljs-keyword">if</span>(i != lenData-<span class="hljs-number">1</span>)&#123;      checkCode = checkCode + check.charAt(i+len);    &#125;  &#125;  <span class="hljs-keyword">return</span> checkCode;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">     * CRC计算器</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 数据流</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> polynomial 多项式</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> CheckCode</span><span class="hljs-comment">     */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>[] Calculate(<span class="hljs-keyword">char</span>[] data, String polynomial) &#123;  <span class="hljs-comment">//TODO</span>  StringBuilder dataStr = <span class="hljs-keyword">new</span> StringBuilder(String.valueOf(data));  <span class="hljs-keyword">int</span> lenData = data.length;  <span class="hljs-keyword">int</span> len = polynomial.length();  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;len-<span class="hljs-number">1</span>; i++)&#123;    dataStr.append(<span class="hljs-string">&quot;0&quot;</span>); <span class="hljs-comment">//补上末尾的n-1位的0。</span>  &#125;  <span class="hljs-keyword">return</span> mod2Div(dataStr.toString(), polynomial, len, lenData).toCharArray();&#125;</code></pre><p>运用的模2除法的CRC校验器为：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * CRC校验器</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 接收方接受的数据流</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> polynomial 多项式</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> CheckCode CheckCode</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 余数</span><span class="hljs-comment">     */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>[] Check(<span class="hljs-keyword">char</span>[] data, String polynomial, <span class="hljs-keyword">char</span>[] CheckCode)&#123;  <span class="hljs-comment">//TODO</span>  <span class="hljs-keyword">int</span> lenData = data.length;  <span class="hljs-keyword">int</span> len = polynomial.length();  String dataStr = String.valueOf(data) +    String.valueOf(CheckCode);  <span class="hljs-keyword">return</span> mod2Div(dataStr, polynomial, len, lenData).toCharArray();&#125;</code></pre><p>校验器的不同点是，校验器在待检查的数据末尾补上的不是$n-1$位的0，而是$n-1$位的<code>CheckCode</code>，只要得到的结果为全0，说明过程中数据没有出错，如果不为全0，说明数据出错需要修复。</p><h3 id="Disk"><a href="#Disk" class="headerlink" title="Disk"></a>Disk</h3><h4 id="读写的编程作业"><a href="#读写的编程作业" class="headerlink" title="读写的编程作业"></a>读写的编程作业</h4><p>怎么将磁头和磁盘搭配起来使用呢？我们在磁头中提供了一个<code>Seek</code>方法，拿到<code>Integer</code>型的地址后，我们可以用<code>Seek</code>方法确定读写开始的位置，在读写数据的时候，如果发生了扇区、磁道或者盘面的变化，我们需要修改磁头的位置，所以我们提供了一个<code>adjust</code>方法。在读数据的时候，我们的逻辑应该是这样的</p><pre><code class="hljs java">DISK_HEAD.Seek()<span class="hljs-keyword">while</span>(len--&gt;<span class="hljs-number">0</span>)&#123;  <span class="hljs-keyword">if</span> (need_adjust())&#123;      DISK_HEAD.adjust();    &#125;  Data.[DISK_HEAD.point++] = data[i++];  <span class="hljs-keyword">if</span> (读出了一个扇区)&#123;      CRC.check(...)    &#125;&#125;</code></pre><p>在写数据的时候，逻辑与上类似，区别在于如果到了需要调整的时候，意味着我们已经写到了一个扇区的尾部，这时候我们需要修改而不是检查这个扇区的CRC。</p><p>依据以上形式完成的读写代码如下：</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">char</span>[] read(String eip, <span class="hljs-keyword">int</span> len) &#123;  <span class="hljs-comment">//TODO</span>  String eipIntStr = transformer.binaryToInt(<span class="hljs-string">&quot;0&quot;</span> + eip);  <span class="hljs-keyword">int</span> eipInt = Integer.parseInt(eipIntStr);  StringBuilder ans = <span class="hljs-keyword">new</span> StringBuilder();  DISK_HEAD.Seek(eipInt);  <span class="hljs-keyword">while</span> (len--&gt;<span class="hljs-number">0</span>)&#123;    DISK_HEAD.adjust();    ans.append(disk.getData(DISK_HEAD).Data[DISK_HEAD.point++]);    <span class="hljs-keyword">if</span>(DISK_HEAD.point == BYTE_PRE_SECTOR)&#123;      <span class="hljs-keyword">char</span>[] checkCode = CRC.Calculate(ToBitStream(disk.getData(DISK_HEAD).Data), POLYNOMIAL);      disk.getData(DISK_HEAD).CRC = ToByteStream(checkCode);    &#125;  &#125;  <span class="hljs-keyword">char</span>[] checkCode = CRC.Calculate(ToBitStream(disk.getData(DISK_HEAD).Data), POLYNOMIAL);  disk.getData(DISK_HEAD).CRC = ToByteStream(checkCode);  <span class="hljs-keyword">return</span> ans.toString().toCharArray();&#125;</code></pre><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(String eip, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">char</span>[] data)</span> </span>&#123;  <span class="hljs-comment">//TODO</span>  String eipIntStr = transformer.binaryToInt(<span class="hljs-string">&quot;0&quot;</span> + eip);  <span class="hljs-keyword">int</span> eipInt = Integer.parseInt(eipIntStr);  write(eipInt, len, data);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">     * 写磁盘（地址为Integer型）</span><span class="hljs-comment">     * 测试会调用该方法</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> eip</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> len</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data</span><span class="hljs-comment">     */</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> eip, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">char</span>[] data)</span> </span>&#123;  <span class="hljs-comment">//TODO</span>  DISK_HEAD.Seek(eip);  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span> (len--&gt;<span class="hljs-number">0</span>)&#123;    DISK_HEAD.adjust();    disk.getData(DISK_HEAD).Data[DISK_HEAD.point++] = data[i++];    <span class="hljs-keyword">if</span>(DISK_HEAD.point == BYTE_PRE_SECTOR)&#123;      <span class="hljs-keyword">char</span>[] checkCode = CRC.Calculate(ToBitStream(disk.getData(DISK_HEAD).Data), POLYNOMIAL);      disk.getData(DISK_HEAD).CRC = ToByteStream(checkCode);    &#125;  &#125;  <span class="hljs-keyword">char</span>[] checkCode = CRC.Calculate(ToBitStream(disk.getData(DISK_HEAD).Data), POLYNOMIAL);  disk.getData(DISK_HEAD).CRC = ToByteStream(checkCode);&#125;</code></pre><h3 id="Disk中的CRC"><a href="#Disk中的CRC" class="headerlink" title="Disk中的CRC"></a>Disk中的CRC</h3><blockquote><p>注意，在磁盘读写的实现中，需要加⼊CRC，并存在扇区中，因为校验和和数据在磁盘中都是字节形式 存在，但是校验是在Bit级别上进⾏运算的，所以⼤家需要实现两个转换⽅法</p></blockquote><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">     * 将Byte流转换成Bit流</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 字节形式的数据</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 转化为01串形式的数据</span><span class="hljs-comment">     */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>[] ToBitStream(<span class="hljs-keyword">char</span>[] data) &#123;  <span class="hljs-keyword">char</span>[] t = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[data.length * <span class="hljs-number">8</span>];  <span class="hljs-comment">//TODO</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;data.length; i++)&#123;    <span class="hljs-keyword">int</span> byt = data[i];    String test = transformer.intToBinary(String.valueOf(byt)).substring(<span class="hljs-number">24</span>, <span class="hljs-number">32</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">8</span>; j++)&#123;      t[i*<span class="hljs-number">8</span> + j] = test.charAt(j);    &#125;  &#125;  <span class="hljs-keyword">return</span> t;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">     * 将Bit流转换为Byte流</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 01串形式的数据</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 转化为字节形式的数据</span><span class="hljs-comment">     */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>[] ToByteStream(<span class="hljs-keyword">char</span>[] data) &#123;  <span class="hljs-keyword">char</span>[] t = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[data.length / <span class="hljs-number">8</span>];  <span class="hljs-comment">//TODO</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;data.length; i+=<span class="hljs-number">8</span>)&#123;    String test = String.valueOf(data).substring(i, i+<span class="hljs-number">8</span>);    <span class="hljs-keyword">int</span> byt = Integer.parseInt(transformer.binaryToInt(test));    t[i/<span class="hljs-number">8</span>] = (<span class="hljs-keyword">char</span>) byt;  &#125;  <span class="hljs-keyword">return</span> t;&#125;</code></pre><p>以上过程简单直接，不多赘述。</p>]]></content>
    
    
    <categories>
      
      <category>WeeklyReview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WeeklyReview</tag>
      
      <tag>COA</tag>
      
      <tag>Disk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>COA-VirtualMemory</title>
    <link href="/2020/11/26/COA-VirtualMemory/"/>
    <url>/2020/11/26/COA-VirtualMemory/</url>
    
    <content type="html"><![CDATA[<h2 id="COA-VirtualMemory"><a href="#COA-VirtualMemory" class="headerlink" title="COA-VirtualMemory"></a>COA-VirtualMemory</h2><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><h4 id="固定大小分区"><a href="#固定大小分区" class="headerlink" title="固定大小分区"></a>固定大小分区</h4><ul><li>操作系统：固定的大小；</li><li>当加载程序的时候，有限放入：目前空的，能放下它的，且最小的。</li><li>缺点：浪费内存</li></ul><h4 id="变化大小分区"><a href="#变化大小分区" class="headerlink" title="变化大小分区"></a>变化大小分区</h4><ul><li>操作系统：固定的大小；</li><li>用户系统——按照需求；</li><li>不停的会产生许多小的空白区域——内存<strong>碎片</strong>。</li></ul><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><p>程序和内存“不连续”。</p><p>将内存分成固定大小的块，命名为<strong>页框</strong>，将程序分成固定大小的块，命名为<strong>页</strong>。</p><ul><li><strong>逻辑地址</strong>：指令的地址；</li><li><strong>物理地址</strong>：内存的地址；</li></ul><p>在页内部的偏移量（offset）不变。地址转换：把逻辑页号换为物理页号；</p><h3 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h3><ul><li>存放在硬盘中；</li><li>允许逻辑地址空间大于实际内存；</li><li><strong>只有需要的程序和数据会被加载进入内存；</strong>而不是载入整个程序；</li><li>每个进程都会有一个自己的页表；</li></ul><h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p><img src="/img/COA/Page.jpg" alt=""></p><ul><li>页表中不需要存放虚页号；</li></ul><p><img src="/img/COA/VMM.jpg" alt=""></p><p>有时候会产生缺页。每一个程序都有一个页表，存入其中所有的页。</p><h3 id="TLB"><a href="#TLB" class="headerlink" title="TLB"></a>TLB</h3><p><img src="/img/COA/TLB.jpg" alt=""></p><ul><li>存放页表的Cache；</li><li>采用的是关联映射</li><li>需要存放虚拟页号；tag就是虚页号；</li></ul><p><img src="/img/COA/TLBC.jpg" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>WeeklyReview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WeeklyReview</tag>
      
      <tag>COA</tag>
      
      <tag>VirtualMemory</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cache-Lab-COA</title>
    <link href="/2020/11/24/Cache-Lab-COA/"/>
    <url>/2020/11/24/Cache-Lab-COA/</url>
    
    <content type="html"><![CDATA[<h2 id="Cache-Lab"><a href="#Cache-Lab" class="headerlink" title="Cache Lab"></a>Cache Lab</h2><p><a href="https://github.com/wyh2023/COA2020/tree/main/Chapter2/CacheLab">代码的github地址</a></p><h4 id="前排吐槽"><a href="#前排吐槽" class="headerlink" title="前排吐槽"></a>前排吐槽</h4><p>这次的实验和以往有了比较大的不同。首先，从结构上看要复杂一些，有了不同的模块，更像是实现一个东西，而非过程式的实现得到特定输出的函数。当然，这也给测试代码带来了一些难度，同时增加了阅读框架代码的难度。同时，这也表明了计组这门课的考试难度不会简单，为即将到来的期末而担忧╮(╯▽╰)╭</p><h3 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h3><ul><li>Cache存在的目的是什么？<ul><li>处理器的处理速度远远超过了存储器提供信息的速度而产生了一个bar，Cache的作用就是在处理器与主存之间添加一个缓存，加快存取速度。</li><li>cache中保存的是主存中<strong>块</strong>的副本。</li></ul></li><li>Cache的工作原理是什么？<ul><li><img src="/img/COA/Cache.jpg" alt=""></li><li>CPU先向Cache索要数据（Check），如果找到则命中（Hit），如果不命中则在主存中寻找数据（Miss），将主存中的数据整块搬到Cache中，然后再从Cache中返回信息给CPU。</li><li>可这样理解，编程作业也是这样实现的：CPU只与Cache交互，从Cache当中Fetch信息，如果命中则返回信息（的位置），不命中则在主存中寻找信息并替换到Cache中。</li></ul></li><li>如何知道Cache是否命中？<ul><li>我们已知数据的地址，那么我们可以推知它在Cache的标志位（tags）是怎么样表示的。在组相联映射中，还要先推得组号，在对应的组中匹配标志。同时，我们还需要注意的是有效位（ValidBit），这一点在课上没有提及，如果有效位置为0，则Cache是不被使用的，因此，在FIFO下，判断Cache是否被使用除了判断时间戳（TimeStamp）还需要判断有效位是否是1。</li><li>因此，在标志位相匹配和有效位为1的情况下，Cache命中。</li></ul></li><li>时间局部性和空间局部性<ul><li>时间局部性：同一个数据在短时间内被使用多次；</li><li>空间局部性：临近的数据在短时间被被连续使用；</li></ul></li><li><img src="/img/COA/CacheCL.jpg" alt=""></li><li>在替换的过程中，搬运的<strong>是块而不是字</strong>。<ul><li><img src="/img/COA/CacheMove.jpg" alt=""></li></ul></li><li>Cache之所以需要更多的操作却还能节省时间：<ul><li>是因为它有较高的命中率；</li><li>Cache的存取时间远小于到主存的存取时间；</li></ul></li><li>Cache越大效果越好吗？<ul><li>增大Cache的大小可以提高命中率；</li><li>但是也增大了成本和Cache的存取时间；</li><li>不是，变好的幅度会越来越小。“局部性”，并不会牵扯到太大的范围，并且块越大块内寻找的成本就会越高。块太大了之后，带来的数据是局部性比较差的、比较老的数据。</li></ul></li><li>哪种映射方式更好？<ul><li><img src="/img/COA/Map.jpg" alt=""></li><li>组相联是直接映射和全相联的一个Trade Off。</li><li>当组相连的组大小为整个Cache时，映射模式本质上是全相联映射；当组大小为1时，本质上是直接映射；</li></ul></li><li>Cache系统的组成？<ul><li><img src="/img/COA/CacheSystem.jpg" alt=""></li></ul></li><li>替换算法都有什么？分别有怎样的特点和好处？<ul><li>LRU-最近最少用；</li><li>FIFO-先进先出；<ul><li>本次实验使用的主要算法：通过为Cache行添加上一个时间戳来标示CacheLine在Cache里面的存在时间，每次替换时间戳最大的那个。</li></ul></li><li>LFU-使用频率最低；</li><li>Random-随机；</li></ul></li><li>写策略的异同？<ul><li>直写法（Write Through）<ul><li>替换的时候同时写主存和Cache；</li><li>一改就要访问主存；</li><li>提高了cache和主存的一致性；</li></ul></li><li>回写法（Write Back）<ul><li>只修改Cache。只有当替换算法要驱逐这个更新过的块时，才把它写到第一层中；</li><li>需要一个脏位来表示这一个块是否被调整过；如果是1就写回去，如果是0就替换掉；</li><li>优点：减少对主存的操作到最小的程度；</li></ul></li></ul></li><li>CacheLine的行大小是不是越多越好？<ul><li>当行大小从很小变大的时候，命中率会相对提高——更多有用的信息会被搬到Cache中去；</li><li>但当行大小过大，命中率就会降低<ul><li>Cache中的行数会减少，从而导致更多的行替换；</li><li>添加进去的字距离需要的字比较远，以至于小概率在短期内会被用到；</li></ul></li></ul></li><li>多级Cache有什么好处？（亟待补充）</li></ul><hr><h3 id="实验概览"><a href="#实验概览" class="headerlink" title="实验概览"></a>实验概览</h3><h4 id="框架梳理"><a href="#框架梳理" class="headerlink" title="框架梳理"></a>框架梳理</h4><h4 id="Cache的数据结构"><a href="#Cache的数据结构" class="headerlink" title="Cache的数据结构"></a>Cache的数据结构</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Cache行，每行长度为(1+22+&#123;<span class="hljs-doctag">@link</span> Cache#LINE_SIZE_B&#125;)</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CacheLine</span> </span>&#123;  <span class="hljs-comment">// 有效位，标记该条数据是否有效</span>  <span class="hljs-keyword">boolean</span> validBit = <span class="hljs-keyword">false</span>;  <span class="hljs-comment">// 脏位，标记该条数据是否被修改</span>  <span class="hljs-keyword">boolean</span> dirty = <span class="hljs-keyword">false</span>;  <span class="hljs-comment">// 用于LRU和FIFO算法，记录该条数据时间戳</span>  Long timeStamp = -<span class="hljs-number">1L</span>;  <span class="hljs-comment">// 标记，占位长度为()22位，有效长度取决于映射策略：</span>  <span class="hljs-comment">// 直接映射: 12 位</span>  <span class="hljs-comment">// 全关联映射: 22 位</span>  <span class="hljs-comment">// (2^n)-路组关联映射: 22-(10-n) 位</span>  <span class="hljs-comment">// 注意，tag在物理地址中用高位表示，如：直接映射(32位)=tag(12位)+行号(10位)+块内地址(10位)，</span>  <span class="hljs-comment">// 那么对于值为0b1111的tag应该表示为0000000011110000000000，其中前12位为有效长度，</span>  <span class="hljs-comment">// 因为测试平台的原因，我们无法使用4GB的内存，但是我们还是选择用32位地址线来寻址</span>  <span class="hljs-keyword">char</span>[] tag = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">22</span>];  <span class="hljs-comment">// 数据</span>  <span class="hljs-keyword">char</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[LINE_SIZE_B];  <span class="hljs-keyword">char</span>[] getData() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.data;  &#125;  <span class="hljs-keyword">char</span>[] getTag() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.tag;  &#125;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] tagN, <span class="hljs-keyword">char</span>[] input)</span></span>&#123;    validBit = <span class="hljs-keyword">true</span>;    timeStamp = <span class="hljs-number">0L</span>;    System.arraycopy(tagN, <span class="hljs-number">0</span>, tag, <span class="hljs-number">0</span>, tagN.length);    System.arraycopy(input, <span class="hljs-number">0</span>, data, <span class="hljs-number">0</span>, input.length);  &#125;</code></pre><p>以上删去了无用的数据结构，这里的成员变量都已经在注释中解释的很清楚，不做过多解读了。主要说一下<code>update</code>，这里的update的主要目的是启用一个新的Cache，重置了它的有效位、时间戳以及内容。</p><blockquote><p>故事要从$Cache$的读写开始说起。由于$Cache$需要进行分块读写，所以我们提供了一个<code>helper</code>函数，这个函数已经写好了，他做的事情就是分块读写，然后根据参数来判断究竟是读还是写。在<code>helper</code>中，我们调用了<code>fetch</code>函数，这个函数会检查$Cache$是否包含某一个特定的$block$，如果检查到了就会返回，没有检查到就会从内存中加载。因为我们只需要实现一种替换策略，所以这里你可以硬编码一个<code>FIFO</code>进去，对于映射策略来说，本质上只有一种映射策略。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] helper(String eip, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">char</span>[] writeData)&#123;  <span class="hljs-keyword">char</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[len];  Transformer t = <span class="hljs-keyword">new</span> Transformer();  <span class="hljs-keyword">int</span> addr =  Integer.parseInt(t.binaryToInt(<span class="hljs-string">&quot;0&quot;</span> + eip));  <span class="hljs-keyword">int</span> upperBound = addr + len;  <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span> (addr &lt; upperBound) &#123;    <span class="hljs-keyword">int</span> nextSegLen = LINE_SIZE_B - (addr % LINE_SIZE_B);    <span class="hljs-keyword">if</span> (addr + nextSegLen &gt;= upperBound) &#123;      <span class="hljs-comment">//为满足循环终止条件，补满nextSegLen</span>      nextSegLen = upperBound - addr;    &#125;    <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(writeData == <span class="hljs-keyword">null</span>)&#123;      <span class="hljs-keyword">int</span> rowNO = fetch(t.intToBinary(String.valueOf(addr)), nextSegLen);      <span class="hljs-keyword">char</span>[] cache_data = cache.get(rowNO).getData();      <span class="hljs-keyword">while</span> (i &lt; nextSegLen) &#123;        data[index] = cache_data[addr % LINE_SIZE_B + i];        index++;        i++;      &#125;    &#125;    <span class="hljs-keyword">else</span>&#123;      <span class="hljs-keyword">int</span> rowNO = fetch(t.intToBinary(String.valueOf(addr)), nextSegLen);      <span class="hljs-keyword">char</span>[] input = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[LINE_SIZE_B];      Arrays.fill(input, <span class="hljs-string">&#x27;0&#x27;</span>);      <span class="hljs-keyword">while</span> (i &lt; nextSegLen) &#123;        input[addr % LINE_SIZE_B + i] = writeData[index];        index++;        i++;      &#125;      writeStrategy.write(rowNO, input);    &#125;    addr += nextSegLen;  &#125;  <span class="hljs-keyword">return</span> data;&#125;</code></pre><p><code>helper</code>用在<code>read</code>和<code>write</code>之中，减少了很大程度的重复代码；因为字符串操作的蛋疼性（手动熊猫擦汗），因此对<code>addr</code>需要一个神奇的操作。<code>upperBound</code>表示的是读写的终点。<code>nextSegLen</code>表示一行中还有多少剩余的位置。根据读写的数据量（即$len$的不同，很有可能会产生跨Cache行的读写，也很有可能产生不足一个Cache行的读写。</p><pre><code class="hljs java"><span class="hljs-keyword">if</span> (addr + nextSegLen &gt;= upperBound) &#123;  nextSegLen = upperBound - addr;&#125;</code></pre><p>的目的之一就是就是将<code>addr += nextSegLen</code>使得<code>addr</code>能达到循环终止的条件。至于<code>fetch</code>为什么有两个参数这里不是很明白……因为Cache中总是以块为操作单位的，这里的第二个参数<code>len</code>是做什么的呢(._.)</p><p>后面的代码都比较好理解，判断是否有内容需要写，从而决定是读还是写。如果是读的话，返回cache中的data。如果是写的话，通过写策略将Cache中写入内容。</p><p>以上是本次编程作业的一个主要逻辑单元。那么基于此开始总结本次的编程作业，首先是第一个我们参与到的函数——<code>fetch</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fetch</span><span class="hljs-params">(String sAddr, <span class="hljs-keyword">int</span> len)</span> </span>&#123;  <span class="hljs-comment">//TODO</span>  <span class="hljs-keyword">int</span> blockNO = getBlockNO(sAddr);  <span class="hljs-keyword">int</span> hit = mappingStrategy.map(blockNO);  <span class="hljs-keyword">if</span>(hit != -<span class="hljs-number">1</span>)&#123;    <span class="hljs-keyword">return</span> hit;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">return</span> mappingStrategy.writeCache(blockNO);  &#125;&#125;</code></pre><p>这是知识回顾中一个简单流程的实现。</p><p><img src="/img/COA/Cache.jpg" alt=""></p><p>框架代码中提供了一个处理前22位的函数，它非常的简单，就是把标志位+组号转化为整数类型。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getBlockNO</span><span class="hljs-params">(String addr)</span> </span>&#123;  Transformer t = <span class="hljs-keyword">new</span> Transformer();  <span class="hljs-keyword">return</span> Integer.parseInt(t.binaryToInt(<span class="hljs-string">&quot;0&quot;</span> + addr.substring(<span class="hljs-number">0</span>, <span class="hljs-number">22</span>)));&#125;</code></pre><p>首先提取了块地址的有关信息——标志和组号。然后通过映射关系找到对应的Cache行（可能会不命中）。如果命中的话（这表明标志位和有效位均符合要求），返回相应的行号，流程结束！如果不命中的话……就有点麻烦了( ´▽` )ﾉ。我们需要通过替换策略，到主存中把需要的块替换到Cache中。</p><p>基于逻辑的顺序，首先我们来看<strong>映射策略</strong>中的映射如何实现的：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">map</span><span class="hljs-params">(<span class="hljs-keyword">int</span> blockNO)</span> </span>&#123;  <span class="hljs-comment">//TODO</span>  <span class="hljs-keyword">int</span> setNO = blockNO % SETS;  <span class="hljs-keyword">int</span> start = setNO * setSize;  <span class="hljs-keyword">int</span> end = (setNO + <span class="hljs-number">1</span>)*setSize;  <span class="hljs-keyword">char</span>[] tag = getTag(blockNO);  <span class="hljs-keyword">return</span> replacementStrategy.isHit(start, end, tag);&#125;</code></pre><p><code>SETS</code>表明了组数，<code>setSize</code>表明了组大小（全文均表示此意）。<code>setNO</code>表示组号，<code>start</code>表示起始的行号，<code>end</code>表示终点行号+1。接着在Cache中查找我们要找的Cache行是否存在我们要找的内容。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">isHit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">char</span>[] addrTag)</span> </span>&#123;  <span class="hljs-comment">//TODO</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=start; i&lt;end; i++)&#123;    <span class="hljs-keyword">if</span> (Cache.getCache().isMatch(i, addrTag)) <span class="hljs-keyword">return</span> i;  &#125;  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> lineNO, <span class="hljs-keyword">char</span>[] tag)</span></span>&#123;  CacheLine cacheLine = <span class="hljs-keyword">this</span>.cache.get(lineNO);    <span class="hljs-keyword">if</span>(cacheLine == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;  <span class="hljs-keyword">if</span> (!cacheLine.validBit) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;  <span class="hljs-keyword">if</span> (!Arrays.equals(cacheLine.tag, tag)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><p><code>isMatch</code>提供了判断逻辑——即我们需要首先有<code>cacheLine</code>，其次有效位需要为<code>true</code>，最后需要标志位匹配；如果判断命中，我们返回相应的行号，如果判断不命中返回-1。</p><p>回到<code>fetch</code>，如果命中，返回行号。如果不命中，我们就需要从主存中搬来信息。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">writeCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> blockNO)</span> </span>&#123;    <span class="hljs-comment">//TODO</span>    <span class="hljs-keyword">int</span> setNO = blockNO % SETS;    <span class="hljs-keyword">int</span> start = setNO * setSize;    <span class="hljs-keyword">int</span> end = (setNO + <span class="hljs-number">1</span>)*setSize;    <span class="hljs-keyword">char</span>[] tag = getTag(blockNO);    <span class="hljs-keyword">char</span>[] memory =Memory.getMemory().read(t.intToBinary(String.valueOf(Cache.LINE_SIZE_B * blockNO)), Cache.LINE_SIZE_B);    <span class="hljs-keyword">return</span> replacementStrategy.Replace(start, end, tag, memory);&#125;</code></pre><p><code>Memory.getMemory().read(t.intToBinary(String.valueOf(Cache.LINE_SIZE_B * blockNO)), Cache.LINE_SIZE_B);</code>这么老长一串是从主存中读到的信息。</p><p>我的替换算法实现的比较复杂TAT，水平太低，并且肉眼可见的低效。不过还是先简单说说我自己的想法：为每个Cache行标记一个时间戳，没有被使用到的Cache行置为-1。一旦被使用到则时间戳变为0。在FIFO算法中，替换首先得组满了再进行替换，如果没满，则先使用空闲的。空闲的Cache行有两种，一种是没被使用过时间戳为<code>-1</code>，一种是有效位为<code>false</code>。</p><p>如果存在没被使用过的，则替换第一个没被使用过的<code>free CacheLine</code>。</p><p>如果满了，就在全部的CacheLine中寻找时间戳最大，在Cache中存在最久的那个，将其替换。</p><p>随后为组中全部非空Cache的时间戳增加1。</p><p>最后更新CacheLine。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Replace</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">char</span>[] addrTag, <span class="hljs-keyword">char</span>[] input)</span> </span>&#123;  <span class="hljs-comment">//TODO</span>  <span class="hljs-comment">//find free</span>  <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;  <span class="hljs-keyword">boolean</span> isFull = <span class="hljs-keyword">true</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=start; i&lt;end; i++)&#123;    <span class="hljs-keyword">if</span>(Cache.getCache().getTimeStamp(i) == -<span class="hljs-number">1L</span> || !Cache.getCache().getValid(i))&#123;      index = i;      isFull = <span class="hljs-keyword">false</span>;      <span class="hljs-keyword">break</span>;    &#125;  &#125;  <span class="hljs-comment">//Sort &amp; Find the Oldest.</span>  <span class="hljs-keyword">if</span>(isFull)&#123;    <span class="hljs-keyword">long</span> maxTime = Cache.getCache().getTimeStamp(start);    index = start;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=start; i&lt;end; i++)&#123;      <span class="hljs-keyword">if</span>(maxTime &lt; Cache.getCache().getTimeStamp(i))&#123;        maxTime = Cache.getCache().getTimeStamp(i);        index = i;      &#125;    &#125;  &#125;  <span class="hljs-comment">//inc the TimeStamp</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=start; i&lt;end; i++)&#123;    <span class="hljs-keyword">long</span> time = Cache.getCache().getTimeStamp(i);    <span class="hljs-keyword">if</span>(time &gt;= <span class="hljs-number">0L</span>)&#123;      Cache.getCache().incTimeStamp(i);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">break</span>;    &#125;  &#125;  <span class="hljs-comment">//inc the TimeStamp of the new CacheLine</span>  <span class="hljs-keyword">if</span>(Cache.getCache().getTimeStamp(index)==-<span class="hljs-number">1L</span>)&#123;    Cache.getCache().incTimeStamp(index);  &#125;  <span class="hljs-comment">//Write Back</span>  <span class="hljs-keyword">if</span>(Cache.getCache().getDirty(index))&#123;    writeStrategy.writeBack(index);    Cache.getCache().setDirty(index, <span class="hljs-keyword">false</span>);  &#125;  Cache.getCache().updateCacheLine(index, addrTag, input);  <span class="hljs-keyword">return</span> index;&#125;</code></pre><p>更新Cache内容的方法放在Cache中：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateCacheLine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">char</span>[] tag, <span class="hljs-keyword">char</span>[] input)</span></span>&#123;  CacheLine cacheLine = cache.get(row);  <span class="hljs-keyword">assert</span> cacheLine != <span class="hljs-keyword">null</span>;  cacheLine.update(tag, input);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] tagN, <span class="hljs-keyword">char</span>[] input)</span></span>&#123;  validBit = <span class="hljs-keyword">true</span>;  timeStamp = <span class="hljs-number">0L</span>;  System.arraycopy(tagN, <span class="hljs-number">0</span>, tag, <span class="hljs-number">0</span>, tagN.length);  System.arraycopy(input, <span class="hljs-number">0</span>, data, <span class="hljs-number">0</span>, input.length);&#125;</code></pre><p><code>update</code>之前有所提到，<code>updateCacheLine</code>就是在此基础之上，找到对应的Cache行，算是多了一层的抽象。</p><p>至此，Cache不命中也处理完了。</p><p>修改到这里应该就可以通过关于“读”的全部用例了。</p><p>那么关于“写”呢？</p><p>我们在知识回顾中提到了，本次实验所使用的回写法，只在替换算法要驱逐这个块的时候写回主存。【读操作不进行写回，因此可能产生一致性的问题】</p><p>所以在Replace中已经出现过了写回的判断——在更新cache行之前。</p><p>对Cache的写我们还是要看回<code>helper</code>。我们是通过<code>WriteStrategy</code>对Cache进行写操作的。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rowNo, <span class="hljs-keyword">char</span>[] input)</span> </span>&#123;  <span class="hljs-comment">//TODO</span>  Cache.getCache().setDirty(rowNo, <span class="hljs-keyword">true</span>);  Cache.getCache().setData(rowNo, input);&#125;</code></pre><p>首先，我们要把修改的那行Cache的脏位置为<code>true</code>，提醒主存在写操作（$altered）的时候回写。然后修改Cache里的内容，<code>setData</code>等函数不多赘述了。</p><p>写回的操作是这样的，先调用Cache，找到对应的Cache行，通过自身信息推导出需要写回的内存的地址，写入信息。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeBack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rowNo)</span> </span>&#123;  <span class="hljs-comment">//TODO</span>  Cache cache = Cache.getCache();  String pAddr = mappingStrategy.getPAddr(rowNo);  Memory.getMemory().writeBackM(pAddr, cache.getData(rowNo));&#125;</code></pre><p>上面是写操作策略中的<code>WriteBack</code>，首先我们需要推出对应的物理地址<code>pAddr</code>。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPAddr</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rowNo)</span> </span>&#123;  <span class="hljs-comment">//TODO</span>  <span class="hljs-comment">//</span>  <span class="hljs-keyword">int</span> setNum = rowNo / setSize;  String setStr = <span class="hljs-keyword">new</span> Transformer().intToBinary(String.valueOf(setNum)).substring(<span class="hljs-number">32</span>-countSets(SETS));  <span class="hljs-keyword">char</span>[] tag = Cache.getCache().getTag(rowNo);  String tagStr = String.valueOf(tag).substring(<span class="hljs-number">0</span>, <span class="hljs-number">22</span>-countSets(SETS));  <span class="hljs-keyword">return</span> tagStr + setStr + <span class="hljs-string">&quot;0000000000&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countSets</span><span class="hljs-params">(<span class="hljs-keyword">int</span> SETS)</span></span>&#123;  <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;  SETS &gt;&gt;= <span class="hljs-number">1</span>;  <span class="hljs-keyword">while</span>(SETS != <span class="hljs-number">0</span>)&#123;    ret++;    SETS &gt;&gt;= <span class="hljs-number">1</span>;  &#125;  <span class="hljs-keyword">return</span> ret;&#125;</code></pre><p>首先需要算出的是组数，这可以通过<code>rowNo / setSize</code>得到，比如组大小是4行，在第17行说明在第4组。（以0为起始）。然后算出Tag，它的长度是22-组数的长度。末尾补上十位0就是对应的物理地址。【为什么补上0就可以呢？因为Cache是按块操作的，以<code>&quot;0000000000&quot;</code>对齐的就是一块。】</p><p>主存的写操作也是有不少值得说的地方，除了判断是否有内容需要写回，将脏位恢复之外。还需要将重写的地方对应的Cache无效化。然后再更新数据。下面给出<code>invalid</code>但不做过多解释。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invalid</span><span class="hljs-params">(String sAddr, <span class="hljs-keyword">int</span> len)</span> </span>&#123;  <span class="hljs-keyword">int</span> from = getBlockNO(sAddr);  Transformer t = <span class="hljs-keyword">new</span> Transformer();  <span class="hljs-keyword">int</span> to = getBlockNO(t.intToBinary(String.valueOf(Integer.parseInt(t.binaryToInt(<span class="hljs-string">&quot;0&quot;</span> + sAddr)) + len - <span class="hljs-number">1</span>)));  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> blockNO=from; blockNO&lt;=to; blockNO++) &#123;    <span class="hljs-keyword">int</span> rowNO = mappingStrategy.map(blockNO);    <span class="hljs-keyword">if</span> (rowNO != -<span class="hljs-number">1</span>) &#123;      cache.get(rowNO).timeStamp = -<span class="hljs-number">1L</span>;      cache.get(rowNO).validBit = <span class="hljs-keyword">false</span>;    &#125;  &#125;&#125;</code></pre><p>到这里差不多也就结束了！不过目前没有去管彩蛋，因为要做的事情有点多，这次的$Review$写了两个多小时头皮发麻，不知道码了大概多少字。其实看下来，这一次并没有写很复杂的逻辑，无非是把老师上课讲的流程付诸于实践。只不过相比从前多了几个抽象层次，并且更难去测试，使得这次的编程作业看起来变难了……</p><p>希望有更高的作业质量的同时也希望可以更好的$Survive$过去( ´▽` )ﾉ！</p><h3 id="重振软院荣光，我辈义不容辞！"><a href="#重振软院荣光，我辈义不容辞！" class="headerlink" title="重振软院荣光，我辈义不容辞！"></a>重振软院荣光，我辈义不容辞！</h3>]]></content>
    
    
    
    <tags>
      
      <tag>COA</tag>
      
      <tag>Cache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>COA-RAID</title>
    <link href="/2020/11/19/COA-RAID/"/>
    <url>/2020/11/19/COA-RAID/</url>
    
    <content type="html"><![CDATA[<h2 id="COA-RAID"><a href="#COA-RAID" class="headerlink" title="COA-RAID"></a>COA-RAID</h2><h3 id="RAID（磁盘冗余阵列）"><a href="#RAID（磁盘冗余阵列）" class="headerlink" title="RAID（磁盘冗余阵列）"></a>RAID（磁盘冗余阵列）</h3><ul><li>一组物理磁盘，但是在使用的时候感觉像是一块磁盘，在操作系统下被视为一个单一的逻辑驱动器。</li><li>数据以<strong>带化（striping）</strong>的方式分布在一组物理磁盘上。</li><li>冗余磁盘容量用于存储奇偶校验信息，磁盘出错的情况下，有一定的恢复能力。【0、1级不支持】</li><li>多个磁头和机械臂移动机构同时操作达到更高的I/O和传输速度，但多个设备的使用增加了出错概率。</li><li><img src="/img/COA/RAIDLevel.jpg" alt=""></li></ul><h4 id="RAID-Level-0"><a href="#RAID-Level-0" class="headerlink" title="RAID Level 0"></a>RAID Level 0</h4><ul><li><img src="/img/COA/L0.jpg" alt=""></li><li>IO相应快：好多个I/O请求过来的话，对应不同的物理盘，可以减少等待时间；</li><li>IO数据量较大可以存在不同的空间里，可以提高写的速度。</li><li>缺点：因为条带化，文件可能会跨多个物理盘，只要有一个盘坏了，会影响许多数据的读取。</li></ul><h4 id="RAID-Level-1"><a href="#RAID-Level-1" class="headerlink" title="RAID Level 1"></a>RAID Level 1</h4><ul><li><img src="/img/COA/L1.jpg" alt=""></li><li>镜像：不同时坏的时候，总能取到数据。</li><li>可以加速读取，同时读一块盘上的不同内容。两个请求能够并行发出，减少I/O的排队时间。</li><li>一个读请求可以由包含请求数据的两个磁盘中的某一个提供服务，只要它的寻道时间较小；（旋转延迟改不了）</li><li>一个写请求需要更新两个对应的条带，但这可以并行完成。</li><li>缺点：价格高昂，需要支持两倍于逻辑磁盘的磁盘空间。</li><li>有大批的读请求时，RAID 1能实现高速的I/O速率，性能几乎可以达到RAID 0的两倍。如果有大批的写请求，性能则不比RAID 0好多少。</li></ul><h4 id="RAID-Level-2（没有广泛运用）"><a href="#RAID-Level-2（没有广泛运用）" class="headerlink" title="RAID Level 2（没有广泛运用）"></a>RAID Level 2（没有广泛运用）</h4><ul><li><img src="/img/COA/L2.jpg" alt=""></li><li>每一个磁盘都会参与每一次I/O的运算。非常高的数据传输率——<strong>条带非常的小</strong>；</li><li>使用了海明码——每一次读写的时候都会读数据进行矫验。</li><li>对于单个读操作，所有磁盘同时读取，请求的数据和相关的纠错码辈传送到阵列控制器。IO响应也可以更快。</li><li>对于单个写操作，所有数据盘和奇偶校验盘必须被访问以进行写操作。</li><li>缺点：成本高昂，冗余磁盘的数目与数据磁盘数目的对数成正比；后来的磁盘本身没有那么容易出错，因此不需要那么多冗余盘来进行操作；</li></ul><h4 id="RAID-Level-3"><a href="#RAID-Level-3" class="headerlink" title="RAID Level 3"></a>RAID Level 3</h4><ul><li><img src="/img/COA/L3.jpg" alt=""></li><li>使用了奇偶校验，对所有数据盘上同一位置的一组独立位进行简单计算的奇偶校验位；</li><li>如果有一个<strong>数据盘</strong>坏了，可以帮它恢复出来；<ul><li>P(b) = b<sub>1</sub>⊕b<sub>2</sub>⊕b<sub>3</sub>⊕b<sub>4</sub></li><li>b<sub>2</sub>⊕P(b)⊕P(b) = b<sub>2</sub>⊕b<sub>1</sub>⊕b<sub>2</sub>⊕b<sub>3</sub>⊕b<sub>4</sub>⊕P(b)</li><li>b<sub>2</sub> = b<sub>1</sub>⊕b<sub>3</sub>⊕b<sub>4</sub>⊕P(b)</li><li>每个数据条带的内容都可以从阵列中剩余磁盘的相应条带中重新生成。适用于3～6级。</li></ul></li><li><strong>校验盘</strong>坏了恢复的过程中需要知道是奇校验还是偶校验。</li><li>性能：非常小的条带，非常高的数据传输率。任何I/O请求将包含所有数据盘的并行数据传送。</li><li>缺点：同一时间只能加载一个IO请求。</li></ul><h4 id="RAID-Level-4（没有广泛运用）"><a href="#RAID-Level-4（没有广泛运用）" class="headerlink" title="RAID Level 4（没有广泛运用）"></a>RAID Level 4（没有广泛运用）</h4><ul><li><img src="/img/COA/L4.jpg" alt=""></li><li>独立存取技术。每个磁盘成员的操作是独立的，因此各个I/O请求能够并行处理。</li><li>各个盘之间不要牵绊——条带变大。每个盘变得相对独立；</li><li>每一次写操作，阵列管理软件不仅要修改用户数据，而且要修改相应的校验位。</li><li><img src="/img/COA/L4C.jpg" alt=""></li><li>为了计算新的奇偶校验位，阵列管理软件必须读取旧的数据条带和奇偶校验条带，然后用新的数据和新计算出的奇偶校验位更新上述的两个条带。因此每个条带的写操作包括两次读操作和两次写操作。</li><li>当涉及所有磁盘的数据条带的较大I/O写操作时，只需要和新的数据位来进行简单的计算即可得奇偶校验位。因此，奇偶校验盘和数据磁盘并行更新，不再需要另外的读或写操作。</li><li>在任何情况下，<strong>每一次读写操作必须涉及奇偶校验盘</strong>，因此它成为一个瓶颈。（因此没有被广泛使用）独立性很差，不实用。</li></ul><h4 id="RAID-Level-5"><a href="#RAID-Level-5" class="headerlink" title="RAID Level 5"></a>RAID Level 5</h4><ul><li><img src="/img/COA/L5.jpg" alt=""></li><li>和RAID 4相似；</li><li>冗余的任务分配在不同的盘上，所有磁盘上都分布了奇偶校验条带。</li><li>并不是完全独立了，只是好一点。</li></ul><h4 id="RAID-Level-6"><a href="#RAID-Level-6" class="headerlink" title="RAID Level 6"></a>RAID Level 6</h4><ul><li><img src="/img/COA/L6.jpg" alt=""></li><li>RAID 6 方案进行两种不同的奇偶校验计算，并将校验码以分开的块存于不同的磁盘中。因此，用户数据需要$N$个磁盘的RAID 6阵列，由$N+2$个磁盘组成。</li><li>P和Q是两个不同的数据校验算法，其中一个是用于RAID 4和RAID 5中的异或运算，另一个是一种独立的数据校验算法。这样，即使包含用户数据的两个盘出现故障了，数据照样能重新生成。</li><li>优点：极高的数据可用性，只在平均修复时间间隔内3个磁盘都出了故障才会使数据丢失。</li><li>每次写都要影响两个奇偶块。</li></ul>]]></content>
    
    
    <categories>
      
      <category>WeeklyReview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WeeklyReview</tag>
      
      <tag>RAID</tag>
      
      <tag>COA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Floating-point-Arithmetic-Review-2</title>
    <link href="/2020/11/13/Floating-point-Arithmetic-Review-2/"/>
    <url>/2020/11/13/Floating-point-Arithmetic-Review-2/</url>
    
    <content type="html"><![CDATA[<h2 id="浮点数乘除法运算编程作业总结"><a href="#浮点数乘除法运算编程作业总结" class="headerlink" title="浮点数乘除法运算编程作业总结"></a>浮点数乘除法运算编程作业总结</h2><p>多有说的不清楚以及还想不太清楚的地方，希望多多包涵( ´▽` )ﾉ</p><h3 id="浮点数乘法"><a href="#浮点数乘法" class="headerlink" title="浮点数乘法"></a>浮点数乘法</h3><h4 id="1-特殊情况"><a href="#1-特殊情况" class="headerlink" title="1. 特殊情况"></a>1. 特殊情况</h4><p>任何数和NaN相乘以及0和无穷相乘得到的结果都是NaN。我们首先需要对此进行特判：</p><pre><code class="hljs java"><span class="hljs-comment">//如果两个乘数中有一个是NaN，返回NaN</span><span class="hljs-keyword">if</span>(Pattern.matches(a, IEEE754Float.NaN) || Pattern.matches(b, IEEE754Float.NaN))&#123;  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NaN&quot;</span>;&#125;String ansExp;String ansFrac;<span class="hljs-keyword">char</span> signA = a.charAt(<span class="hljs-number">0</span>);<span class="hljs-keyword">char</span> signB = b.charAt(<span class="hljs-number">0</span>);String ansSign = (signA == signB)? <span class="hljs-string">&quot;0&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>;<span class="hljs-comment">//这么写麻烦了很多，在除法中的处理看起来更清爽一些。</span><span class="hljs-comment">//如果两个乘数中有一个是0，那么当另一个数：</span><span class="hljs-comment">//1.为NaN时【貌似重复判断了】结果为NaN</span><span class="hljs-comment">//2.为无穷的时候结果为NaN</span><span class="hljs-comment">//3.其他情况返回0，注意0的符号是两个乘数的异或结果</span><span class="hljs-keyword">if</span>(a.equals(IEEE754Float.N_ZERO) || b.equals(IEEE754Float.N_ZERO)   || a.equals(IEEE754Float.P_ZERO) || b.equals(IEEE754Float.P_ZERO))&#123;  <span class="hljs-keyword">if</span>(Pattern.matches(a, IEEE754Float.NaN) || Pattern.matches(b, IEEE754Float.NaN))&#123;    <span class="hljs-keyword">return</span> IEEE754Float.NaN;  &#125;  <span class="hljs-keyword">if</span>(a.startsWith(<span class="hljs-string">&quot;11111111&quot;</span>, <span class="hljs-number">1</span>) || b.startsWith(<span class="hljs-string">&quot;11111111&quot;</span>, <span class="hljs-number">1</span>))&#123;    <span class="hljs-keyword">return</span> IEEE754Float.NaN;  &#125;  <span class="hljs-keyword">return</span> ansSign + <span class="hljs-string">&quot;0000000000000000000000000000000&quot;</span>;&#125;</code></pre><h4 id="2-处理参数"><a href="#2-处理参数" class="headerlink" title="2. 处理参数"></a>2. 处理参数</h4><p>上面还处理了结果会用到的符号。下面对两个乘数进行处理，并且补上规格化隐去的小数点之前的0或者1。使用了countA和countB来代表参与运算的小数部分。</p><pre><code class="hljs java">String expA = a.substring(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>);String expB = b.substring(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>);String bitA = (expA.equals(<span class="hljs-string">&quot;00000000&quot;</span>))? <span class="hljs-string">&quot;0&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>;String bitB = (expB.equals(<span class="hljs-string">&quot;00000000&quot;</span>))? <span class="hljs-string">&quot;0&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>;String fracA = a.substring(<span class="hljs-number">9</span>);String fracB = b.substring(<span class="hljs-number">9</span>);String countA = bitA + fracA + <span class="hljs-string">&quot;0000&quot;</span>; <span class="hljs-comment">//28</span>String countB = bitB + fracB + <span class="hljs-string">&quot;0000&quot;</span>;</code></pre><h4 id="3-CF以及特判阶码"><a href="#3-CF以及特判阶码" class="headerlink" title="3. CF以及特判阶码"></a>3. CF以及特判阶码</h4><p>这里比较有意思，要单独说一下有关CF位。</p><p>CF位表示的是进位，当无符号数加减法溢出的时候CF会被置为1。什么情况下加法会溢出呢？当n位的两个二进制数相加得到的和大于2<sup>n</sup>时，溢出，也就是最后一位计算的时候CF为1。加法的情况下比较好理解，那么减法呢？在我的实现中，减法是将减数取反加一来实现的。因此，原本需要借位的数相加之后的CF为0，不需要的为1。所以加法和减法的溢出与否和CF的关系是相反的。</p><p>在这里，因为阶码比它的真实值多了127，两个数相乘之和阶码相加，也就加上了两个127，因此我们需要减一个127。正常的两个数之和的范围是0～508。而得到一个可以表示的结果的范围应该是127～381。</p><p>怎么样表示上溢出和下溢出的数更方便呢？</p><p>我们使用CF位！</p><p>如果一开始的加法溢出了，说明得到的结果大于255。如果之后的减法需要借位，说明得到的结果小于等于382（这也说明了还有一种加完得到255的情况）。小于382的情况是合法的，以上的关系都是充要的。因此，当一开始的加法溢出且减法不需要借位的时候，阶码上溢！根据之前对于CF的讨论，<strong>当加法之后的CF为1且减法之后的CF为1时，溢出得到结果无穷。</strong></p><p>如果一开始的加法没有溢出，说明结果小于等于255。如果之后-127的减法需要借位，说明结果处于0～126或256～382。取并集结果：0～126，我们可以知道<strong>当CF在加法之后为0，减127之后也为0的时候，阶码下溢出。</strong></p><p>以下是具体的处理：</p><pre><code class="hljs java">String tmp = add(expA, expB);<span class="hljs-comment">//CF 判断有没有溢出；</span><span class="hljs-keyword">char</span> tmpCF = CF;ansExp = sub(<span class="hljs-string">&quot;01111111&quot;</span>, tmp);<span class="hljs-comment">//CF 判断有没有借位；</span><span class="hljs-keyword">if</span>((tmpCF==<span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; CF==<span class="hljs-string">&#x27;1&#x27;</span>) || ansExp.equals(<span class="hljs-string">&quot;11111111&quot;</span>))&#123; <span class="hljs-comment">//一开始溢出了但是没有借位，说明</span>  <span class="hljs-keyword">if</span>(signA==signB) <span class="hljs-keyword">return</span> IEEE754Float.P_INF;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> IEEE754Float.N_INF;&#125;<span class="hljs-keyword">if</span>(tmpCF==<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; CF==<span class="hljs-string">&#x27;0&#x27;</span>)&#123; <span class="hljs-comment">//一开始没有溢出，但是有借位</span>  <span class="hljs-keyword">if</span>(signA==signB) <span class="hljs-keyword">return</span> IEEE754Float.P_ZERO;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> IEEE754Float.N_ZERO;&#125;</code></pre><p>之后的一步就是小数部分相乘得到结果的fraction。并对结果进行规格化（规格化的过程不多赘述）。</p><pre><code class="hljs java">ansFrac = mulFrac(countA, countB).substring(<span class="hljs-number">1</span>, <span class="hljs-number">25</span>);<span class="hljs-comment">//Normalize</span><span class="hljs-keyword">while</span> (ansFrac.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; !ansExp.equals(<span class="hljs-string">&quot;00000000&quot;</span>))&#123;  ansFrac = ansFrac.substring(<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;0&quot;</span>;  ansExp = sub(<span class="hljs-string">&quot;00000001&quot;</span>, ansExp);&#125;ansFrac = ansFrac.substring(<span class="hljs-number">1</span>, <span class="hljs-number">24</span>);<span class="hljs-keyword">return</span> ansSign + ansExp + ansFrac;</code></pre><h4 id="4-尾数乘法"><a href="#4-尾数乘法" class="headerlink" title="4. 尾数乘法"></a>4. 尾数乘法</h4><p>在这里给出mulFrac的具体代码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">mulFrac</span> <span class="hljs-params">(String src, String dest)</span></span>&#123;  String Y = dest;  String product = <span class="hljs-string">&quot;0000000000000000000000000000&quot;</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">28</span>; i++)&#123;    <span class="hljs-keyword">if</span>(Y.charAt(<span class="hljs-number">27</span>) == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;      product = add(src, product);    &#125;    product = <span class="hljs-string">&quot;0&quot;</span> + product;    Y = product.charAt(<span class="hljs-number">28</span>) + Y.substring(<span class="hljs-number">0</span>, <span class="hljs-number">28</span>);    product = product.substring(<span class="hljs-number">0</span>, <span class="hljs-number">28</span>);  &#125;  <span class="hljs-keyword">return</span> product;&#125;</code></pre><p>参数均是28位（1位规格化隐藏+23位fraction+4位保护位）。这里使用了ppt上的算法，当Y最后一位为1的时候，将部分积的第一位置为1，然后右移；反之置为0，再左移。得到的结果应当为部分积（也是28位），在mul中会被切割整理。以上的操作都是竖式乘法的一种实现，可以用该思路辅助理解。</p><p>ppt截图：</p><p><img src="/img/COA/FloatMul.jpg" alt=""></p><h3 id="浮点数除法"><a href="#浮点数除法" class="headerlink" title="浮点数除法"></a>浮点数除法</h3><h4 id="1-判断特殊情况"><a href="#1-判断特殊情况" class="headerlink" title="1. 判断特殊情况"></a>1. 判断特殊情况</h4><p>当被除数为0且除数也为0的时候，结果为NaN。除此之外，当被除数为0的时候，结果也为0（注意判断符号）；当除数为0的时候抛出错误。</p><pre><code class="hljs java">String ansExp;String ansFrac;<span class="hljs-keyword">char</span> signA = a.charAt(<span class="hljs-number">0</span>);<span class="hljs-keyword">char</span> signB = b.charAt(<span class="hljs-number">0</span>);String ansSign = (signA == signB)? <span class="hljs-string">&quot;0&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>;<span class="hljs-keyword">if</span>(b.startsWith(<span class="hljs-string">&quot;0000000000000000000000000000000&quot;</span>, <span class="hljs-number">1</span>))&#123;  <span class="hljs-keyword">if</span>(a.equals(IEEE754Float.N_ZERO) || a.equals(IEEE754Float.P_ZERO))&#123;    <span class="hljs-keyword">return</span> IEEE754Float.NaN;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArithmeticException();  &#125;&#125;<span class="hljs-keyword">if</span>(a.startsWith(<span class="hljs-string">&quot;0000000000000000000000000000000&quot;</span>, <span class="hljs-number">1</span>))&#123;  <span class="hljs-keyword">return</span> ansSign + <span class="hljs-string">&quot;0000000000000000000000000000000&quot;</span>;&#125;</code></pre><h4 id="2-处理参数-1"><a href="#2-处理参数-1" class="headerlink" title="2. 处理参数"></a>2. 处理参数</h4><p>处理的操作和乘法一致</p><pre><code class="hljs java">String expA = a.substring(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>);String expB = b.substring(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>);String bitA = (expA.equals(<span class="hljs-string">&quot;00000000&quot;</span>))? <span class="hljs-string">&quot;0&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>;String bitB = (expB.equals(<span class="hljs-string">&quot;00000000&quot;</span>))? <span class="hljs-string">&quot;0&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>;String fracA = a.substring(<span class="hljs-number">9</span>);String fracB = b.substring(<span class="hljs-number">9</span>);String countA = bitA + fracA + <span class="hljs-string">&quot;0000&quot;</span>; <span class="hljs-comment">//28</span>String countB = bitB + fracB + <span class="hljs-string">&quot;0000&quot;</span>;String tmp = sub(expB, expA);</code></pre><h4 id="3-判断阶码的情况"><a href="#3-判断阶码的情况" class="headerlink" title="3. 判断阶码的情况"></a>3. 判断阶码的情况</h4><p>除法在阶码之间发生减法的时候，不会出现上溢出的情况。得到的结果范围是-254～254。如果得到了负数，则CF置为1。因为减法会将127抵消，因此得到的结果需要再加上一个127。<strong>这个时候阶码还是会有可能上溢的！</strong>但好像本次编程作业没有考虑这个情况，因此希望大家注意！</p><p>上溢出的情况是减法不借位，即第一次CF为1，加法进位，第二次的CF为1。得到的结果是无穷。</p><p>下溢出的情况是减法借位而加法不进位，即两次的CF均为0。得到的结果是0。</p><pre><code class="hljs java">String tmp = sub(expB, expA);<span class="hljs-comment">//CF 判断有没有溢出；</span><span class="hljs-keyword">char</span> tmpCF = CF;ansExp = add(<span class="hljs-string">&quot;01111111&quot;</span>, tmp);<span class="hljs-comment">//CF 判断有没有借位；</span><span class="hljs-keyword">if</span>(tmpCF == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; CF == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;  <span class="hljs-keyword">return</span> ansSign + <span class="hljs-string">&quot;0000000000000000000000000000000&quot;</span>;&#125;<span class="hljs-keyword">if</span>(tmpCF == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; CF == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;  <span class="hljs-keyword">return</span> ansSign + <span class="hljs-string">&quot;1111111100000000000000000000000&quot;</span>;&#125;</code></pre><h4 id="计算小数部分"><a href="#计算小数部分" class="headerlink" title="计算小数部分"></a>计算小数部分</h4><pre><code class="hljs java">ansFrac = divFrac(countB, countA).substring(<span class="hljs-number">0</span>, <span class="hljs-number">24</span>);<span class="hljs-comment">//Normalize</span><span class="hljs-keyword">while</span> (ansFrac.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; !ansExp.equals(<span class="hljs-string">&quot;00000000&quot;</span>))&#123;  ansFrac = ansFrac.substring(<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;0&quot;</span>;  ansExp = sub(<span class="hljs-string">&quot;00000001&quot;</span>, ansExp);&#125;ansFrac = ansFrac.substring(<span class="hljs-number">1</span>, <span class="hljs-number">24</span>);<span class="hljs-keyword">return</span> ansSign + ansExp + ansFrac;</code></pre><p>规格化不多赘述</p><p>重点是下面的小数部分除法。我们需要一个余数部分remainder，商quotient。<strong>对参数我们都在前面加上一位0。</strong></p><p>因为小数可能会出现无法除尽的情况。倘若只有28位，<strong>当remainder的最高位为1且不能减去除数的时候</strong>，最高位的1就会在左移之后消失，产生错误。因此这个最高位的1需要保留到下一次减法。现在的remainder是29位的，src，也就是除数，是28位的（第29位被我们手动置为0），所以当remainder的最高位为1的时候，remainder一定会大于src（除数），因此肯定可以使得减法进行。</p><p>这里首先减去除数，一旦减多了，就把除数加回来。怎么判断减多了？利用刚才仔细分析的CF。一旦CF为0，即减法需要借位，则说明减多了；一旦CF为1，说明“enough“，减对了。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">divFrac</span> <span class="hljs-params">(String src, String dest)</span></span>&#123;  String remainder = <span class="hljs-string">&quot;0&quot;</span> + dest;  String quotient = <span class="hljs-string">&quot;00000000000000000000000000000&quot;</span>;  src = <span class="hljs-string">&quot;0&quot;</span> + src;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">29</span>; i++)&#123;    remainder = sub(src, remainder);    <span class="hljs-keyword">char</span> tmp = quotient.charAt(<span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span>(CF == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;      quotient = quotient.substring(<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;1&quot;</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      remainder = add(src, remainder);      quotient = quotient.substring(<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;0&quot;</span>;    &#125;    remainder = remainder.substring(<span class="hljs-number">1</span>) + tmp;  &#125;  <span class="hljs-keyword">return</span> quotient;&#125;</code></pre><p>ppt截图：</p><p><img src="/img/COA/FloatMul.jpg" alt=""></p><h3 id="完整代码（包括辅助函数）"><a href="#完整代码（包括辅助函数）" class="headerlink" title="完整代码（包括辅助函数）"></a>完整代码（包括辅助函数）</h3><pre><code class="hljs java"><span class="hljs-function">String <span class="hljs-title">mul</span><span class="hljs-params">(String a, String b)</span> </span>&#123;  <span class="hljs-keyword">if</span>(Pattern.matches(a, IEEE754Float.NaN) || Pattern.matches(b, IEEE754Float.NaN))&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NaN&quot;</span>;  &#125;  String ansExp;  String ansFrac;  <span class="hljs-keyword">char</span> signA = a.charAt(<span class="hljs-number">0</span>);  <span class="hljs-keyword">char</span> signB = b.charAt(<span class="hljs-number">0</span>);  String ansSign = (signA == signB)? <span class="hljs-string">&quot;0&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>;  <span class="hljs-keyword">if</span>(a.equals(IEEE754Float.N_ZERO) || b.equals(IEEE754Float.N_ZERO)     || a.equals(IEEE754Float.P_ZERO) || b.equals(IEEE754Float.P_ZERO))&#123;    <span class="hljs-keyword">if</span>(Pattern.matches(a, IEEE754Float.NaN) || Pattern.matches(b, IEEE754Float.NaN))&#123;      <span class="hljs-keyword">return</span> IEEE754Float.NaN;    &#125;    <span class="hljs-keyword">if</span>(a.startsWith(<span class="hljs-string">&quot;11111111&quot;</span>, <span class="hljs-number">1</span>) || b.startsWith(<span class="hljs-string">&quot;11111111&quot;</span>, <span class="hljs-number">1</span>))&#123;      <span class="hljs-keyword">return</span> IEEE754Float.NaN;    &#125;    <span class="hljs-keyword">return</span> ansSign + <span class="hljs-string">&quot;0000000000000000000000000000000&quot;</span>;  &#125;  String expA = a.substring(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>);  String expB = b.substring(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>);  String bitA = (expA.equals(<span class="hljs-string">&quot;00000000&quot;</span>))? <span class="hljs-string">&quot;0&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>;  String bitB = (expB.equals(<span class="hljs-string">&quot;00000000&quot;</span>))? <span class="hljs-string">&quot;0&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>;  String fracA = a.substring(<span class="hljs-number">9</span>);  String fracB = b.substring(<span class="hljs-number">9</span>);  String countA = bitA + fracA + <span class="hljs-string">&quot;0000&quot;</span>; <span class="hljs-comment">//28</span>  String countB = bitB + fracB + <span class="hljs-string">&quot;0000&quot;</span>;  String tmp = add(expA, expB);  <span class="hljs-comment">//CF 判断有没有溢出；</span>  <span class="hljs-keyword">char</span> tmpCF = CF;  ansExp = sub(<span class="hljs-string">&quot;01111111&quot;</span>, tmp);  <span class="hljs-comment">//CF 判断有没有借位；</span>  <span class="hljs-keyword">if</span>((tmpCF==<span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; CF==<span class="hljs-string">&#x27;1&#x27;</span>) || ansExp.equals(<span class="hljs-string">&quot;11111111&quot;</span>))&#123; <span class="hljs-comment">//一开始溢出了但是没有借位，说明</span>    <span class="hljs-keyword">if</span>(signA==signB) <span class="hljs-keyword">return</span> IEEE754Float.P_INF;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> IEEE754Float.N_INF;  &#125;  <span class="hljs-keyword">if</span>(tmpCF==<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; CF==<span class="hljs-string">&#x27;0&#x27;</span>)&#123; <span class="hljs-comment">//一开始没有溢出，但是有借位</span>    <span class="hljs-keyword">if</span>(signA==signB) <span class="hljs-keyword">return</span> IEEE754Float.P_ZERO;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> IEEE754Float.N_ZERO;  &#125;  ansFrac = mulFrac(countA, countB).substring(<span class="hljs-number">1</span>, <span class="hljs-number">25</span>);  <span class="hljs-comment">//Normalize</span>  <span class="hljs-keyword">while</span> (ansFrac.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; !ansExp.equals(<span class="hljs-string">&quot;00000000&quot;</span>))&#123;    ansFrac = ansFrac.substring(<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;0&quot;</span>;    ansExp = sub(<span class="hljs-string">&quot;00000001&quot;</span>, ansExp);  &#125;  ansFrac = ansFrac.substring(<span class="hljs-number">1</span>, <span class="hljs-number">24</span>);  <span class="hljs-keyword">return</span> ansSign + ansExp + ansFrac;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">     * compute the float mul of a / b</span><span class="hljs-comment">     */</span><span class="hljs-function">String <span class="hljs-title">div</span><span class="hljs-params">(String a, String b)</span> </span>&#123;  String ansExp;  String ansFrac;  <span class="hljs-keyword">char</span> signA = a.charAt(<span class="hljs-number">0</span>);  <span class="hljs-keyword">char</span> signB = b.charAt(<span class="hljs-number">0</span>);  String ansSign = (signA == signB)? <span class="hljs-string">&quot;0&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>;  <span class="hljs-keyword">if</span>(b.startsWith(<span class="hljs-string">&quot;0000000000000000000000000000000&quot;</span>, <span class="hljs-number">1</span>))&#123;    <span class="hljs-keyword">if</span>(a.equals(IEEE754Float.N_ZERO) || a.equals(IEEE754Float.P_ZERO))&#123;      <span class="hljs-keyword">return</span> IEEE754Float.NaN;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArithmeticException();    &#125;  &#125;  <span class="hljs-keyword">if</span>(a.startsWith(<span class="hljs-string">&quot;0000000000000000000000000000000&quot;</span>, <span class="hljs-number">1</span>))&#123;    <span class="hljs-keyword">return</span> ansSign + <span class="hljs-string">&quot;0000000000000000000000000000000&quot;</span>;  &#125;  String expA = a.substring(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>);  String expB = b.substring(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>);  String bitA = (expA.equals(<span class="hljs-string">&quot;00000000&quot;</span>))? <span class="hljs-string">&quot;0&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>;  String bitB = (expB.equals(<span class="hljs-string">&quot;00000000&quot;</span>))? <span class="hljs-string">&quot;0&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>;  String fracA = a.substring(<span class="hljs-number">9</span>);  String fracB = b.substring(<span class="hljs-number">9</span>);  String countA = bitA + fracA + <span class="hljs-string">&quot;0000&quot;</span>; <span class="hljs-comment">//28</span>  String countB = bitB + fracB + <span class="hljs-string">&quot;0000&quot;</span>;  String tmp = sub(expB, expA);  <span class="hljs-comment">//CF 判断有没有溢出；</span>  <span class="hljs-keyword">char</span> tmpCF = CF;  ansExp = add(<span class="hljs-string">&quot;01111111&quot;</span>, tmp);  <span class="hljs-comment">//CF 判断有没有借位；</span>  <span class="hljs-keyword">if</span>(tmpCF == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; CF == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;    <span class="hljs-keyword">return</span> ansSign + <span class="hljs-string">&quot;0000000000000000000000000000000&quot;</span>;  &#125;  <span class="hljs-keyword">if</span>(tmpCF == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; CF == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;    <span class="hljs-keyword">return</span> ansSign + <span class="hljs-string">&quot;1111111100000000000000000000000&quot;</span>;  &#125;  ansFrac = divFrac(countB, countA).substring(<span class="hljs-number">0</span>, <span class="hljs-number">24</span>);  <span class="hljs-comment">//Normalize</span>  <span class="hljs-keyword">while</span> (ansFrac.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; !ansExp.equals(<span class="hljs-string">&quot;00000000&quot;</span>))&#123;    ansFrac = ansFrac.substring(<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;0&quot;</span>;    ansExp = sub(<span class="hljs-string">&quot;00000001&quot;</span>, ansExp);  &#125;  ansFrac = ansFrac.substring(<span class="hljs-number">1</span>, <span class="hljs-number">24</span>);  <span class="hljs-keyword">return</span> ansSign + ansExp + ansFrac;&#125;<span class="hljs-function">String <span class="hljs-title">add</span><span class="hljs-params">(String src, String dest)</span> </span>&#123;  <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;  <span class="hljs-keyword">char</span>[] srcArr = src.toCharArray();  <span class="hljs-keyword">char</span>[] destArr = dest.toCharArray();  <span class="hljs-keyword">int</span> len = srcArr.length;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=len-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;    <span class="hljs-keyword">if</span>(srcArr[i]==<span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; destArr[i]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;      destArr[i] = (carry==<span class="hljs-number">1</span>)? <span class="hljs-string">&#x27;1&#x27;</span>:<span class="hljs-string">&#x27;0&#x27;</span>;      carry = <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (srcArr[i]==<span class="hljs-string">&#x27;1&#x27;</span> || destArr[i]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;      <span class="hljs-keyword">if</span>(carry==<span class="hljs-number">1</span>)&#123;        destArr[i] = <span class="hljs-string">&#x27;0&#x27;</span>;      &#125; <span class="hljs-keyword">else</span> &#123;        destArr[i] = <span class="hljs-string">&#x27;1&#x27;</span>;        carry = <span class="hljs-number">0</span>;      &#125;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (carry == <span class="hljs-number">1</span>)&#123;      destArr[i] = <span class="hljs-string">&#x27;1&#x27;</span>;      carry = <span class="hljs-number">0</span>;    &#125;  &#125;  <span class="hljs-keyword">this</span>.CF = (carry == <span class="hljs-number">1</span>)? <span class="hljs-string">&#x27;1&#x27;</span>:<span class="hljs-string">&#x27;0&#x27;</span>;  <span class="hljs-keyword">return</span> String.valueOf(destArr);&#125;<span class="hljs-function">String <span class="hljs-title">sub</span><span class="hljs-params">(String src, String dest)</span> </span>&#123;  <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;  <span class="hljs-keyword">char</span>[] srcArr = src.toCharArray();  <span class="hljs-keyword">char</span>[] destArr = dest.toCharArray();  <span class="hljs-keyword">int</span> len = srcArr.length;  <span class="hljs-keyword">int</span> flg = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=len-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;    <span class="hljs-keyword">if</span>(flg == <span class="hljs-number">1</span>)&#123;      srcArr[i] = (srcArr[i]==<span class="hljs-string">&#x27;0&#x27;</span>)? <span class="hljs-string">&#x27;1&#x27;</span>:<span class="hljs-string">&#x27;0&#x27;</span>;    &#125;    <span class="hljs-keyword">if</span>(srcArr[i]!=<span class="hljs-string">&#x27;0&#x27;</span>)&#123;      flg = <span class="hljs-number">1</span>;    &#125;  &#125;  <span class="hljs-keyword">return</span> add(String.valueOf(srcArr), dest);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">mulFrac</span> <span class="hljs-params">(String src, String dest)</span></span>&#123;  String Y = dest;  String product = <span class="hljs-string">&quot;0000000000000000000000000000&quot;</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">28</span>; i++)&#123;    <span class="hljs-keyword">if</span>(Y.charAt(<span class="hljs-number">27</span>) == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;      product = add(src, product);    &#125;    product = <span class="hljs-string">&quot;0&quot;</span> + product;    Y = product.charAt(<span class="hljs-number">28</span>) + Y.substring(<span class="hljs-number">0</span>, <span class="hljs-number">28</span>);    product = product.substring(<span class="hljs-number">0</span>, <span class="hljs-number">28</span>);  &#125;  <span class="hljs-keyword">return</span> product;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">divFrac</span> <span class="hljs-params">(String src, String dest)</span></span>&#123;  String remainder = <span class="hljs-string">&quot;0&quot;</span> + dest;  String quotient = <span class="hljs-string">&quot;00000000000000000000000000000&quot;</span>;  src = <span class="hljs-string">&quot;0&quot;</span> + src;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">29</span>; i++)&#123;    remainder = sub(src, remainder);    <span class="hljs-keyword">char</span> tmp = quotient.charAt(<span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span>(CF == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;      quotient = quotient.substring(<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;1&quot;</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      remainder = add(src, remainder);      quotient = quotient.substring(<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;0&quot;</span>;    &#125;    remainder = remainder.substring(<span class="hljs-number">1</span>) + tmp;  &#125;  <span class="hljs-keyword">return</span> quotient;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>WeeklyReview</tag>
      
      <tag>Integer</tag>
      
      <tag>COA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Integer-Arithmetic-Review-mul&amp;div</title>
    <link href="/2020/11/06/Integer-Arithmetic-Review/"/>
    <url>/2020/11/06/Integer-Arithmetic-Review/</url>
    
    <content type="html"><![CDATA[<h2 id="整数乘除运算编程作业总结"><a href="#整数乘除运算编程作业总结" class="headerlink" title="整数乘除运算编程作业总结"></a>整数乘除运算编程作业总结</h2><h5 id="注：本地作业调用的函数均为以前使用过的add、sub、neg"><a href="#注：本地作业调用的函数均为以前使用过的add、sub、neg" class="headerlink" title="注：本地作业调用的函数均为以前使用过的add、sub、neg"></a>注：本地作业调用的函数均为以前使用过的add、sub、neg</h5><h3 id="整数乘法"><a href="#整数乘法" class="headerlink" title="整数乘法"></a>整数乘法</h3><p>从代码结构上来看乘法十分简单，但是我们还是要好好复习一下部分积和布斯乘法的概念。</p><p><img src="/img/COA/Booth.jpg" alt=""></p><p>首先把其中的一个乘数按各位展开。</p><script type="math/tex; mode=display">2^n = 2^{n+1}-2^n</script><p>进行如上所示的变换。拆开括号二次组合，因此就可以得到一个合式。</p><script type="math/tex; mode=display">\sum_{i=0}^{n-1}(X×(Y_i-Y_{i+1})×2^{-(n-i)})</script><p>因此每一项的P都可以表示成为：</p><script type="math/tex; mode=display">P_{i+1}=2^{-1}×(P_i + X×(Y_i-Y_{i+1}))</script><p>在上面，首先，为了满足变换的条件，需要添加上一个Y0。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">mul</span> <span class="hljs-params">(String src, String dest)</span></span>&#123;  dest = dest + <span class="hljs-string">&quot;0&quot;</span>;  String product = <span class="hljs-string">&quot;00000000000000000000000000000000&quot;</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">32</span>; i++)&#123;    <span class="hljs-keyword">char</span> Y = dest.charAt(<span class="hljs-number">32</span>);    <span class="hljs-keyword">char</span> Yi = dest.charAt(<span class="hljs-number">31</span>);    <span class="hljs-keyword">if</span>(Y - Yi == <span class="hljs-number">1</span>)&#123;      product = add(src, product);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Y - Yi == -<span class="hljs-number">1</span>) &#123;      product = sub(src, product);    &#125;    dest = product.charAt(<span class="hljs-number">31</span>) + dest.substring(<span class="hljs-number">0</span>, <span class="hljs-number">32</span>);    product = product.charAt(<span class="hljs-number">0</span>) + product.substring(<span class="hljs-number">0</span>, <span class="hljs-number">31</span>);  &#125;  String ret = product + dest.substring(<span class="hljs-number">0</span>, <span class="hljs-number">32</span>);  <span class="hljs-keyword">return</span> ret.substring(<span class="hljs-number">32</span>, <span class="hljs-number">64</span>);&#125;</code></pre><p>然后，进行32次循环。每一次循环根据两个Y的差来判断是加上还是减去另一个乘数。然后右移部分积和返回结果。</p><h3 id="整数除法"><a href="#整数除法" class="headerlink" title="整数除法"></a>整数除法</h3><p>除法相比较来说会烦人很多。</p><p>因为被除数的正负问题，我将除法分成两个部分处理。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">div</span><span class="hljs-params">(String operand1, String operand2)</span> </span>&#123;  <span class="hljs-comment">//TODO</span>  <span class="hljs-keyword">if</span>(operand2.equals(BinaryIntegers.ZERO))&#123;    <span class="hljs-keyword">if</span>(operand1.equals(BinaryIntegers.ZERO))&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NaN&quot;</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArithmeticException();    &#125;  &#125;  String overflow = <span class="hljs-string">&quot;0&quot;</span>;  <span class="hljs-keyword">if</span>(operand1.equals(IEEE754Float.N_ZERO) &amp;&amp; operand2.equals(BinaryIntegers.NegativeOne))&#123;    overflow = <span class="hljs-string">&quot;1&quot;</span>;  &#125;  <span class="hljs-keyword">char</span> aSign = operand1.charAt(<span class="hljs-number">0</span>);  <span class="hljs-keyword">char</span> bSign = operand2.charAt(<span class="hljs-number">0</span>);  <span class="hljs-keyword">if</span>(bSign == <span class="hljs-string">&#x27;1&#x27;</span>) operand2 = Neg(operand2);  String[] ans;  <span class="hljs-keyword">if</span>(aSign==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;    ans = posDiv(operand1, operand2);    <span class="hljs-keyword">if</span>(bSign==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;      ans[<span class="hljs-number">1</span>] = Neg(ans[<span class="hljs-number">1</span>]);    &#125;  &#125; <span class="hljs-keyword">else</span>&#123;    ans = negDiv(operand1, operand2);    <span class="hljs-keyword">if</span>(bSign==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;      ans[<span class="hljs-number">1</span>] = Neg(ans[<span class="hljs-number">1</span>]);    &#125;  &#125;  <span class="hljs-keyword">return</span> overflow + ans[<span class="hljs-number">1</span>] + ans[<span class="hljs-number">0</span>];&#125;</code></pre><p>首先需要特判一些边界情况。</p><pre><code class="hljs java"><span class="hljs-keyword">if</span>(operand2.equals(BinaryIntegers.ZERO))&#123;  <span class="hljs-keyword">if</span>(operand1.equals(BinaryIntegers.ZERO))&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NaN&quot;</span>;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArithmeticException();  &#125;&#125;</code></pre><p>如果被除数和除数都为0，那么得到的结果将会是“NaN”。如果被除数不为0，而除数为0，那么将会产生除法错，抛出ArithmeticException。</p><p>关于溢出位，在x86体系中，我们判断除法是否溢出的方法是判断被除数的高位是否比被除数要大。在本次编程作业中，我们需要判断的是一个特殊情况——最小负数即-2<sup>31</sup>除以-1溢出。</p><pre><code class="hljs java">String overflow = <span class="hljs-string">&quot;0&quot;</span>;<span class="hljs-keyword">if</span>(operand1.equals(IEEE754Float.N_ZERO) &amp;&amp; operand2.equals(BinaryIntegers.NegativeOne))&#123;  overflow = <span class="hljs-string">&quot;1&quot;</span>;&#125;</code></pre><p>之后我们要记录下被除数和除数的符号，方便后续的比较。并且将负的除数转化为正数。这里要提到的是，除法运算中，同号得正，异号得负，仅需要在结果处判断即可。</p><p>因此，我们根据被除数的正负分别调用除法处理函数。（因为需要返回商和余数，所以返回值使用了String数组）</p><pre><code class="hljs java"><span class="hljs-keyword">if</span>(aSign==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;  ans = posDiv(operand1, operand2);  <span class="hljs-keyword">if</span>(bSign==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;    ans[<span class="hljs-number">1</span>] = Neg(ans[<span class="hljs-number">1</span>]);  &#125;&#125; <span class="hljs-keyword">else</span>&#123;  ans = negDiv(operand1, operand2);  <span class="hljs-keyword">if</span>(bSign==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;    ans[<span class="hljs-number">1</span>] = Neg(ans[<span class="hljs-number">1</span>]);  &#125;&#125;</code></pre><p>首先来介绍正数除法处理函数：</p><pre><code class="hljs java">String[] posDiv(String quotient, String division)&#123;  String[] ans = <span class="hljs-keyword">new</span> String[<span class="hljs-number">2</span>];  String remainder = <span class="hljs-string">&quot;00000000000000000000000000000000&quot;</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">32</span>; i++)&#123;    remainder = remainder.substring(<span class="hljs-number">1</span>) + quotient.charAt(<span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span>(sub(division, remainder).charAt(<span class="hljs-number">0</span>) != remainder.charAt(<span class="hljs-number">0</span>))&#123;      quotient = quotient.substring(<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;0&quot;</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      quotient = quotient.substring(<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;1&quot;</span>;      remainder = sub(division, remainder);    &#125;  &#125;  ans[<span class="hljs-number">0</span>] = remainder;  ans[<span class="hljs-number">1</span>] = quotient;  <span class="hljs-keyword">return</span> ans;&#125;</code></pre><p>首先在被除数前方补上n个0，作为余数。</p><p>想象一个除法竖式的操作。</p><p>首先，我们左移一位余数和商，如果余数减去除数仍为正数，那么这一位在商处得到1，如果为负数，得到0。</p><p>重复32次结束。在余数处剩下的就是整个计算的余数。</p><p>下面来看看负数的处理，相比较来说就要复杂一些。</p><pre><code class="hljs java">String[] negDiv(String quotient, String division)&#123;  String[] ans = <span class="hljs-keyword">new</span> String[<span class="hljs-number">2</span>];  String remainder = <span class="hljs-string">&quot;11111111111111111111111111111111&quot;</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;quotient.length(); i++)&#123;    remainder = remainder.substring(<span class="hljs-number">1</span>) + quotient.charAt(<span class="hljs-number">0</span>);    remainder = add(remainder, division);    <span class="hljs-keyword">if</span>(CF.equals(<span class="hljs-string">&quot;1&quot;</span>))&#123;      <span class="hljs-comment">//余数和除数之间的操作变成了加法，所以如果错加了一个除数，我们需要把它减回去。</span>      remainder = sub(division, remainder);      quotient = quotient.substring(<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;0&quot;</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      quotient = quotient.substring(<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;1&quot;</span>;    &#125;  &#125;  <span class="hljs-keyword">if</span>(add(remainder, division).equals(BinaryIntegers.ZERO))&#123;    remainder = BinaryIntegers.ZERO;    quotient = add(<span class="hljs-string">&quot;00000000000000000000000000000001&quot;</span>, quotient);  &#125;  ans[<span class="hljs-number">0</span>] = remainder;  ans[<span class="hljs-number">1</span>] = quotient;  <span class="hljs-keyword">return</span> ans;&#125;</code></pre><p>大致原理和正数并没有区别。只不过因为符号位为1，所以最高位之前补上的是32个1。余数和除数之间的操作变成了加法，所以如果错加了一个除数，我们需要把它减回去。</p><p>不过最后为什么有一个特判呢？</p><p>因为在正数的处理中，正数减一个数为0是很正常的并且不需要改变符号位，所以余数为0的情况可以被处理到。</p><p>而在负数中并不如此，余数全部为1的情况下，它的基准就会是-1。每当我们想做负数的除法整除操作时，差的这一位1经常会make trouble。</p><p>这怎么办呢……</p><p>首先先想想，如果不是整除的情况下，我们的除法计算是不是好的？【No matter whether it’s right or not, it works!】在正数除法中，我们的余数取值范围是0～2<sup>31</sup>-1，而负数除法中是-1～-2<sup>31</sup>，所以我们更倾向于留下的负数是-1！我们在设计除法运算的时候，就没考虑整除现象的产生。</p><p>怎么办？减去1让除法先算了，再加回去并且把余数置为0呗……</p><pre><code class="hljs java"><span class="hljs-keyword">if</span>(add(remainder, division).equals(BinaryIntegers.ZERO))&#123;  remainder = BinaryIntegers.ZERO;  quotient = add(<span class="hljs-string">&quot;00000000000000000000000000000001&quot;</span>, quotient);&#125;</code></pre><p>大致如此啦！( ´▽` )ﾉ</p>]]></content>
    
    
    
    <tags>
      
      <tag>WeeklyReview</tag>
      
      <tag>Integer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Floating-point-Arithmetic-Review</title>
    <link href="/2020/11/02/Floating-point-Arithmetic-Review/"/>
    <url>/2020/11/02/Floating-point-Arithmetic-Review/</url>
    
    <content type="html"><![CDATA[<h2 id="浮点数运算编程作业总结"><a href="#浮点数运算编程作业总结" class="headerlink" title="浮点数运算编程作业总结"></a>浮点数运算编程作业总结</h2><p>基本的运算流程按照ppt上的流程图来实现：</p><p><img src="/img/浮点数运算.jpg" alt=""></p><p>因为IEEE 754表示浮点数的特性，对于浮点数来说，整数和负数之间的差别就只有第一位的符号位。所以对于减法来说，只要将减数的符号变换，即可转换为加法！</p><pre><code class="hljs java"><span class="hljs-function">String <span class="hljs-title">sub</span><span class="hljs-params">(String a,String b)</span></span>&#123;  <span class="hljs-comment">// TODO</span>  b = (b.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">&#x27;0&#x27;</span>)? (<span class="hljs-string">&quot;1&quot;</span>.concat(b.substring(<span class="hljs-number">1</span>))) : (<span class="hljs-string">&quot;0&quot;</span>.concat(b.substring(<span class="hljs-number">1</span>)));  <span class="hljs-keyword">return</span> add(a, b);&#125;</code></pre><p>下面对加法的整个过程进行细致的分析，因此会把整个方法拆分成几个部分，完整的函数在本页的最后给出！(因为仅仅作为作业提交，整个代码不考虑效率、安全、耦合性和冗余程度，并且有一些溢出没有考虑判断，前排提醒！也许以后有机会可以重写x)</p><pre><code class="hljs java"><span class="hljs-keyword">if</span>(a.startsWith(<span class="hljs-string">&quot;0000000000000000000000000000000&quot;</span>, <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> b;<span class="hljs-keyword">if</span>(b.startsWith(<span class="hljs-string">&quot;0000000000000000000000000000000&quot;</span>, <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> a;</code></pre><p>首先，对于a或者b等于0的情况进行判断！如果其中的一个等于0，那么返回另一个即可！</p><pre><code class="hljs java"><span class="hljs-comment">//取a和b的阶码；</span>String aExp = a.substring(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>);String bExp = b.substring(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>);<span class="hljs-comment">//取出符号位；</span><span class="hljs-keyword">char</span> aSign = a.charAt(<span class="hljs-number">0</span>);<span class="hljs-keyword">char</span> bSign = b.charAt(<span class="hljs-number">0</span>);<span class="hljs-comment">//取出尾数；</span>String aFriction = a.substring(<span class="hljs-number">9</span>);String bFriction = b.substring(<span class="hljs-number">9</span>);<span class="hljs-comment">//以下只是为了简化代码将阶码转化为了整数，为了方便循环的写法；</span><span class="hljs-keyword">int</span> expA = unsignedVal(aExp);<span class="hljs-keyword">int</span> expB = unsignedVal(bExp);<span class="hljs-comment">//将规格化数的1补上，非规格化的0补上；</span>aFriction = (expA == <span class="hljs-number">0</span>)? (<span class="hljs-string">&quot;0&quot;</span>+aFriction):(<span class="hljs-string">&quot;1&quot;</span>+aFriction);bFriction = (expB == <span class="hljs-number">0</span>)? (<span class="hljs-string">&quot;0&quot;</span>+bFriction):(<span class="hljs-string">&quot;1&quot;</span>+bFriction);<span class="hljs-comment">//添加上保护位！</span>aFriction = aFriction + <span class="hljs-string">&quot;0000&quot;</span>; <span class="hljs-comment">//guardBits!</span>bFriction = bFriction + <span class="hljs-string">&quot;0000&quot;</span>; <span class="hljs-comment">//guardBits!</span></code></pre><p>以上的操作相当于是对两个浮点数的机器级表示对预处理。下面进行对阶的操作。</p><pre><code class="hljs java"><span class="hljs-comment">//flg的作用是为了知道究竟是操作a和b中的哪一个阶码来对阶的。</span><span class="hljs-keyword">int</span> flg = <span class="hljs-number">0</span>;<span class="hljs-comment">//对阶操作。</span><span class="hljs-keyword">while</span> (expA &lt; expB)&#123;  flg = <span class="hljs-number">1</span>;  aExp = alu.add(<span class="hljs-string">&quot;00000001&quot;</span>, aExp);  expA++;  aFriction = <span class="hljs-string">&quot;0&quot;</span> + aFriction;&#125;<span class="hljs-keyword">while</span> (expB &lt; expA)&#123;  flg = <span class="hljs-number">2</span>;  bExp = alu.add(<span class="hljs-string">&quot;00000001&quot;</span>, bExp);  expB++;  bFriction = <span class="hljs-string">&quot;0&quot;</span> + bFriction;&#125;<span class="hljs-keyword">if</span>(flg == <span class="hljs-number">1</span>)&#123;  <span class="hljs-keyword">if</span>(aFriction.startsWith(<span class="hljs-string">&quot;00000000000000000000000&quot;</span>, <span class="hljs-number">1</span>))     <span class="hljs-keyword">return</span> b;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(flg == <span class="hljs-number">2</span>)&#123;  <span class="hljs-keyword">if</span>(bFriction.startsWith(<span class="hljs-string">&quot;00000000000000000000000&quot;</span>, <span class="hljs-number">1</span>))     <span class="hljs-keyword">return</span> a;&#125;</code></pre><p>我使用的while循环来进行对阶，将阶码较小的向大的对齐【注意，现在的尾数部分已经是包含规格化补上的“1”或者“0”以及保护位的了】，我右移尾数部分的方法是在尾数前面补0，最后取前28位（1位补上，23位尾数部分，4位保护位】。flg设置的意义：判断是谁进行的对阶，然后判断它的尾数有没有变成0（此时，阶码已经对齐）！一旦它变成0，返回的结果就是另一个数。</p><pre><code class="hljs java"><span class="hljs-comment">//取前28位 1位规格化/非规格化，23位尾数，4位保护位；</span>aFriction = aFriction.substring(<span class="hljs-number">0</span>, <span class="hljs-number">28</span>);bFriction = bFriction.substring(<span class="hljs-number">0</span>, <span class="hljs-number">28</span>);<span class="hljs-comment">//Sign them!</span>aFriction = <span class="hljs-string">&quot;00&quot;</span> + aFriction;bFriction = <span class="hljs-string">&quot;00&quot;</span> + bFriction;StringBuilder ansBuilder = <span class="hljs-keyword">new</span> StringBuilder();String ansFriction;<span class="hljs-keyword">if</span>(aSign == bSign)&#123;  ansFriction = alu.add(aFriction, bFriction);&#125; <span class="hljs-keyword">else</span> &#123;  ansFriction = alu.sub(bFriction, aFriction); &#125;</code></pre><p>这里为什么要在小数位前面加上两个0呢？首先，我们之后要对尾数部分进行加减运算，因为我们要进行的是带符号运算，因此，我们应该补充上至少一个符号位。所以最左边的0是作为符号位的。那么第二个0，就是用来判断加减之后是否溢出的。</p><p>对于异号加法，我们转化为同号减法；对于同号，直接做加法。</p><p>如果想加减之后等于0，那么计算结果为0，返回0！</p><pre><code class="hljs java"><span class="hljs-keyword">if</span>(ansFriction.equals(<span class="hljs-string">&quot;000000000000000000000000000000&quot;</span>))&#123;  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;00000000000000000000000000000000&quot;</span>;&#125;</code></pre><p>针对符号位，首先我们应该明白一件事：<strong>两个正数或者负数之间的减法不会发生溢出。</strong>所以，对于加法来说，这个溢出位只判断同符号数相加之后是否溢出。</p><pre><code class="hljs java"><span class="hljs-keyword">if</span>(aSign == bSign)&#123;  ansBuilder.append(aSign);&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-keyword">if</span>(ansFriction.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;    <span class="hljs-comment">//a + b</span>    <span class="hljs-keyword">if</span>(aSign == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;      ansBuilder.append(<span class="hljs-string">&quot;0&quot;</span>);    &#125; <span class="hljs-keyword">else</span> &#123;      ansBuilder.append(<span class="hljs-string">&quot;1&quot;</span>);    &#125;    ansFriction = Neg(ansFriction);  &#125; <span class="hljs-keyword">else</span> &#123;    ansBuilder.append(aSign);  &#125;&#125;</code></pre><p>当a与b的符号相同时，发生的是加法，并且两个数的尾数都是正数。所以结果的符号直接与a或b相同即可。当a和b异号的时候，我们需要知道的是a和b之间的差。通过减法，再将得到的结果取绝对值，就可以得到它们的差。至于符号，我们靠上面的代码来判断：注意，我们上面是用a减去b。<strong>那么如果得到的结果是负数并且a是负数，说明a的绝对值小于b的绝对值，a+b得到的是正数。</strong>所以我们将返回值的符号位设为和b相同即可（谁的绝对值大和谁的符号相同）。最后将尾数部分取绝对值。如果为正数，说明a的绝对值更大，符号和a相同。</p><pre><code class="hljs java"><span class="hljs-keyword">if</span>(ansFriction.charAt(<span class="hljs-number">1</span>)==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;  <span class="hljs-keyword">if</span>(aExp.equals(<span class="hljs-string">&quot;11111110&quot;</span>))&#123;    ansBuilder.append(<span class="hljs-string">&quot;1111111100000000000000000000000&quot;</span>);    <span class="hljs-keyword">return</span> ansBuilder.toString();  &#125;  aExp = alu.add(aExp, <span class="hljs-string">&quot;00000001&quot;</span>);  ansFriction = ansFriction.substring(<span class="hljs-number">1</span>, <span class="hljs-number">29</span>);&#125; <span class="hljs-keyword">else</span> &#123;  ansFriction = ansFriction.substring(<span class="hljs-number">2</span>, <span class="hljs-number">30</span>);&#125;</code></pre><p>这里判断两数相加之后是否进位，如果进位就在阶码处+1，将尾数左移一位。此处应该判断结果是否会溢出，若溢出则返回无穷。因为此时我的小数部分是30位（2位补充的“00”+1位规格化的0/1+23位尾数+4位保护位），因此取相应的1到28位（左移）或2到30位（无左移）；</p><pre><code class="hljs java"><span class="hljs-keyword">while</span> (ansFriction.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;  aExp = alu.sub(<span class="hljs-string">&quot;00000001&quot;</span>, aExp);  ansFriction = ansFriction + <span class="hljs-string">&quot;0&quot;</span>;  ansFriction = ansFriction.substring(<span class="hljs-number">1</span>, <span class="hljs-number">28</span>);&#125;</code></pre><p>每当目前的尾数的第一位不为1，则需要进行规格化操作；（因为前面已经处理过全为0的情况，因此该循环可以终止）</p><pre><code class="hljs java">ansFriction = ansFriction.substring(<span class="hljs-number">0</span>, <span class="hljs-number">24</span>);ansBuilder.append(aExp);ansBuilder.append(ansFriction, <span class="hljs-number">1</span>, <span class="hljs-number">24</span>);<span class="hljs-keyword">return</span> ansBuilder.toString();</code></pre><p>完成答案。</p><h3 id="辅助函数一览"><a href="#辅助函数一览" class="headerlink" title="辅助函数一览"></a>辅助函数一览</h3><ol><li>计算一串01序列的无符号整数值；</li></ol><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">unsignedVal</span><span class="hljs-params">(String str)</span></span>&#123;  <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;  <span class="hljs-keyword">int</span> len = str.length();  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=len-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;    <span class="hljs-keyword">if</span> (str.charAt(i) == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;      ret += (<span class="hljs-number">1</span>&lt;&lt;(len-<span class="hljs-number">1</span>-i));    &#125;  &#125;  <span class="hljs-keyword">return</span> ret;&#125;</code></pre><ol><li>对带符号整数取反；</li></ol><pre><code class="hljs java"><span class="hljs-function">String <span class="hljs-title">Neg</span><span class="hljs-params">(String src)</span></span>&#123;  <span class="hljs-keyword">char</span>[] binaryStr = src.toCharArray();  <span class="hljs-keyword">int</span> index = src.length()-<span class="hljs-number">1</span>;  <span class="hljs-keyword">int</span> flg = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span>(; index&gt;=<span class="hljs-number">0</span>; index--)&#123;    <span class="hljs-keyword">if</span> (flg == <span class="hljs-number">1</span>)&#123;      binaryStr[index] = (binaryStr[index]==<span class="hljs-string">&#x27;1&#x27;</span>)? <span class="hljs-string">&#x27;0&#x27;</span>:<span class="hljs-string">&#x27;1&#x27;</span>;    &#125;    <span class="hljs-keyword">if</span>(binaryStr[index]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;      flg = <span class="hljs-number">1</span>;    &#125;  &#125;  <span class="hljs-keyword">return</span> String.valueOf(binaryStr);&#125;</code></pre><h3 id="完整的ADD函数"><a href="#完整的ADD函数" class="headerlink" title="完整的ADD函数"></a>完整的ADD函数</h3><pre><code class="hljs java"><span class="hljs-function">String <span class="hljs-title">add</span><span class="hljs-params">(String a,String b)</span></span>&#123;  <span class="hljs-comment">// TODO</span>  <span class="hljs-keyword">if</span>(a.startsWith(<span class="hljs-string">&quot;0000000000000000000000000000000&quot;</span>, <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> b;  <span class="hljs-keyword">if</span>(b.startsWith(<span class="hljs-string">&quot;0000000000000000000000000000000&quot;</span>, <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> a;  String aExp = a.substring(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>);  String bExp = b.substring(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>);  <span class="hljs-keyword">char</span> aSign = a.charAt(<span class="hljs-number">0</span>);  <span class="hljs-keyword">char</span> bSign = b.charAt(<span class="hljs-number">0</span>);  String aFriction = a.substring(<span class="hljs-number">9</span>);  String bFriction = b.substring(<span class="hljs-number">9</span>);  <span class="hljs-keyword">int</span> expA = unsignedVal(aExp);  <span class="hljs-keyword">int</span> expB = unsignedVal(bExp);  aFriction = (expA == <span class="hljs-number">0</span>)? (<span class="hljs-string">&quot;0&quot;</span>+aFriction):(<span class="hljs-string">&quot;1&quot;</span>+aFriction);  bFriction = (expB == <span class="hljs-number">0</span>)? (<span class="hljs-string">&quot;0&quot;</span>+bFriction):(<span class="hljs-string">&quot;1&quot;</span>+bFriction);  aFriction = aFriction + <span class="hljs-string">&quot;0000&quot;</span>; <span class="hljs-comment">//guardBits!</span>  bFriction = bFriction + <span class="hljs-string">&quot;0000&quot;</span>; <span class="hljs-comment">//guardBits!</span>  <span class="hljs-keyword">int</span> flg = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span> (expA &lt; expB)&#123;    flg = <span class="hljs-number">1</span>;    aExp = alu.add(<span class="hljs-string">&quot;00000001&quot;</span>, aExp);    expA++;    aFriction = <span class="hljs-string">&quot;0&quot;</span> + aFriction;  &#125;  <span class="hljs-keyword">while</span> (expB &lt; expA)&#123;    flg = <span class="hljs-number">2</span>;    bExp = alu.add(<span class="hljs-string">&quot;00000001&quot;</span>, bExp);    expB++;    bFriction = <span class="hljs-string">&quot;0&quot;</span> + bFriction;  &#125;  <span class="hljs-keyword">if</span>(flg == <span class="hljs-number">1</span>)&#123;    <span class="hljs-keyword">if</span>(aFriction.startsWith(<span class="hljs-string">&quot;00000000000000000000000&quot;</span>, <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> b;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(flg == <span class="hljs-number">2</span>)&#123;    <span class="hljs-keyword">if</span>(bFriction.startsWith(<span class="hljs-string">&quot;00000000000000000000000&quot;</span>, <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> a;  &#125;  aFriction = aFriction.substring(<span class="hljs-number">0</span>, <span class="hljs-number">28</span>);  bFriction = bFriction.substring(<span class="hljs-number">0</span>, <span class="hljs-number">28</span>);  <span class="hljs-comment">//Sign them!</span>  aFriction = <span class="hljs-string">&quot;00&quot;</span> + aFriction;  bFriction = <span class="hljs-string">&quot;00&quot;</span> + bFriction;  StringBuilder ansBuilder = <span class="hljs-keyword">new</span> StringBuilder();  String ansFriction;  <span class="hljs-keyword">if</span>(aSign == bSign)&#123;    ansFriction = alu.add(aFriction, bFriction);  &#125; <span class="hljs-keyword">else</span> &#123;    ansFriction = alu.sub(bFriction, aFriction); <span class="hljs-comment">//b+ a-</span>  &#125;  <span class="hljs-keyword">if</span>(ansFriction.equals(<span class="hljs-string">&quot;000000000000000000000000000000&quot;</span>))&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;00000000000000000000000000000000&quot;</span>;  &#125;  <span class="hljs-keyword">if</span>(aSign == bSign)&#123;    ansBuilder.append(aSign);  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">if</span>(ansFriction.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;      <span class="hljs-comment">//a + b</span>      <span class="hljs-keyword">if</span>(aSign == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;        ansBuilder.append(<span class="hljs-string">&quot;0&quot;</span>);      &#125; <span class="hljs-keyword">else</span> &#123;        ansBuilder.append(<span class="hljs-string">&quot;1&quot;</span>);      &#125;      ansFriction = Neg(ansFriction);    &#125; <span class="hljs-keyword">else</span> &#123;      ansBuilder.append(aSign);    &#125;  &#125;  <span class="hljs-comment">/*</span><span class="hljs-comment">        if(unsignedVal(ansFriction.substring(26, 30))&gt;7)&#123;</span><span class="hljs-comment">            ansFriction = alu.add(ansFriction, &quot;000000000000000000000000001000&quot;);</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment">         */</span>  <span class="hljs-keyword">if</span>(ansFriction.charAt(<span class="hljs-number">1</span>)==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;    <span class="hljs-keyword">if</span>(aExp.equals(<span class="hljs-string">&quot;11111110&quot;</span>))&#123;      ansBuilder.append(<span class="hljs-string">&quot;1111111100000000000000000000000&quot;</span>);      <span class="hljs-keyword">return</span> ansBuilder.toString();    &#125;    aExp = alu.add(aExp, <span class="hljs-string">&quot;00000001&quot;</span>);    ansFriction = ansFriction.substring(<span class="hljs-number">1</span>, <span class="hljs-number">29</span>);  &#125; <span class="hljs-keyword">else</span> &#123;    ansFriction = ansFriction.substring(<span class="hljs-number">2</span>, <span class="hljs-number">30</span>);  &#125;  <span class="hljs-comment">//normalize</span>  <span class="hljs-keyword">while</span> (ansFriction.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;    aExp = alu.sub(<span class="hljs-string">&quot;00000001&quot;</span>, aExp);    ansFriction = ansFriction + <span class="hljs-string">&quot;0&quot;</span>;    ansFriction = ansFriction.substring(<span class="hljs-number">1</span>, <span class="hljs-number">28</span>);  &#125;  ansFriction = ansFriction.substring(<span class="hljs-number">0</span>, <span class="hljs-number">24</span>);  ansBuilder.append(aExp);  ansBuilder.append(ansFriction, <span class="hljs-number">1</span>, <span class="hljs-number">24</span>);  <span class="hljs-keyword">return</span> ansBuilder.toString();&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>WeeklyReview</tag>
      
      <tag>Integer</tag>
      
      <tag>COA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>week6-Grade2-fall</title>
    <link href="/2020/11/02/week6-Grade2-fall/"/>
    <url>/2020/11/02/week6-Grade2-fall/</url>
    
    <content type="html"><![CDATA[<h2 id="算法分析与设计"><a href="#算法分析与设计" class="headerlink" title="算法分析与设计"></a>算法分析与设计</h2><h2 id="计算机组成与结构"><a href="#计算机组成与结构" class="headerlink" title="计算机组成与结构"></a>计算机组成与结构</h2><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><ul><li><p>本身盘不带有磁性，磁性物质被洒在盘面上；</p></li><li><p>一个扇区的存储容量经常是512B；</p></li><li><p>内外圈读512B的时间都是一样的。只要保证一个角度（内圈）即可。每一圈都是一样的，很容易算出来它在哪个位置。</p></li><li><p>多划分（multiple zone recording）：每多一次扇区就要调整一次磁头的转速【成本高，容易坏】；提高了磁盘的利用效率可以多放几个512B；</p></li><li><p>相同磁道合起来是一个柱面；同一个柱面的数据每次一起写；</p></li><li><p>格式化</p><ul><li>gap多余——提供反应时间。不能够太短。</li></ul></li><li><p>读写数据</p><ul><li><p>寻道时间+旋转延迟+读写时间；</p></li><li><script type="math/tex; mode=display">T_a=T_s+\frac{1}{2r}+\frac{b}{rN}</script></li><li><p>r表示转速；</p></li></ul></li><li><p>磁头扫描算法</p><ul><li>FCFS：</li><li>SSTF：移动到距离当前磁道最近的。</li><li>SCAN：从0磁道到N；</li><li>C-SCAN：从N磁道到0；</li><li>为什么不来回扫呢？最坏等待时间会变短！</li></ul></li><li><p>磁道号、磁头号。</p><ul><li>同步字节——提醒需要开始读了。</li><li>为什么要加一个gap？——足够长的等待时间方便后面操作。避免所有的扇区划分在一起。</li></ul></li><li><p>写：</p><ul><li>电流——磁场——磁性物质不同排列——电阻变化——恒定电流</li></ul></li><li>寻道时间：磁头移动到目标磁道的时间；</li><li>CD<ul><li>一条线状均匀分布</li><li>CD盘的凹凸不平是压出来的——母盘。</li><li>刻录——高强度激光（反射时承担的两种状态 pit 和 land） </li></ul></li></ul><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><ul><li>海明码<ul><li>故障字（syndrome word）</li><li>总共有M+K+1种情况；</li></ul></li><li>只有一位出错的时候表示C出错</li><li>故障字的组合情况是唯一的。</li><li>生成多项式——f</li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>WeeklyReview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WeeklyReview</tag>
      
      <tag>DFS</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NBCD-Review</title>
    <link href="/2020/10/23/NBCD-Review/"/>
    <url>/2020/10/23/NBCD-Review/</url>
    
    <content type="html"><![CDATA[<p>因为NBCD在编程作业中的头疼程度，决定对他进行一个单独的篇章进行总结（但或许这个知识点本身并不是特别重要）。</p><h2 id="NBCD"><a href="#NBCD" class="headerlink" title="NBCD"></a>NBCD</h2><p>BCD(a.k.a. Binary-Coded Decimal)。NBCD码，也称8421码。将0～9表示成四位0000～1001。编程作业中的NBCD码固定为32位，表示1个符号和7个数字。而实际表示中，NBCD可以表示无限位的十进制整数。正号表示为“1100”，负号表示为“1101”。</p><ul><li>注：0在NBCD码中只有正0，需要注意。（也许这只是编程作业的feature）</li><li>32位的NBCD码中，若该位没有数字则用“0000”补充。</li></ul><h2 id="NBCD的加法"><a href="#NBCD的加法" class="headerlink" title="NBCD的加法"></a>NBCD的加法</h2><ul><li>符号系统有一些复杂，所以我做了这样的处理：<ul><li>1⃣️对于加法，同号继续，异号调用减法；</li><li>2⃣️对于减法，同号继续，异号调用加法；</li><li>注：这样的调用会增加程序的耦合性，是一种不好的编程习惯！</li></ul></li><li>NBCD的加法是单次四位操作的，每次使用位级加法。但这样会产生一个问题：结果产生在范围1010～1111，或产生了进位。因为十六进制表示的原因，位级加减得到的结果一旦需要进位，会比正常得到的结果少6。所以我们在需要进位的时候设置进位CF为1，并且为位级计算的结果加上“0110”。</li><li>别忘了在没有进位的时候设置进位Carry为0；</li><li>因为在我的设计中，加法处理的是同号的情况，所以计算结果应当和位级计算的结果同号；所以计算结果的符号和a的符号相同即可！</li><li>调用减法的时候需要注意替换符号，比如a和-b的情况（这里a和b都是绝对值），a+(-b)转化为a-b即可，也就是将b的符号“1101”换成“1100”就可以了。</li></ul><pre><code class="hljs java"><span class="hljs-function">String <span class="hljs-title">add</span><span class="hljs-params">(String a, String b)</span> </span>&#123;  <span class="hljs-comment">// TODO</span>  <span class="hljs-comment">//invoke cutStr to get slices;</span>  String[] aStr = cutStr(a);  String[] bStr = cutStr(b);  <span class="hljs-comment">//Accorrding to the sign, select which operation to take;</span>  String aSign = aStr[<span class="hljs-number">0</span>];  String bSign = bStr[<span class="hljs-number">0</span>];  <span class="hljs-keyword">if</span>(!aSign.equals(bSign))&#123;    <span class="hljs-keyword">if</span>(aSign.equals(<span class="hljs-string">&quot;1100&quot;</span>))&#123;      b = b.replace(<span class="hljs-string">&quot;1101&quot;</span>, <span class="hljs-string">&quot;1100&quot;</span>);      <span class="hljs-keyword">return</span> sub(b, a);    &#125; <span class="hljs-keyword">else</span> &#123;      a = a.replace(<span class="hljs-string">&quot;1101&quot;</span>, <span class="hljs-string">&quot;1100&quot;</span>);      <span class="hljs-keyword">return</span> sub(a, b);    &#125;  &#125;  String tmp;  StringBuilder ret = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-comment">//Carry Flag!</span>  <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">7</span>; i&gt;<span class="hljs-number">0</span>; i--)&#123;    <span class="hljs-comment">//Invoke alu.add to calculate the result of a and b;</span>    tmp = alu.add(aStr[i], bStr[i]);    <span class="hljs-keyword">if</span>(carry == <span class="hljs-number">1</span>)&#123;      tmp = alu.add(tmp, <span class="hljs-string">&quot;0001&quot;</span>); <span class="hljs-comment">//Carry One;</span>    &#125;    <span class="hljs-keyword">if</span>((aStr[i].charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;1&#x27;</span> || bStr[i].charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;1&#x27;</span>)&amp;&amp;(tmp.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span>)       || valOfNBCD(tmp)&gt;<span class="hljs-number">9</span>)&#123;         <span class="hljs-comment">// 1001 + 1000 = 0001 ? check overflow! if 1010 ~ 1111, overflow as well.</span>      carry = <span class="hljs-number">1</span>;      tmp = alu.add(tmp, <span class="hljs-string">&quot;0110&quot;</span>);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">//Case: not overflow</span>      carry = <span class="hljs-number">0</span>;    &#125;    ret.insert(<span class="hljs-number">0</span>, tmp);  &#125;  <span class="hljs-comment">//Same as the two args;</span>  ret.insert(<span class="hljs-number">0</span>, aSign);  <span class="hljs-keyword">return</span> ret.toString();&#125;</code></pre><h2 id="NBCD的减法"><a href="#NBCD的减法" class="headerlink" title="NBCD的减法"></a>NBCD的减法</h2><p>整理（调用）的加法之所以相对简单是因为加法不会产生变号的现象。代码细节需要注意：b（第二个参数）为被减数，而第一个参数为减数。</p><ul><li><p>同理于加法，对于b和a异号的情况，调用加法进行计算。当b为负数a为正数的时候，转换为b和-a作加法。当b为正数a为负数的时候，转化为b和-a（正数）作加法。</p></li><li><p>减法的实质仍然是加法：</p></li><li><script type="math/tex; mode=display">A - B=A+(10^n-B)</script></li><li><p>因此在十进制中，我们<strong>对每一位数字取补（从右往左起的第一个非0位去减10（需要借位），后续的去减9。）</strong>。得到的结果与b（被减数）相加。这里加法的过程和加法是完全一样的；若对7位均进行操作，就不需要再“减掉”这个操作了，因为加上的10<sup>n</sup>会直接溢出。</p></li><li><p>因为这里加上了10<sup>n</sup>（n&lt;7），所以后面需要把他减掉。为了不影响原本为0的位，我们先把“0000”全部补上。</p><ul><li>关于这里需要判断一下carry的问题：这里其实判断的是溢出情况。比如说 333 - 300 = 33（假设这里只有3位），根据上面的操作，等效变成了 333 + 700 = 1033，这里就有一位的进位（进位到了千位）。而我们这里只有三位，这一位进位就会被自动舍弃，也就是说会自动减去一个1000，得到我们想要的结果：33。所以，在<strong>整体计算</strong>（即7位全部参与运算）之后，还有一位进位的情况下，不需要这个-10<sup>n</sup>的操作。</li><li>对于不需要进位的情况，我们根据刚才取补的方式：最低非0位去减10（10 - 最低非零位），从右起后续的每位去减9，就可以得到减去10之后的结果了。</li></ul></li><li><p>最后的一个重难点——<strong>判断符号</strong>。</p><ul><li><p>NBCD中没有负0，所以0我们要特判一下。</p></li><li><p>负数-负数的情况和正数-正数的情况相反，这里需要注意一下。比如(-3-(-4))不需要借位，但是它得到的是正数的结果；(1-2)同样是不需要借位的，但他得到的是负数的结果。</p></li><li><p>如果有进位（借位）：在正数相减中，有进位说明：被减数大于减数。我们回头去看一遍数学推导：</p><script type="math/tex; mode=display">A - B=A+(10^n-B)</script><p>如果有进位的话，说明：</p><script type="math/tex; mode=display">A - B=A+(10^n-B)>10^n</script><p>那么：</p><script type="math/tex; mode=display">A>B</script><p>说明了被减数大于减数，差应该和被减数同号！</p><p>如果没进位的话，结果就和上面正好相反：</p><script type="math/tex; mode=display">A<B</script><p>差应该和被减数异号！</p></li></ul></li></ul><p>以下就是一堆糟心的代码，可读性并不高，但可以根据上面的说明阅读一下。理论上还需要证明一下代码的正确性，但是太困了就算了吧QAQ</p><pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> a A 32-bits NBCD String</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> b A 32-bits NBCD String</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> b - a</span><span class="hljs-comment"> */</span><span class="hljs-function">String <span class="hljs-title">sub</span><span class="hljs-params">(String a, String b)</span> </span>&#123;  <span class="hljs-comment">// TODO</span>  String[] aStr = cutStr(a);  String[] bStr = cutStr(b);  String aSign = aStr[<span class="hljs-number">0</span>];  String bSign = bStr[<span class="hljs-number">0</span>];  <span class="hljs-comment">//adjust sign bit;</span>  <span class="hljs-keyword">if</span>(!aSign.equals(bSign))&#123;    <span class="hljs-keyword">if</span>(aSign.equals(<span class="hljs-string">&quot;1100&quot;</span>))&#123;      a = a.replace(<span class="hljs-string">&quot;1100&quot;</span>, <span class="hljs-string">&quot;1101&quot;</span>);      <span class="hljs-keyword">return</span> add(a, b);    &#125; <span class="hljs-keyword">else</span> &#123;      a = a.replace(<span class="hljs-string">&quot;1101&quot;</span>, <span class="hljs-string">&quot;1100&quot;</span>);      <span class="hljs-keyword">return</span> add(a, b);    &#125;  &#125;  String tmpStr;  String[] ans = <span class="hljs-keyword">new</span> String[<span class="hljs-number">8</span>];  StringBuilder nTmp = <span class="hljs-keyword">new</span> StringBuilder();  <span class="hljs-keyword">int</span> i=<span class="hljs-number">7</span>;  <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;  <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span>(; i&gt;<span class="hljs-number">0</span>; i--)&#123;    <span class="hljs-keyword">if</span>(aStr[i].equals(<span class="hljs-string">&quot;0000&quot;</span>) &amp;&amp; bStr[i].equals(<span class="hljs-string">&quot;0000&quot;</span>)) <span class="hljs-keyword">break</span>;    tmpStr = alu.sub(aStr[i],<span class="hljs-string">&quot;1001&quot;</span>);    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">7</span>) tmpStr = alu.add(tmpStr, <span class="hljs-string">&quot;0001&quot;</span>);   <span class="hljs-comment">//借位</span>    String tmp = tmpStr;    tmpStr = alu.add(tmpStr, bStr[i]);    <span class="hljs-keyword">if</span>(carry == <span class="hljs-number">1</span>)&#123;      tmpStr = alu.add(tmpStr, <span class="hljs-string">&quot;0001&quot;</span>);    &#125;    <span class="hljs-keyword">if</span>((tmp.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;1&#x27;</span> || bStr[i].charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;1&#x27;</span>)&amp;&amp;(tmpStr.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span>) ||       valOfNBCD(tmpStr) &gt; <span class="hljs-number">9</span>)&#123;      <span class="hljs-comment">//carry和overflow还没判断呢！</span>      carry = <span class="hljs-number">1</span>;      tmpStr = alu.add(tmpStr, <span class="hljs-string">&quot;0110&quot;</span>);    &#125; <span class="hljs-keyword">else</span> &#123;      carry = <span class="hljs-number">0</span>;    &#125;    count++;    ans[i] = tmpStr;  &#125;  <span class="hljs-keyword">while</span> (i&gt;<span class="hljs-number">0</span>)&#123;    ans[i] = <span class="hljs-string">&quot;0000&quot;</span>;    i--;  &#125;  <span class="hljs-keyword">int</span> flg = <span class="hljs-number">0</span>;  <span class="hljs-keyword">if</span>(carry == <span class="hljs-number">0</span>)&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">7</span>; j&gt;<span class="hljs-number">7</span>-count; j--)&#123;      <span class="hljs-keyword">if</span>(ans[j].equals(<span class="hljs-string">&quot;0000&quot;</span>)) <span class="hljs-keyword">continue</span>;      <span class="hljs-keyword">if</span>(flg == <span class="hljs-number">0</span>)&#123;        ans[j] = alu.sub(ans[j], <span class="hljs-string">&quot;1010&quot;</span>);        flg = <span class="hljs-number">1</span>;      &#125; <span class="hljs-keyword">else</span> &#123;        ans[j] = alu.sub(ans[j], <span class="hljs-string">&quot;1001&quot;</span>);      &#125;    &#125;  &#125;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">7</span>; j&gt;<span class="hljs-number">0</span>; j--)&#123;    nTmp.insert(<span class="hljs-number">0</span>, ans[j]);  &#125;  String ret = nTmp.toString();  <span class="hljs-keyword">if</span> (ret.equals(<span class="hljs-string">&quot;0000000000000000000000000000&quot;</span>)) &#123; <span class="hljs-comment">//之前判断&quot;0&quot;有问题；</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1100&quot;</span> + ret;  &#125;  <span class="hljs-keyword">if</span>(aSign.equals(<span class="hljs-string">&quot;1100&quot;</span>))&#123;    <span class="hljs-keyword">return</span> ((carry==<span class="hljs-number">1</span>)? <span class="hljs-string">&quot;1100&quot;</span>:<span class="hljs-string">&quot;1101&quot;</span>) + ret;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">return</span> ((carry==<span class="hljs-number">1</span>)? <span class="hljs-string">&quot;1101&quot;</span>:<span class="hljs-string">&quot;1100&quot;</span>) + ret;  &#125;&#125;</code></pre><h2 id="辅助函数一览"><a href="#辅助函数一览" class="headerlink" title="辅助函数一览"></a>辅助函数一览</h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">valOfNBCD</span><span class="hljs-params">(String a)</span></span>&#123;  <span class="hljs-keyword">char</span>[] aLst = a.toCharArray();  <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span>; i++)&#123;    ret &lt;&lt;= <span class="hljs-number">1</span>;    ret += (aLst[i]==<span class="hljs-string">&#x27;1&#x27;</span>)? <span class="hljs-number">1</span>:<span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">return</span> ret;&#125;</code></pre><p>计算四位BCD的值，即对应的0～9。</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> String[] cutStr(String str)&#123;  String[] strArr = <span class="hljs-keyword">new</span> String[<span class="hljs-number">8</span>];  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">8</span>; i++)&#123;    strArr[i] = str.substring(<span class="hljs-number">4</span>*i, <span class="hljs-number">4</span>*(i + <span class="hljs-number">1</span>));  &#125;  <span class="hljs-keyword">return</span> strArr;&#125;</code></pre><p>将字符串以四个一组切分；</p><p>过程中还有调用ALU中的位级加减法，理解成整数相加减即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>WeeklyReview</tag>
      
      <tag>NBCD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>专业词汇</title>
    <link href="/2020/10/21/%E4%B8%93%E4%B8%9A%E8%AF%8D%E6%B1%87/"/>
    <url>/2020/10/21/%E4%B8%93%E4%B8%9A%E8%AF%8D%E6%B1%87/</url>
    
    <content type="html"><![CDATA[<h3 id="生物"><a href="#生物" class="headerlink" title="生物"></a>生物</h3><ul><li>invertebrate 无脊椎的； vertebrate 有脊椎的；</li><li>primates 灵长类；</li><li>mollusk 软体动物；</li><li>coelenterate 腔肠动物；</li><li>spineless 无脊椎的；没骨气的；Sipne 脊椎；</li><li>reproduce 繁殖；</li><li>recessive gene 隐性基因；</li></ul><h3 id="地质"><a href="#地质" class="headerlink" title="地质"></a>地质</h3><ul><li>sedimentation 沉淀（过程）；sediment 沉淀物；<ul><li>同义替换：deposit 沉淀；accumulation；</li></ul></li><li>grains 颗粒；纹理；</li><li>molten 熔化的；铸造的；</li><li>magma 岩浆；</li><li>lava 火山岩浆；</li><li>grantie 花岗岩；</li><li>lead 铅；</li><li>dating 确定年代；</li></ul><h4 id="商科"><a href="#商科" class="headerlink" title="商科"></a>商科</h4><ul><li>commodity/products/goods/merchandise 商品；<ul><li>commoditize 商品化；</li></ul></li><li>merchant 商业的；</li></ul>]]></content>
    
    
    <categories>
      
      <category>TOEFL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TOEFL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TOEFL-writing-notes</title>
    <link href="/2020/10/20/TOEFL-writing-notes/"/>
    <url>/2020/10/20/TOEFL-writing-notes/</url>
    
    <content type="html"><![CDATA[<h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><div class="table-container"><table><thead><tr><th style="text-align:center">注意事项</th><th style="text-align:center">综合写作</th><th style="text-align:center">独立写作</th></tr></thead><tbody><tr><td style="text-align:center">形式</td><td style="text-align:center">读+听+写</td><td style="text-align:center">写</td></tr><tr><td style="text-align:center">时间</td><td style="text-align:center">20min</td><td style="text-align:center">30min</td></tr><tr><td style="text-align:center">字数</td><td style="text-align:center">150~225</td><td style="text-align:center">&gt;300</td></tr><tr><td style="text-align:center">题材</td><td style="text-align:center">Academic</td><td style="text-align:center">Non-Academic</td></tr><tr><td style="text-align:center">观点</td><td style="text-align:center">Objective</td><td style="text-align:center">Subjective</td></tr></tbody></table></div><h3 id="1-综合写作考试流程"><a href="#1-综合写作考试流程" class="headerlink" title="1. 综合写作考试流程"></a>1. 综合写作考试流程</h3><p>Wrting Based on reading and listening.</p><p>Step1: You will have <strong>3</strong> minute to read a passage.</p><ul><li>Structure: 总分结构，四段式<ul><li>一个总论点+三个分论点+理由细节</li></ul></li></ul><p>Step2: listening (阅读消失)</p><ul><li><p>You will hear a lecture for 2 minutes.</p></li><li><p>Tips: 听力与阅读的关系</p><ol><li>话题相同，观点相反</li><li>一一对应的反驳</li></ol></li></ul><p>Step3: Writing （阅读重现）</p><ul><li>Finish your essay in 20 minutes.</li><li>字数要求：150～225</li></ul><p>怎么写？</p><ul><li>第一段：阅读说了什么，听力不同意；</li><li>第二段：听力不同意阅读的第一个理由 + 听力细节；</li><li>第三段：听力不同意阅读的第二个理由 + 听力细节；</li><li>第四段：听力不同意阅读的第三个理由 + 听力细节；</li></ul><h3 id="2-独立写作"><a href="#2-独立写作" class="headerlink" title="2. 独立写作"></a>2. 独立写作</h3><p>Writing Based on Knowledge and experience.</p><p>Finish your essay in 30 minutes.</p><p>字数要求：300+</p><h3 id="3-段间结构的三种展开方式"><a href="#3-段间结构的三种展开方式" class="headerlink" title="3. 段间结构的三种展开方式"></a>3. 段间结构的三种展开方式</h3><h4 id="1-一边倒——有倾向性的观点。"><a href="#1-一边倒——有倾向性的观点。" class="headerlink" title="1. 一边倒——有倾向性的观点。"></a>1. <strong>一边倒</strong>——有倾向性的观点。</h4><div class="table-container"><table><thead><tr><th style="text-align:center">Introduction</th></tr></thead><tbody><tr><td style="text-align:center">A+/A&gt;B</td></tr><tr><td style="text-align:center">A+/A&gt;B</td></tr><tr><td style="text-align:center">A+/A&gt;B</td></tr><tr><td style="text-align:center">Conclusion</td></tr></tbody></table></div><h4 id="2-让步——仍然有自己明确段倾向性观点"><a href="#2-让步——仍然有自己明确段倾向性观点" class="headerlink" title="2. 让步——仍然有自己明确段倾向性观点"></a>2. 让步——仍然有自己明确段倾向性观点</h4><div class="table-container"><table><thead><tr><th style="text-align:center">Introduction</th></tr></thead><tbody><tr><td style="text-align:center">A+</td></tr><tr><td style="text-align:center">A+</td></tr><tr><td style="text-align:center">-(A-/B+)</td></tr><tr><td style="text-align:center">Conclusion</td></tr></tbody></table></div><ul><li>什么是让步段：不需要再去想出一个新的分论点去支持我方观点，而是也考虑到对立面的观点，承认我方观点也有一定缺陷，但是一定要<strong>转折回来（虚假妥协）。</strong><ul><li>使用条件：<ul><li>想不出足够理由的时候；</li><li>二选一题目中两者事物没有直接关联，无法直接比较时；</li><li>在绝对词题目中：承合段的本质是让步段；</li></ul></li></ul></li></ul><h4 id="3-Case-by-case"><a href="#3-Case-by-case" class="headerlink" title="3. Case-by-case"></a>3. Case-by-case</h4><p>无倾向性的观点。分别论述两方观点使用情况。</p><div class="table-container"><table><thead><tr><th style="text-align:center">Introduction</th></tr></thead><tbody><tr><td style="text-align:center">A+</td></tr><tr><td style="text-align:center">A-/B+</td></tr><tr><td style="text-align:center">Conclusion</td></tr></tbody></table></div><p>使用条件： 当我们发现话题的对立两面明显在世界中都存在且都明显不可或缺时，我们会考虑用这种写法。</p><p><strong><em>Tips：</em></strong>段落与段落之间应该满足什么要求？</p><ul><li>互斥：互不包含，互不因果</li><li>一个要点永远要自成一段，每个段落都必须充分展开，不能和其他段落有重合的部分。         </li></ul><p>辩证切入点：</p><ul><li>有时候，为了避免三个理由相同或相似，可以找不同段收益方或受损方。</li></ul><h3 id="4-托福独立写作评分标准"><a href="#4-托福独立写作评分标准" class="headerlink" title="4. 托福独立写作评分标准"></a>4. 托福独立写作评分标准</h3><ol><li>Effectively <strong>addresses</strong> the topic and task. 切题</li><li>Is well organized and well developed, using clearly appropriate explanations, exemplifications, and/or details. 组织良好，展开充分（事实性语言；具体有画面感）</li><li>Displays unity, progression, and coherence（统一性、递进性、连贯性）</li><li>Displays consistent facility in the use of language, demonstrating syntactic variety, appropriate word choice, and idiomaticity, though it may have minor lexical or grammatical errors.</li></ol>]]></content>
    
    
    <categories>
      
      <category>TOEFL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TOEFL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>week5-Grade2-fall</title>
    <link href="/2020/10/19/week5-Grade2-fall/"/>
    <url>/2020/10/19/week5-Grade2-fall/</url>
    
    <content type="html"><![CDATA[<h2 id="算法分析与设计"><a href="#算法分析与设计" class="headerlink" title="算法分析与设计"></a>算法分析与设计</h2><h3 id="1-并查集"><a href="#1-并查集" class="headerlink" title="1. 并查集"></a>1. 并查集</h3><h4 id="1-0-等价关系"><a href="#1-0-等价关系" class="headerlink" title="1.0 等价关系"></a>1.0 等价关系</h4><ul><li><p>自反性</p><script type="math/tex; mode=display">a \equiv a</script></li><li><p>对称性</p><script type="math/tex; mode=display">a \equiv b \Rightarrow b \equiv a</script></li><li><p>传递性</p><script type="math/tex; mode=display">a \equiv b, b \equiv c \Rightarrow a \equiv c</script></li><li><p>等价关系形成了一个划分——互不相交。</p></li></ul><h4 id="1-1-动态等价关系"><a href="#1-1-动态等价关系" class="headerlink" title="1.1 动态等价关系"></a>1.1 动态等价关系</h4><ul><li>判断是否等价；</li><li>合并两个等价关系；</li></ul><h3 id="1-2-Union-Find-的数据结构"><a href="#1-2-Union-Find-的数据结构" class="headerlink" title="1.2 Union-Find 的数据结构"></a>1.2 Union-Find 的数据结构</h3><ul><li>使用一棵树表示一个子集，子集中的元素互相等价。</li><li>真个集合划分称为互不相交的子集。</li><li>实现上：<ul><li>使用数组记住每个元素（结点）的父亲结点（的编号）。</li><li>树的根结点的父亲结点为-1。</li></ul></li></ul><h3 id="1-3-路经压缩"><a href="#1-3-路经压缩" class="headerlink" title="1.3 路经压缩"></a>1.3 路经压缩</h3><ul><li>树的形状越矮越好；</li><li>在一次find到过程中，将路径上所有的结点直接与根结点相连；</li><li>cFind花了两倍于find的时间（操作）；</li></ul><h3 id="wUnion-和-cFind-共同使用的开销"><a href="#wUnion-和-cFind-共同使用的开销" class="headerlink" title="wUnion 和 cFind 共同使用的开销"></a>wUnion 和 cFind 共同使用的开销</h3><ul><li><p><em>O</em>((<em>n</em>+<em>m</em>)<em>log<sup>\</em>&lt;/sup&gt;(n)*)</p><ul><li><p>worst case;</p></li><li><script type="math/tex; mode=display">H(0)=1</script><script type="math/tex; mode=display">H(i)=2^{H(i-1)}</script><p><em>log<sup>\</em>&lt;/sup&gt;(n)<em> = min{ </em>k<em> | H(</em>k<em>) &gt;= </em>j* }</p></li></ul></li></ul><p>有几条分界线，有几次开销。</p><h2 id="计算机组织与结构"><a href="#计算机组织与结构" class="headerlink" title="计算机组织与结构"></a>计算机组织与结构</h2><h3 id="1-内存"><a href="#1-内存" class="headerlink" title="1. 内存"></a>1. 内存</h3><ul><li>能存；</li><li>能初始化；</li><li>能够读出；</li></ul><h4 id="1-1-RAM"><a href="#1-1-RAM" class="headerlink" title="1.1 RAM"></a>1.1 RAM</h4><ul><li>读写都是简单且快速的；</li><li>但是有易失性（断电后不保存）；</li></ul><h5 id="1-1-1-DRAM"><a href="#1-1-1-DRAM" class="headerlink" title="1.1.1 DRAM"></a>1.1.1 DRAM</h5><ul><li>动态指的是：电容会有漏电的现象，需要刷新存储器中的内容，因此读写不能同时进行；</li><li>有点：成本低，集成度高；</li><li>缺点：不稳定，速度慢；</li><li>用作主存储器；</li></ul><h5 id="1-1-2-SRAM"><a href="#1-1-2-SRAM" class="headerlink" title="1.1.2 SRAM"></a>1.1.2 SRAM</h5><ul><li>缺点：集成度低，占空间；</li><li>用作Cache；</li></ul><h4 id="1-2-ROM"><a href="#1-2-ROM" class="headerlink" title="1.2 ROM"></a>1.2 ROM</h4><ul><li>只读存储器；</li><li>不需要能量来维持存储的信息；非易失；</li><li>只能写一次；通过出场设置来进行写；</li><li>安全性更好；</li></ul><h4 id="1-3-PROM"><a href="#1-3-PROM" class="headerlink" title="1.3 PROM"></a>1.3 PROM</h4><ul><li>大批量生产时，效率没有ROM高；</li><li>可编程ROM；</li><li>更加灵活和方便——个人使用；</li></ul><h4 id="1-4-Read-Mostly-Memory"><a href="#1-4-Read-Mostly-Memory" class="headerlink" title="1.4 Read-Mostly Memory"></a>1.4 Read-Mostly Memory</h4><ul><li>读操作远频繁于写操作；</li><li>非易失性存储；</li></ul><h5 id="1-4-1-EPROM"><a href="#1-4-1-EPROM" class="headerlink" title="1.4.1 EPROM"></a>1.4.1 EPROM</h5><ul><li>可擦除可编程只读存储器；</li><li>相比于PROM更贵，但是可以多次使用；</li><li>一次性擦除一整个芯片，擦除时间20分钟；</li></ul><h5 id="1-4-2-EEPROM"><a href="#1-4-2-EEPROM" class="headerlink" title="1.4.2 EEPROM"></a>1.4.2 EEPROM</h5><ul><li>电可擦除可编程只读存储器；</li><li>每次重写一个字节；</li><li>比EPROM更贵，但也有更低的集成度；</li><li>每次写操作需要几百微秒，写操作很慢；</li></ul><h4 id="1-5-Flash-Memory"><a href="#1-5-Flash-Memory" class="headerlink" title="1.5 Flash Memory"></a>1.5 Flash Memory</h4><ul><li>闪存，用于U盘。</li><li>功能性和稳定性介于EPROM和EEPROM之间；</li><li>和EPROM一样的高集成度；</li><li>可以在块级擦除，但字节不行；</li></ul><h4 id="1-6-Refreshing"><a href="#1-6-Refreshing" class="headerlink" title="1.6 Refreshing"></a>1.6 Refreshing</h4><h5 id="集中式刷新"><a href="#集中式刷新" class="headerlink" title="集中式刷新"></a>集中式刷新</h5><ul><li>刷新的过程中不能对存储器进行操作；</li><li>停止读写操作，集中刷新</li></ul><h5 id="非集中式刷新"><a href="#非集中式刷新" class="headerlink" title="非集中式刷新"></a>非集中式刷新</h5><ul><li>每次存储周期都刷新——读写周期会延长；</li></ul><h5 id="异步刷新"><a href="#异步刷新" class="headerlink" title="异步刷新"></a>异步刷新</h5><ul><li>避开现在正在使用的一行，若有一行一直都没有刷新，快到64ms都要强制刷新；</li></ul><h4 id="1-7"><a href="#1-7" class="headerlink" title="1.7"></a>1.7</h4><h5 id="1-7-1-位扩展"><a href="#1-7-1-位扩展" class="headerlink" title="1.7.1 位扩展"></a>1.7.1 位扩展</h5><ul><li>地址线没有变换；</li><li>扩展寻址单元个数——数据线增加；</li><li>用八块4K<em>1bit的芯片构成4K\</em>8的内存</li></ul><h5 id="1-7-2-增加寻址单元个数（字扩展）"><a href="#1-7-2-增加寻址单元个数（字扩展）" class="headerlink" title="1.7.2 增加寻址单元个数（字扩展）"></a>1.7.2 增加寻址单元个数（字扩展）</h5><ul><li><p>地址线增加；（2倍多一根）</p></li><li><script type="math/tex; mode=display">\lceil log_2(n) \rceil</script></li><li><p>数据线不变；</p></li><li><p>用四块16K<em>8bit的芯片来构成 64K\</em>8bit的芯片</p></li></ul><h5 id="1-73-同时扩展"><a href="#1-73-同时扩展" class="headerlink" title="1.73 同时扩展"></a>1.73 同时扩展</h5><ul><li>地址线增加；</li><li>数据线增加；</li><li>用8块16K<em>4bit的芯片来构成 64K\</em>8bit的芯片</li></ul><h3 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h3><ul><li>行列选择：选择线减少；</li><li>地址译码器；</li></ul><h3 id="2-Cache"><a href="#2-Cache" class="headerlink" title="2. Cache"></a>2. Cache</h3><h4 id="2-1-How-Cache-Works"><a href="#2-1-How-Cache-Works" class="headerlink" title="2.1 How Cache Works?"></a>2.1 How Cache Works?</h4><ul><li>Check</li><li>Hit</li><li>Miss</li></ul><h4 id="2-2-局部性原理"><a href="#2-2-局部性原理" class="headerlink" title="2.2 局部性原理"></a>2.2 局部性原理</h4><ul><li>空间局部性；</li><li>时间局部性；</li></ul><h4 id="2-3-Average-Access-Time"><a href="#2-3-Average-Access-Time" class="headerlink" title="2.3 Average Access Time"></a>2.3 Average Access Time</h4><ul><li><script type="math/tex; mode=display">T_A = p ×T_C+(1-p)×(T_C + T_M)</script></li><li><script type="math/tex; mode=display">T_A = T_C + (1-p)×T_M</script></li><li><script type="math/tex; mode=display">T_A < T_M， p>\frac{T_C}{T_M}</script></li></ul><h4 id="2-4-Elements-of-Cache-Design"><a href="#2-4-Elements-of-Cache-Design" class="headerlink" title="2.4 Elements of Cache Design"></a>2.4 Elements of Cache Design</h4><ul><li><p>Cache Size 越大越好？</p><ul><li>不是，变好的幅度会越来越小。“局部性”，并不会牵扯到太大的范围，并且块越大块内寻找的成本就会越高。块太大了之后，带来的数据是局部性比较差的、比较老的数据。</li></ul></li><li><p>Mapping Function</p><ul><li>Cache line</li><li>直接映射 Direct Mapping<ul><li>地址 = Tag + 行号 + 块内地址；<ul><li>先根据行号找到Cache对应的行，然后比对tag，若不相同则miss，否则根据块内地址选择对应的字节。若miss，根据tag+行号找到主存储器中的内容（低几位）相同，将内容放入cache并且重写tag，将放入内容（根据块内地址查找）送入cpu。</li></ul></li><li>每个块只能存入一个地方。查找很快。映射的时候也很快，每个块只有一个地方可以去。换的也快。</li><li>缺点：很容易引起“抖动（Thrashing）”。Cache小的时候容易引起抖动。换一个（很容易出现这个情况）就会换一整个块。</li></ul></li><li>关联映射 Associative Mapping<ul><li>地址 = Tag + 块内地址；</li><li>根据tag寻找（遍历）</li><li>避免了抖动，但是实现相对复杂，寻找的成本比较高。</li></ul></li><li>直接映射适合大容量cache，关联映射适合小的；<ul><li>大容量cache不容易出现抖动。</li><li>直接映射查找快，大cache影响小；关联映射遍历查找，小cache效率更高。</li></ul></li><li>组关联 Set Associative Mapping<ul><li>行的大小和块的大小一样大。</li><li>优点：在固定的组里进行操作；</li></ul></li><li>相关性：<ul><li>直接关联：1；</li><li>关联映射：C；</li><li>组关联：K；</li><li>相关性越低，命中率越低，cache越短。</li></ul></li></ul></li></ul><h4 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h4><ul><li>LRU 最近最少用算法；</li><li>FIFO 先进先出；</li><li>LFU 使用频率最少；</li><li>Random 随机。</li></ul><h4 id="写策略"><a href="#写策略" class="headerlink" title="写策略"></a>写策略</h4><ul><li><p>Write Through</p><ul><li>替换的时候同时写主存和Cache；</li><li>一改就要访问主存；</li><li>提高了cache和主存的一致性；</li></ul></li><li><p>Write Back</p><ul><li>只修改Cache。当块被替换的时候；</li><li>需要一个脏位来表示这一个块是否被调整过；如果是1就写回去，如果是0就替换掉；</li><li>优点：减少对主存的操作到最小的程度；</li></ul></li></ul><h4 id="行的大小"><a href="#行的大小" class="headerlink" title="行的大小"></a>行的大小</h4><p>行的大小会影响Cache的命中率；块太小，一次性拿进来的东西太少，块太大，拿进来没用的东西太多，减少行数会造成更换过于频繁。</p><h4 id="多级Cache"><a href="#多级Cache" class="headerlink" title="多级Cache"></a>多级Cache</h4>]]></content>
    
    
    <categories>
      
      <category>WeeklyReview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WeeklyReview</tag>
      
      <tag>并查集</tag>
      
      <tag>内存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>brief-introduction-of-VM</title>
    <link href="/2020/10/16/brief-introduction-of-VM/"/>
    <url>/2020/10/16/brief-introduction-of-VM/</url>
    
    <content type="html"><![CDATA[<h1 id="Brief-Introduction-of-VM"><a href="#Brief-Introduction-of-VM" class="headerlink" title="Brief Introduction of VM"></a>Brief Introduction of VM</h1><h2 id="1-虚拟机简介"><a href="#1-虚拟机简介" class="headerlink" title="1. 虚拟机简介"></a>1. 虚拟机简介</h2><p>虚拟机是一个计算系统。计算系统的最终目标是执行预先编程的逻辑。</p><h3 id="1-1-虚拟机类型"><a href="#1-1-虚拟机类型" class="headerlink" title="1.1 虚拟机类型"></a>1.1 虚拟机类型</h3><ul><li>1⃣️ <strong>完整指令集架构（ISA）虚拟机</strong>，提供<strong>完整的计算机系统ISA模拟或虚拟化</strong>。（例如VitualBox、QEMU等等）</li><li>2⃣️ <strong>应用程序二进制接口（ABI）虚拟机</strong>，<strong>提供客户进程ABI模拟</strong>。</li><li>3⃣️ <strong>虚拟ISA虚拟机</strong>，提供一个运行时引擎，以便虚拟ISA编码的应用程序在其上执行。虚拟ISA通常定义了一套高层的、规模有限的ISA语义，所以不需要虚拟机模拟完整的计算机系统。（例如JVM等等）</li><li>4⃣️ <strong>语言虚拟机</strong>，提供一个运行时引擎来执行以客户语言编写的程序。程序通常以源码形式提供给虚拟机，并没有预先完成编译为机器码。运行时引擎需要解释或翻译程序等。（例如Lisp、Ruby的运行时引擎）</li></ul><p>前两种虚拟机有时被称为“模拟器”。另外两种虚拟机是语言运行时引擎。</p><h3 id="1-2-为什么需要虚拟机"><a href="#1-2-为什么需要虚拟机" class="headerlink" title="1.2 为什么需要虚拟机"></a>1.2 为什么需要虚拟机</h3><ul><li><p>虚拟机改善了（计算机）安全性、（程序）效率和（应用程序）可移植性。</p></li><li><p>对于安全语言（提供了内存安全、运算安全和控制安全特性），虚拟机上必要的。通过安全语言，能尽早安全地捕获程序bug或运行错误。</p><ul><li>内存安全：确保内存中某类型的数据总是遵循对这种类型的限制。</li><li>运算安全：确保对某种类型数据的运算总是遵循对这种类型的限制。</li><li>控制安全：确保代码执行流既不会卡住也不会跑飞。</li></ul><p>安全语言本身并不能满足所有的安全需求。（例如，程序需要虚拟机为它分配一块带有类型的内存，例如某种类型的对象）如果没有虚拟机，安全语言必须引入非安全的操作支持。</p></li><li><p>虚拟机为安全语言的代码和数据提供“托管”。</p></li><li><p>因为安全语言能在编译时或运行时尽早安全地捕获程序中的BUG。因此，提高了开发者的生产率。</p></li></ul><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ul><li>应用程序提供给JVM之后，<strong>JVM的类加载器加载并解析初始类文件，然后把项目放在内存中相应的数据结构中。接下来，JVM把所有的符号饮用解析到直接引用的内存地址。类初始化之后（即调用初始化器之后），JVM调用初始类的main()方法来执行这个应用程序。</strong></li></ul><h2 id="JVM调试——OpenJDK的安装以及Clion配合使用"><a href="#JVM调试——OpenJDK的安装以及Clion配合使用" class="headerlink" title="JVM调试——OpenJDK的安装以及Clion配合使用"></a>JVM调试——OpenJDK的安装以及Clion配合使用</h2><p>主要参考的blog有：</p><ul><li><a href="https://jishuin.proginn.com/p/763bfbd28c57">在MacOS系统上编译OpenJDK12并使用CLion调试</a></li><li><a href="https://blog.csdn.net/zy353003874/article/details/107555072">费尽九牛二虎之力，终于我成功编译并调试了JVM</a></li><li><a href="https://www.jianshu.com/p/ee7e9176632c">mac下编译openjdk1.9及集成clion动态调试</a></li><li><a href="https://blog.jetbrains.com/clion/2020/03/openjdk-with-clion/">Clion官方手册：Develop OpenJDK in CLion with Pleasure</a></li></ul><p>下面要进入真正的学习了( ´▽` )ﾉ</p>]]></content>
    
    
    <categories>
      
      <category>VM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>week4_Grade2_fall</title>
    <link href="/2020/10/16/week4-Grade2-fall/"/>
    <url>/2020/10/16/week4-Grade2-fall/</url>
    
    <content type="html"><![CDATA[<h2 id="计算机组织与结构"><a href="#计算机组织与结构" class="headerlink" title="计算机组织与结构"></a>计算机组织与结构</h2><h3 id="1-编程作业分析【尽可能不使用API】"><a href="#1-编程作业分析【尽可能不使用API】" class="headerlink" title="1. 编程作业分析【尽可能不使用API】"></a>1. 编程作业分析【尽可能不使用API】</h3><h4 id="1-1-整数int转化为二进制形式"><a href="#1-1-整数int转化为二进制形式" class="headerlink" title="1.1 整数int转化为二进制形式"></a>1.1 整数int转化为二进制形式</h4><ul><li>整数有32位，其中第一位（最左位）位符号位。</li><li>负数的符号位为“1”，与相对应的正数之间的关系为“取反加一”。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">intToBinary</span><span class="hljs-params">(String numStr)</span> </span>&#123;  <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span></span>  <span class="hljs-keyword">int</span> num = Integer.parseInt(numStr);  <span class="hljs-keyword">int</span> sign = <span class="hljs-number">0</span>;  <span class="hljs-keyword">if</span>(num &lt; <span class="hljs-number">0</span>)&#123;    sign = <span class="hljs-number">1</span>;    num = -num;  &#125;  <span class="hljs-keyword">char</span>[] binaryStr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">32</span>];  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">31</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;    <span class="hljs-keyword">if</span>(num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;      binaryStr[i] = <span class="hljs-string">&#x27;0&#x27;</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      binaryStr[i] = <span class="hljs-string">&#x27;1&#x27;</span>;    &#125;    num /= <span class="hljs-number">2</span>;  &#125;  <span class="hljs-comment">//deal with negative numbers</span>  <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">1</span>)&#123;    <span class="hljs-keyword">int</span> index = <span class="hljs-number">31</span>;    <span class="hljs-keyword">int</span> flg = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(; index&gt;=<span class="hljs-number">0</span>; index--)&#123;      <span class="hljs-keyword">if</span> (flg == <span class="hljs-number">1</span>)&#123;        binaryStr[index] = (binaryStr[index]==<span class="hljs-string">&#x27;1&#x27;</span>)? <span class="hljs-string">&#x27;0&#x27;</span>:<span class="hljs-string">&#x27;1&#x27;</span>;      &#125;      <span class="hljs-keyword">if</span>(binaryStr[index]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;        flg = <span class="hljs-number">1</span>;      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> String.valueOf(binaryStr);&#125;</code></pre><p>​       以上的操作比较简单，主要是把整数字符串转换为整数，再进行“除二取余”的操作。特别的，对于负数再进行一次“取反加一”的操作。这里没有直接用取反操作符，而是使用了<strong>“从末尾的0起到第一个1不变，下一位到起始处取反”</strong>的操作。</p><h4 id="1-2-二进制形式转化为整数int"><a href="#1-2-二进制形式转化为整数int" class="headerlink" title="1.2 二进制形式转化为整数int"></a>1.2 二进制形式转化为整数int</h4><ul><li>与上面的操作相对应。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">binaryToInt</span><span class="hljs-params">(String binStr)</span> </span>&#123;  <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span></span>  <span class="hljs-keyword">char</span>[] bits = binStr.toCharArray();  <span class="hljs-keyword">char</span> sign = bits[<span class="hljs-number">0</span>];  <span class="hljs-keyword">if</span>(sign == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;    <span class="hljs-keyword">int</span> index = <span class="hljs-number">31</span>;    <span class="hljs-keyword">int</span> flg = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(; index&gt;=<span class="hljs-number">0</span>; index--)&#123;      <span class="hljs-keyword">if</span> (flg == <span class="hljs-number">1</span>)&#123;        bits[index] = (bits[index]==<span class="hljs-string">&#x27;1&#x27;</span>)? <span class="hljs-string">&#x27;0&#x27;</span>:<span class="hljs-string">&#x27;1&#x27;</span>;      &#125;      <span class="hljs-keyword">if</span>(bits[index]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;        flg = <span class="hljs-number">1</span>;      &#125;    &#125;  &#125;  <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;  <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">31</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;    <span class="hljs-keyword">if</span>(bits[i] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;      ans += num;    &#125;    num &lt;&lt;= <span class="hljs-number">1</span>;  &#125;  <span class="hljs-keyword">if</span>(sign == <span class="hljs-string">&#x27;1&#x27;</span>) ans = -ans;  <span class="hljs-keyword">return</span> String.valueOf(ans);&#125;</code></pre><p>​       对1.1中的操作进行逆操纵，先对负数取反加一。然后根据</p><script type="math/tex; mode=display">S = \sum_{i=0}^{n}2^i×s</script><p>求得int的绝对值，在最后根据符号位补上符号。</p><h4 id="1-3-浮点数转二进制【最麻烦的部分】"><a href="#1-3-浮点数转二进制【最麻烦的部分】" class="headerlink" title="1.3 浮点数转二进制【最麻烦的部分】"></a>1.3 浮点数转二进制【最麻烦的部分】</h4><ul><li>浮点数的二进制表示有三个部分——符号（sign）、阶码（exponent）、尾数（fraction）</li><li>浮点数有规格化和非规格化之分；</li><li>在编写的过程中最好参考表格：</li><li><img src="/img/浮点数解释.png" alt=""></li><li>相信有更好的写法！</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">floatToBinary</span><span class="hljs-params">(String floatStr)</span> </span>&#123;  <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span></span>  String sign = <span class="hljs-string">&quot;0&quot;</span>;  String expStr;  String fracStr;  <span class="hljs-keyword">int</span> exponent = <span class="hljs-number">127</span>;  <span class="hljs-keyword">float</span> num = Float.parseFloat(floatStr);  <span class="hljs-keyword">if</span>(num &lt; <span class="hljs-number">0</span>)&#123;    sign = <span class="hljs-string">&quot;1&quot;</span>;    num = -num;  &#125;  <span class="hljs-keyword">while</span> (num-<span class="hljs-number">2</span> &gt; <span class="hljs-number">0</span>)&#123;    num /= <span class="hljs-number">2</span>;    exponent++;    <span class="hljs-keyword">if</span>(exponent == <span class="hljs-number">255</span>) <span class="hljs-keyword">break</span>;  &#125;  <span class="hljs-keyword">while</span> (num-<span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>)&#123;    num *= <span class="hljs-number">2</span>;    exponent--;    <span class="hljs-keyword">if</span>(exponent &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;  &#125;    <span class="hljs-keyword">if</span>(exponent &lt; <span class="hljs-number">1</span>)&#123;    expStr = <span class="hljs-string">&quot;00000000&quot;</span>;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exponent == <span class="hljs-number">255</span>)&#123;    expStr = <span class="hljs-string">&quot;11111111&quot;</span>;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">int</span> expTmp = exponent;    StringBuilder expBuilder = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">8</span>; i++)&#123;      <span class="hljs-keyword">if</span>(expTmp % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;        expBuilder.insert(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;1&quot;</span>);      &#125; <span class="hljs-keyword">else</span> &#123;        expBuilder.insert(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;0&quot;</span>);      &#125;      expTmp /= <span class="hljs-number">2</span>;    &#125;    expStr = expBuilder.toString();  &#125;  <span class="hljs-keyword">double</span> f = num - <span class="hljs-number">1</span>;  StringBuilder fracBuilder = <span class="hljs-keyword">new</span> StringBuilder();  <span class="hljs-keyword">if</span>(exponent == <span class="hljs-number">255</span>)&#123;    fracBuilder.append(<span class="hljs-string">&quot;00000000000000000000000&quot;</span>);  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">if</span>(exponent == <span class="hljs-number">0</span>)&#123;      f = num / <span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">while</span> (f &gt; <span class="hljs-number">0</span>)&#123;      f *= <span class="hljs-number">2</span>;      <span class="hljs-keyword">if</span>(f &gt;= <span class="hljs-number">1</span>)&#123;        fracBuilder.append(<span class="hljs-string">&quot;1&quot;</span>);        f -= <span class="hljs-number">1</span>;      &#125; <span class="hljs-keyword">else</span> &#123;        fracBuilder.append(<span class="hljs-string">&quot;0&quot;</span>);      &#125;    &#125;    <span class="hljs-keyword">int</span> pending = <span class="hljs-number">23</span>-fracBuilder.length();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;pending; i++)&#123;      fracBuilder.append(<span class="hljs-string">&quot;0&quot;</span>);    &#125;  &#125;  fracStr = fracBuilder.toString();  String ans = sign + expStr + fracStr;  <span class="hljs-comment">//下面几行有点奇怪，貌似是为了过oj而加入的，实际上不应该存在。</span>  <span class="hljs-keyword">if</span>(ans.equals(<span class="hljs-string">&quot;01111111100000000000000000000000&quot;</span>))&#123;    ans = <span class="hljs-string">&quot;+Inf&quot;</span>;  &#125;  <span class="hljs-keyword">if</span>(ans.equals(<span class="hljs-string">&quot;11111111100000000000000000000000&quot;</span>))&#123;    ans = <span class="hljs-string">&quot;-Inf&quot;</span>;  &#125;  <span class="hljs-keyword">return</span> ans;&#125;</code></pre><p>在这段代码中可以看到许多的特判（负数、无穷、溢出等等）。并且用到了许多浮点数比较（这是不好的习惯，但是不得已而为之）。</p><p>主要思路是：</p><p>1⃣️ 首先将负数的符号位设置好，并取它的绝对值。</p><p>2⃣️ 以规格化浮点数为界限，将<strong>整数部分大于等于2（即不是1的）</strong>和<strong>整数部分小于1（即也不是1的，而是0的）</strong>的进行规约。在这里需要注意的是，阶码是有上下界限的，一旦达到255或0，需要终止循环，这个时候得到的数值很可能是【无穷】、【0】、【非规格化浮点数】等等。</p><p>3⃣️ 算阶码部分：如果阶码=0直接置为“00000000”，阶码为255直接置为“11111111”，其余的按照转换为无符号整数的方法直接转化。</p><p>4⃣️ 规约结束，取浮点数的小数部分。在这里需要注意！有一个坑：对于2<sup>-127</sup>来说，它是非规格化的，需要用 2<sup>-126</sup>×0.5来表示。<em>【对于其他的非规格化数也同样如此，因为-126的缘故，我们在上面一步中的规约对于非规格化数其实是多乘来一个2。这样做的目的是使非规格化数和规格化数能够平滑过度】</em>因此，我们需要一个特判，如果阶码为0，那么我们需要把数次乘2之后的num除以一个2，<strong>为了补上-127转化到-126的坑</strong>。然后再进行尾数部分的转化——“乘二取整”，最后补齐23位。对于阶码为255的数，直接将尾数置为全0（无穷）。</p><p>5⃣️ 最后一步修正，将符号位、阶码和尾数三部分字符串组合起来，将正负无穷分别以“+Inf”和“-Inf”的形式表示。</p><h4 id="1-4-二进制转化为浮点数"><a href="#1-4-二进制转化为浮点数" class="headerlink" title="1.4 二进制转化为浮点数"></a>1.4 二进制转化为浮点数</h4><ul><li>这个题有点问题，明明是float，在oj判断的时候精度用的是double【吐槽】。但思路整体上是一样。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">binaryToFloat</span><span class="hljs-params">(String binStr)</span> </span>&#123;  <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span></span>  String sign = binStr.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);  String exponent = binStr.substring(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>);  String fraction = binStr.substring(<span class="hljs-number">9</span>, <span class="hljs-number">32</span>);  String ans = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">if</span>(exponent.equals(<span class="hljs-string">&quot;00000000&quot;</span>) &amp;&amp; fraction.equals(<span class="hljs-string">&quot;00000000000000000000000&quot;</span>))&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0.0&quot;</span>;  &#125;  <span class="hljs-keyword">int</span> exp = str2int(exponent, <span class="hljs-number">8</span>);  <span class="hljs-keyword">double</span> frac = <span class="hljs-number">0.0</span>;  <span class="hljs-keyword">if</span>( exp &gt; <span class="hljs-number">0</span> &amp;&amp; exp &lt; <span class="hljs-number">255</span> )&#123;    frac += str2flt(fraction);    frac += <span class="hljs-number">1</span>;    ans = Double.toString((frac * Math.pow(<span class="hljs-number">2</span>, exp-<span class="hljs-number">127</span>)));  &#125;  <span class="hljs-keyword">if</span>( exp == <span class="hljs-number">255</span> &amp;&amp; fraction.equals(<span class="hljs-string">&quot;00000000000000000000000&quot;</span>))&#123;    ans = <span class="hljs-string">&quot;Inf&quot;</span>;    <span class="hljs-keyword">if</span>(sign.equals(<span class="hljs-string">&quot;0&quot;</span>))&#123;      ans = <span class="hljs-string">&quot;+&quot;</span> + ans;    &#125;  &#125;  <span class="hljs-keyword">if</span>( exp == <span class="hljs-number">255</span> &amp;&amp; !fraction.equals(<span class="hljs-string">&quot;00000000000000000000000&quot;</span>))&#123;    ans = <span class="hljs-string">&quot;NaN&quot;</span>;  &#125;  <span class="hljs-keyword">if</span>( exp == <span class="hljs-number">0</span> )&#123;    frac += str2flt(fraction);    ans = Double.toString((frac * Math.pow(<span class="hljs-number">2</span>, exp-<span class="hljs-number">126</span>)));  &#125;  <span class="hljs-keyword">if</span>(sign.equals(<span class="hljs-string">&quot;1&quot;</span>))&#123;    ans = <span class="hljs-string">&quot;-&quot;</span> + ans;  &#125;  <span class="hljs-keyword">return</span> ans;&#125;</code></pre><p>主要思路：</p><p>1⃣️ 特判0；</p><p>2⃣️ 在这里封装了两个函数：将字符串转化为无符号整数，和字符串转化为浮点数。用到的就是之前的“除二取余”和“乘二取整”。</p><p>3⃣️ 根据符号位判断正负。</p><p>4⃣️ 这里的逻辑就简单了很多，根据表判断就可以——规格化数的时候是 2<sup>-127</sup>×(1.<em>f</em>)；正负无穷返回+/-Inf；还有NaN和非规格化数，最后不要忘记补上符号。</p><h4 id="1-5-十进制转化为NBCD"><a href="#1-5-十进制转化为NBCD" class="headerlink" title="1.5 十进制转化为NBCD"></a>1.5 十进制转化为NBCD</h4><ul><li>0～9对应0000～1001，正号用1100，负号用1101。</li><li>共有32位，即8个四位组合，如果不够需要补齐。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">decimalToNBCD</span><span class="hljs-params">(String decimal)</span> </span>&#123;  <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span></span>  <span class="hljs-keyword">char</span>[] numLst = decimal.toCharArray();  StringBuilder ansBuilder = <span class="hljs-keyword">new</span> StringBuilder();  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;  <span class="hljs-keyword">if</span>(numLst[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>)&#123;    ansBuilder.append(<span class="hljs-string">&quot;1101&quot;</span>);    i = <span class="hljs-number">1</span>;  &#125; <span class="hljs-keyword">else</span> &#123;    ansBuilder.append(<span class="hljs-string">&quot;1100&quot;</span>);  &#125;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">7</span>-numLst.length+i;j++)&#123;    ansBuilder.append(<span class="hljs-string">&quot;0000&quot;</span>);  &#125;  String BCD = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">for</span>(; i&lt;numLst.length; i++)&#123;    <span class="hljs-keyword">switch</span> (numLst[i])&#123;      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;0&#x27;</span>:        BCD = <span class="hljs-string">&quot;0000&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:        BCD = <span class="hljs-string">&quot;0001&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:        BCD = <span class="hljs-string">&quot;0010&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;3&#x27;</span>:        BCD = <span class="hljs-string">&quot;0011&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;4&#x27;</span>:        BCD = <span class="hljs-string">&quot;0100&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;5&#x27;</span>:        BCD = <span class="hljs-string">&quot;0101&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;6&#x27;</span>:        BCD = <span class="hljs-string">&quot;0110&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;7&#x27;</span>:        BCD = <span class="hljs-string">&quot;0111&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;8&#x27;</span>:        BCD = <span class="hljs-string">&quot;1000&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;9&#x27;</span>:        BCD = <span class="hljs-string">&quot;1001&quot;</span>; <span class="hljs-keyword">break</span>;    &#125;    ansBuilder.append(BCD);  &#125;  <span class="hljs-keyword">return</span> ansBuilder.toString();&#125;</code></pre><p>主要思路：单纯根据每个数字和符号取对应的BCD表示，需要注意的是补上0000满足位数的要求。总体来说相对简单。</p><h4 id="1-6-NBCD转化为十进制数"><a href="#1-6-NBCD转化为十进制数" class="headerlink" title="1.6 NBCD转化为十进制数"></a>1.6 NBCD转化为十进制数</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">NBCDToDecimal</span><span class="hljs-params">(String NBCDStr)</span> </span>&#123;  <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span></span>  StringBuilder strBuilder = <span class="hljs-keyword">new</span> StringBuilder();  String BCD = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;NBCDStr.length()-<span class="hljs-number">3</span>; i+=<span class="hljs-number">4</span>)&#123;    String swt = NBCDStr.substring(i, i+<span class="hljs-number">4</span>);    <span class="hljs-keyword">switch</span> (swt)&#123;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;0000&quot;</span>:        BCD = <span class="hljs-string">&quot;0&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;0001&quot;</span>:        BCD = <span class="hljs-string">&quot;1&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;0010&quot;</span>:        BCD = <span class="hljs-string">&quot;2&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;0011&quot;</span>:        BCD = <span class="hljs-string">&quot;3&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;0100&quot;</span>:        BCD = <span class="hljs-string">&quot;4&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;0101&quot;</span>:        BCD = <span class="hljs-string">&quot;5&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;0110&quot;</span>:        BCD = <span class="hljs-string">&quot;6&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;0111&quot;</span>:        BCD = <span class="hljs-string">&quot;7&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;1000&quot;</span>:        BCD = <span class="hljs-string">&quot;8&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;1001&quot;</span>:        BCD = <span class="hljs-string">&quot;9&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;1100&quot;</span>:        BCD = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;1101&quot;</span>:        BCD = <span class="hljs-string">&quot;-&quot;</span>; <span class="hljs-keyword">break</span>;    &#125;    strBuilder.append(BCD);  &#125;  <span class="hljs-keyword">while</span> (strBuilder.indexOf(<span class="hljs-string">&quot;0&quot;</span>)==<span class="hljs-number">0</span> &amp;&amp; strBuilder.length()&gt;<span class="hljs-number">1</span>)&#123;    strBuilder.delete(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);  &#125;  <span class="hljs-keyword">while</span> (strBuilder.indexOf(<span class="hljs-string">&quot;-&quot;</span>)==<span class="hljs-number">0</span> &amp;&amp; strBuilder.indexOf(<span class="hljs-string">&quot;0&quot;</span>)==<span class="hljs-number">1</span> &amp;&amp; strBuilder.length()&gt;<span class="hljs-number">1</span>)&#123;    strBuilder.delete(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  &#125;  <span class="hljs-keyword">return</span> strBuilder.toString();&#125;</code></pre><p>主要思路：每四个进行对应，将其转化为十进制的字符串。需要注意的是！因为32位的NBCD码要求，一些数字字符串中会有无用的0产生。需要将它们去除掉，在这里我使用的是——【对正数：第一位为0就去掉；对负数：当第一位为‘-’，第二位为0就去掉第二位的0。进行循环。】</p><p>总体来说，这次的作业有不少细节需要注意，会有一些小的细节的坑需要规避。比如浮点数转化为二进制字符串，如果不对太大的数字进行无穷的转换，就很可能在代码中产生死循环。以及负数的考虑：负数乘2再减1在数轴上会越来越偏离原点，导致死循环！还有规格化数到非规格化数到跳跃也是值得注意的重难点。</p><h2 id="算法设计与分析"><a href="#算法设计与分析" class="headerlink" title="算法设计与分析"></a>算法设计与分析</h2><h3 id="1-Hashing"><a href="#1-Hashing" class="headerlink" title="1. Hashing"></a>1. Hashing</h3><ul><li>Hashing的开销——几乎常量时间：O(1+α)</li></ul><h4 id="1-1-Collision-Handling"><a href="#1-1-Collision-Handling" class="headerlink" title="1.1 Collision Handling"></a>1.1 Collision Handling</h4><h5 id="1-1-Closed-Address"><a href="#1-1-Closed-Address" class="headerlink" title="1.1 Closed Address"></a>1.1 Closed Address</h5><ul><li><p>list在某一个空间的平均长度为<em>n</em>/<em>m</em>；</p></li><li><p>总共开销：Θ(1+ <em>n</em>/<em>m</em>)</p></li><li><p><strong>分析</strong>：对于一次成功的搜索，x<sub>i</sub>的可能性为1/n。对于给定的x<sub>i</sub>，被检测到的元素为<em>t+1</em>次（<em>t</em>是被插入同一个区域的元素数）。对于任意j，x<sub>j</sub>被插入同一个地方的可能性是<em>1/m</em>，因此花销为：</p><script type="math/tex; mode=display">1+\frac{1}{n}\sum_{i=1}^n(1+\sum_{j=i+1}^{n}\frac{1}{m})</script><p>1/m的和是“在要搜索的元素之前的链表中的元素数量”。计算结果大致是：</p><script type="math/tex; mode=display">\Theta(1+\alpha)</script></li></ul><h5 id="1-2-Open-Address"><a href="#1-2-Open-Address" class="headerlink" title="1.2 Open Address"></a>1.2 Open Address</h5><ul><li>不使用链表，所有的元素都存在哈希表中。</li><li>用”rehashing”来解决冲突。</li></ul><h5 id="1-3-Array-Doubling"><a href="#1-3-Array-Doubling" class="headerlink" title="1.3 Array Doubling"></a>1.3 Array Doubling</h5><ul><li><p>allocate a block of size <em>2size</em>; move all item into new table;</p></li><li><p>花销：size</p></li><li><p>执行n次操作，总共花销：</p><script type="math/tex; mode=display">\sum_{i=1}^nc_i{\leq}n+\sum_{j=0}^{log{n}}2^j<3n</script></li><li><p>每一个doubling的操作可以均摊到前面的每一次插入，足够多的准备。（均摊分析）</p></li></ul><h5 id="1-4-Amortized-Analysis"><a href="#1-4-Amortized-Analysis" class="headerlink" title="1.4 Amortized Analysis"></a>1.4 Amortized Analysis</h5><ul><li><em>amortized cost = actual cost + accounting cost</em></li></ul>]]></content>
    
    
    <categories>
      
      <category>WeeklyReview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WeeklyReview</tag>
      
      <tag>计组作业</tag>
      
      <tag>Hashing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>week3_Grade2_fall</title>
    <link href="/2020/09/26/week3-Grade2-fall/"/>
    <url>/2020/09/26/week3-Grade2-fall/</url>
    
    <content type="html"><![CDATA[<h2 id="算法设计与分析"><a href="#算法设计与分析" class="headerlink" title="算法设计与分析"></a>算法设计与分析</h2><h3 id="1-红黑树"><a href="#1-红黑树" class="headerlink" title="1. 红黑树"></a>1. 红黑树</h3><p><a href="https://www.jianshu.com/p/e136ec79235c">30张图彻底理解红黑树</a></p><h4 id="1-1-红黑树定义"><a href="#1-1-红黑树定义" class="headerlink" title="1.1 红黑树定义"></a>1.1 红黑树定义</h4><ul><li>基本限制：<ul><li>满足二叉搜索树；</li><li>每个节点要么是黑色的，要么是红色的；</li><li>所有的外部节点都是黑色的（每个叶子结点【NIL】是黑色）；</li><li>颜色限制：红色结点没有红色的子节点（每个红色结点的两个子节点一定都是黑色的）；</li><li>黑色高度限制：每个从给定结点u到外部节点的路径的黑色长度相等。（任意一结点到每个叶子结点到路径都包含数量相同的黑结点）<ul><li>推论：如果一个结点存在黑子节点，那么该结点肯定有两个子节点；</li></ul></li><li>根结点是黑色的；</li></ul></li><li>ARB tree (Almost-red-black tree)<ul><li>根结点是红色的；</li></ul></li><li>递归定义<ul><li>约定高度为h的红黑树为RB<sub>h</sub>，高度为h的Almost-red-black Tree为ARB<sub>h</sub></li><li>一个二叉树是ARB<sub>h</sub>，那么<ul><li>根结点是红色的；</li><li>左右子树都是RB<sub>h-1</sub></li></ul></li><li>一个二叉树是RB<sub>h</sub>，那么<ul><li>根结点是黑色的；</li><li>左右子树是RB<sub>h-1</sub>或ARB<sub>h</sub></li></ul></li></ul></li></ul><h4 id="1-2-红黑树的插入"><a href="#1-2-红黑树的插入" class="headerlink" title="1.2 红黑树的插入"></a>1.2 红黑树的插入</h4><ul><li>```c++<br>RBtree rbtInset(RBtree oldRBtree, Element newElement){<br>  InsReturn ans = rbtIns(oldRBtree, newNode);<br>  if(ans.newTree.color != black){<pre><code>ans.newTree.color = black; //黑高度增加的途径。</code></pre>  }<br>  return ans.newTree;<br>}<pre><code class="hljs xl">- **插入红色结点不会影响黑色高度限制**；【每次插入都不改变黑高度】- 簇：一个黑色结点和所有可从该黑色结点经由非黑色边达到的红色结点组成的集合，称为**簇**。- 冲突簇（Critical cluster）：起因于<span class="hljs-number">3</span>或<span class="hljs-number">4</span>个红色结点的颜色冲突。如果存在一个从根结点开始到达某结点的通路的长度大于<span class="hljs-number">1</span>，那么这个簇称为**冲突簇**。因为一个簇中的所有边都是非黑边，那么存在一条长度为<span class="hljs-number">2</span>的通路说明簇中一个红色结点与另一个红色结点之间有一条边。- 颜色漂移（Color flip）：冲突簇的根结点和它的子结点变换颜色，当没有新的冲突簇出现时，插入结束。（教材原话：We perform a *<span class="hljs-built_in">color</span> flip* <span class="hljs-keyword">with</span> the root of the cluster, call it *r*, <span class="hljs-built_in">and</span> its two children.）对于三个结点的冲突簇情况不能使用颜色漂移。【三个结点的情况使得中间那个结点变为黑色】  - ```c++    void rb_tree_main::colorFlip(rb_tree * old_tree)&#123;      <span class="hljs-comment">//修改根结点的颜色</span>      <span class="hljs-function"><span class="hljs-title">if</span>(old_tree-&gt;</span><span class="hljs-built_in">color</span> == color_black)&#123;        <span class="hljs-function"><span class="hljs-title">old_tree</span>-&gt;</span><span class="hljs-built_in">color</span> = color_red;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-function"><span class="hljs-title">old_tree</span>-&gt;</span><span class="hljs-built_in">color</span> = color_black;      &#125;            <span class="hljs-comment">//修改根的左子结点的颜色</span>      <span class="hljs-function"><span class="hljs-title">if</span>(old_tree-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span>-&gt;</span><span class="hljs-built_in">color</span> == color_black)&#123;        <span class="hljs-function"><span class="hljs-title">old_tree</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span>-&gt;</span><span class="hljs-built_in">color</span> = color_red;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-function"><span class="hljs-title">old_tree</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span>-&gt;</span><span class="hljs-built_in">color</span> = color_black;      &#125;            <span class="hljs-comment">//修改根的右子节点的颜色</span>      <span class="hljs-function"><span class="hljs-title">if</span>(old_tree-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span>-&gt;</span><span class="hljs-built_in">color</span> == color_clack)&#123;        <span class="hljs-function"><span class="hljs-title">old_tree</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span>-&gt;</span><span class="hljs-built_in">color</span> = color_red;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-function"><span class="hljs-title">old_tree</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span>-&gt;</span><span class="hljs-built_in">color</span> = color_black;      &#125;    &#125;</code></pre></li></ul><h4 id="1-3-修正红黑树（RepairLeft-和-RepairRight）"><a href="#1-3-修正红黑树（RepairLeft-和-RepairRight）" class="headerlink" title="1.3 修正红黑树（RepairLeft 和 RepairRight）"></a>1.3 修正红黑树（RepairLeft 和 RepairRight）</h4><ul><li><p>ok：不需要修正；</p><ul><li>```c++<br>if(ansLeft.status == status.ok){<br>  ans.new_tree = old_tree;<br>  ans.status = status.ok;<br>  return ans<br>}<br>old_tree-&gt;left = ansLeft.new_tree;<pre><code class="hljs fortran">- rbr：不要调整；要将返回值存入相应的field。  - ```c++    <span class="hljs-keyword">if</span>(ansLeft<span class="hljs-number">.</span><span class="hljs-keyword">status</span> == <span class="hljs-keyword">status</span><span class="hljs-number">.</span>rbr)&#123;      ans<span class="hljs-number">.</span>new_tree = old_tree;      ans<span class="hljs-number">.</span><span class="hljs-keyword">status</span> = <span class="hljs-keyword">status</span><span class="hljs-number">.</span>ok;    &#125;</code></pre></li></ul></li><li><p>brb：如果父结点是黑色的，不修正；否则需要向上调整（若当前不调整，返回的状态为rrb）</p><ul><li>```c++<br>if(ansLeft.status == status.brb){<br>  ans.new_tree = old_tree;<br>  if(old_tree-&gt;color == color_black){<pre><code>ans.status = status.ok;</code></pre>  } else {<pre><code>ans.status = status_rrb;</code></pre>  }<br>}<pre><code class="hljs maxima">- rrb：【**当前的父结点的颜色一定为黑色**】根据oldTree的右（左）子节点的情况进行调整（分别对应<span class="hljs-number">4</span>-node和<span class="hljs-number">3</span>-node两种颜色冲突的情况）；  - ```c++    <span class="hljs-keyword">if</span>(ansLeft.<span class="hljs-built_in">status</span> == <span class="hljs-built_in">status</span>.rrb)&#123;     <span class="hljs-keyword">if</span>(old_tree-&gt;right-&gt;<span class="hljs-built_in">color</span> == color_red)&#123;       colorFlip(old_tree);       ans.new_tree = old_tree;       ans.<span class="hljs-built_in">status</span> = <span class="hljs-built_in">status</span>.brb;     &#125; <span class="hljs-keyword">else</span> &#123;       ans.new_tree = rebalLeft(old_tree, ansLeft.<span class="hljs-built_in">status</span>);       ans.<span class="hljs-built_in">status</span> = rbr;     &#125;    &#125;</code></pre></li></ul></li><li><p>brr：和rrb的处理情况类似；</p></li><li><p>所有的处理都不会对黑高度造成影响；</p></li></ul><h4 id="1-4-红黑树的删除"><a href="#1-4-红黑树的删除" class="headerlink" title="1.4 红黑树的删除"></a>1.4 红黑树的删除</h4><ul><li>只有一个子节点的结点可以直接删除；</li><li><strong>保持颜色限制，调整高度。</strong><ul><li>删除红色结点，黑高度不变，没有任何影响；</li><li>删除黑色结点，该结点所在的子树的黑高度减少了1，需要进行修正。<strong>并且这种修正可能导致更高的子树的黑高度降低，需要继续修正。</strong></li></ul></li><li>删除时，将该结点与它在中序遍历之后的后一个结点互换。删除互换后的该结点。将该结点的右结点代替被删除的集合。</li></ul><h3 id="2-渐进复杂性"><a href="#2-渐进复杂性" class="headerlink" title="2. 渐进复杂性"></a>2. 渐进复杂性</h3><h4 id="2-1-Ο"><a href="#2-1-Ο" class="headerlink" title="2.1 Ο"></a>2.1 <em>Ο</em></h4><ul><li><p>复杂度的上界（包含）</p></li><li><p>判断是否包含在<em>Ο</em>的时候可以使用【洛必达法则】。</p></li><li><p>对数复杂度小于幂函数复杂度！</p></li><li><script type="math/tex; mode=display">logn \in O(n^{\alpha}) ,{\forall}{\alpha}>0</script></li><li><p>幂函数复杂度小于指数复杂度！</p></li><li><script type="math/tex; mode=display">n^k \in O(c^n) ,{\forall}c>0</script></li><li><p>阶乘用斯特林公式处理：</p></li><li><script type="math/tex; mode=display">n!≈\sqrt{2{\pi}n}(\frac{n}{e})^n</script></li></ul><h4 id="2-2-Ω"><a href="#2-2-Ω" class="headerlink" title="2.2 Ω"></a>2.2 Ω</h4><ul><li>复杂度的下界（包含）</li></ul><h4 id="2-3-Θ"><a href="#2-3-Θ" class="headerlink" title="2.3 Θ"></a>2.3 Θ</h4><ul><li>复杂度上界与下界的交集——大致相同于真实复杂度；</li></ul><h4 id="2-4-Ο-Ω-Θ的性质"><a href="#2-4-Ο-Ω-Θ的性质" class="headerlink" title="2.4 Ο, Ω, Θ的性质"></a>2.4 <em>Ο</em>, Ω, Θ的性质</h4><ul><li><p><em>Ο</em>是一个等价关系——有传递性、对称性和自反性；</p></li><li><script type="math/tex; mode=display">O(f+g) = O(max(f,g))</script></li></ul><h4 id="2-5-o-和-ω"><a href="#2-5-o-和-ω" class="headerlink" title="2.5 o 和 ω"></a>2.5 o 和 ω</h4><ul><li>f与它的上界（下界）之间有一段不可忽视的距离。（不能大致相等）不光表示小于（大于），也表示f达不到g。</li></ul><h4 id="2-6-分治递归"><a href="#2-6-分治递归" class="headerlink" title="2.6 分治递归"></a>2.6 分治递归</h4><ul><li><p>将规模为n的问题分解成a个规模为n/b的子问题并递归地求解，并且分解/合成的总开销是f(n)的。</p></li><li><script type="math/tex; mode=display">T(n) = aT(\frac{n}{b})+f(n)</script></li><li><p>主定理：</p><ul><li><script type="math/tex; mode=display">f(n){\in}O(𝑛^{log_𝑏⁡{𝑎−𝜀}})，T(n)\in(𝑛^{log_𝑏⁡𝑎})</script></li><li><script type="math/tex; mode=display">f(n){\in}{\Theta}(𝑛^{log_𝑏⁡{𝑎}})，T(n){\in}{\Theta}(f(n)log(n))</script></li><li><p>具体见《算法导论》。</p></li><li>特别的一个特殊情况：</li></ul><script type="math/tex; mode=display">f(m)\in\Theta(m^Elog^a(m))</script><p>​       它的解为：</p><script type="math/tex; mode=display">T(n)\in\Theta(n^Elog^{a+1}(n))</script></li></ul><h2 id="计算机组成与设计"><a href="#计算机组成与设计" class="headerlink" title="计算机组成与设计"></a>计算机组成与设计</h2><h3 id="1-Carry-Look-Ahead-Adder"><a href="#1-Carry-Look-Ahead-Adder" class="headerlink" title="1. Carry Look Ahead Adder"></a>1. Carry Look Ahead Adder</h3><ul><li>Gate Latency<ul><li>AND：1</li><li>OR：1</li><li>XOR：3</li><li>计算CarryOut需要2个延迟</li></ul></li><li><img src="/img/加法器.png" alt="加法器及其延迟"></li><li>再上图中，计算<em>XY</em>和<em>X+Y</em>（即<em>P</em>和<em>G</em>）需要1个延迟，计算所有的<em>C</em>需要两个延迟，计算所有的<em>S</em>又需要3个延迟。（注：根据之前的推导，任意<em>C<sub>n</sub></em>都可以用<em>P、G、C<sub>n</sub></em>来表示）</li></ul><h3 id="2-Partial-Carry-Look-Ahead-Adder"><a href="#2-Partial-Carry-Look-Ahead-Adder" class="headerlink" title="2. Partial Carry Look Ahead Adder"></a>2. Partial Carry Look Ahead Adder</h3><ul><li><p><img src="/img/部分加法器.png" alt="部分加法器及其延迟"></p></li><li><p>在第一个时间周期内计算出所有的<em>P</em>和<em>G</em>，最右边的第一个CLA计算出<em>C8</em>需要3个延迟，往后的<em>C16</em>和<em>C24</em>都需要两个时间周期，最后计算最后的<em>C</em>和<em>S</em>还需要5个延迟。</p></li></ul><h3 id="3-Addition"><a href="#3-Addition" class="headerlink" title="3. Addition"></a>3. Addition</h3><p><em>overflow</em> = C<sub>n</sub>⊕C<sub>n-1</sub> ? Why?</p><p>证明和分析：如果overflow为0，只有两种情况——正数加正数得到负数和负数加负数得到正数。所以我们可以通过符号位来判断：<em>overflow</em> = X<sub>n</sub>Y<sub>n</sub>~S<sub>n</sub>+~X<sub>n</sub>~Y<sub>n</sub>S<sub>n</sub>，当X<sub>n</sub>Y<sub>n</sub>同时为1的时候，S<sub>n</sub>若为0则溢出。当X<sub>n</sub>Y<sub>n</sub>同时为0的时候，S<sub>n</sub>若为1则溢出。</p><h3 id="4-Subtraction"><a href="#4-Subtraction" class="headerlink" title="4. Subtraction"></a>4. Subtraction</h3><h3 id="5-Multiplication"><a href="#5-Multiplication" class="headerlink" title="5. Multiplication"></a>5. Multiplication</h3><ul><li><p>大概步骤：</p><ul><li>每一步计算部分和；</li><li>右移部分和；</li><li>如果<em>Y<sub>i</sub>=0</em>的话，只移动；</li></ul></li><li><p>Booth算法</p></li><li><script type="math/tex; mode=display">P_{i+1}=2^{-1}×(P_i+X×(Y_i-Y_{i+1}))</script><ul><li>初识情况令Y<sub>0</sub> = 0.</li><li>根据 <em>Y<sub>i+1</sub> - Y<sub>i</sub></em> 来判断是 <em>+X，-X，+0</em></li><li>右移部分和；</li><li>重复第二步和第三步；</li></ul></li><li><p>为了使结果正确，每一步应当使用算数右移。补充上去的符号位在计算出结果的符号位会被舍去。</p></li></ul><h3 id="6-Division"><a href="#6-Division" class="headerlink" title="6. Division"></a>6. Division</h3><ul><li>将被除数（remainder）的左边补上<em>n</em>位的<strong>符号位</strong>，除数左边补上<em>n</em>位的0，每一次将除数减被除数，再右移除数一位，若差大于等于0，则在此处的商置为1，将商左移一位。（原始版本）<ul><li>（remainder和quotient合在一起）依然是用division减remainder（前面的n位），如果是异号则用加法。</li></ul></li><li><strong>余数一定和被除数同号</strong>（用除数不断去逼近被除数，但是不能越过它）</li><li>当除数和被除数异号的时候，每次操作的减法变为<em>加法</em>。</li><li>若每次的加法或减法溢出，则做逆操作使得被除数恢复（recover）。</li><li>如果被除数和除数的异号的，我们需要对商修正——取反加一。</li><li><img src="/img/除法.png" alt="除法符号表"></li><li><strong>将错就错版本</strong>：<ul><li>符号扩展n位，然后存储在余数-商寄存器；</li><li>如果被除数和除数有相同的符号做减法，否则做加法：<ul><li>如果余数和除数有相同的符号，<em>Q<sub>n</sub></em>为1，反之为0。</li></ul></li><li>如果余数和除数有相同的符号，那么 <em>R<sub>i+1</sub> = 2R<sub>i</sub> - Y</em> ，否则 <em>R<sub>i+1</sub> = 2R<sub>i</sub> + Y</em> （注：有相同符号说明不需要补上之前错减的操作，继续-Y就可以；若不同说明需要减去之前的操作，因为前面已经错减了，左移*2之后，加上一个Y就可以）<ul><li>如果新的余数和除数有相同的符号，将商置为1，否则置为0。</li></ul></li><li>重复。</li></ul></li></ul><h3 id="7-浮点数运算"><a href="#7-浮点数运算" class="headerlink" title="7. 浮点数运算"></a>7. 浮点数运算</h3><ul><li>对阶</li></ul>]]></content>
    
    
    <categories>
      
      <category>WeeklyReview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WeeklyReview</tag>
      
      <tag>红黑树</tag>
      
      <tag>渐进复杂性</tag>
      
      <tag>ALU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TOEFL_reading_notes</title>
    <link href="/2020/09/22/TOEFL-reading-notes/"/>
    <url>/2020/09/22/TOEFL-reading-notes/</url>
    
    <content type="html"><![CDATA[<h3 id="题型一：Vocabulary-Questions"><a href="#题型一：Vocabulary-Questions" class="headerlink" title="题型一：Vocabulary Questions"></a>题型一：Vocabulary Questions</h3><p>only one of those meanings is relevant.</p><h4 id="做题方法"><a href="#做题方法" class="headerlink" title="做题方法"></a>做题方法</h4><ul><li>认识要选对；</li><li>没有不认识的；</li><li>求同：沾边就对；不存异：不做同义词辨析。</li></ul><h4 id="练习方法"><a href="#练习方法" class="headerlink" title="练习方法"></a>练习方法</h4><p>题干一个词 + 选项四个词 =&gt; 查英文词典记住；</p><h3 id="题型二：Sentence-Simplification-Questions"><a href="#题型二：Sentence-Simplification-Questions" class="headerlink" title="题型二：Sentence Simplification Questions"></a>题型二：Sentence Simplification Questions</h3><p>essential meaning.</p><h4 id="做题方法-1"><a href="#做题方法-1" class="headerlink" title="做题方法"></a>做题方法</h4><ol><li><p>确定题干句子的逻辑关系：</p><ul><li><p>逻辑关系词：1. 连词，2. 副词</p></li><li><p>感情色彩</p></li></ul></li><li><p>确定和逻辑关系相关的语义；</p></li><li>选择逻辑或者相关语义一致的选项；</li></ol><ul><li>常考逻辑：因果、比较、否定、最高级<ul><li>Because / so;</li><li>Lead to / cause;</li><li>encourage;</li><li>be responsible for;</li></ul></li><li>转折：but / while / whereas</li><li>让步：though / despite / albeit</li><li>条件：if / unless</li><li>并列：and / as well as</li></ul><p>逻辑作用的对象：</p><ul><li>因果：原因、结果；</li><li>比较：主题、对象；</li><li>否定、最高级</li></ul><p><strong>原则最简化 </strong> &amp;&amp;  <strong>先逻辑，后语意</strong></p><h3 id="题型三：Factual-Information-Questions"><a href="#题型三：Factual-Information-Questions" class="headerlink" title="题型三：Factual Information Questions"></a>题型三：Factual Information Questions</h3><p>explicitly stated <strong>明确提及</strong>            mentioned only in part of the passage.</p><p>Often the relevant information is in one or two sentences. <strong>在文章某一部分一到两句话明确提及的事实信息。</strong></p><h4 id="做题方法-2"><a href="#做题方法-2" class="headerlink" title="做题方法"></a>做题方法</h4><ul><li>先读一段文章，后做该段的题；</li><li>顺序：事实信息 ——&gt; 题干 ——&gt; 一到两句话 ——&gt; 选项 ——&gt; 排除（选对的）</li><li>干扰选项：① 答非所问；② 无中生有；③ 虚假比较；</li></ul><ol><li><p>定位【缩小阅读范围】</p><ul><li><p>定位方法：</p><p>a. 名词 &gt; 动词、形容词、副词；</p><p>b. 特殊 &gt; 普通；</p><p>​        特殊情况：</p><p>​                ① 题干定位线索在段落中多次出现；</p><p>​                ② 线索是 title 或 topic 用选项定位排除法；</p><p>c. 对名词修饰也在定位范围内；</p><p>d. 特殊疑问词（where/when/why/how）.</p></li></ul></li><li><p>精读：单词\语法\逻辑</p></li><li><p>同义改写：原文和选项之间同意信息点的对应；</p><ul><li>选项和原文信息点对应更多更重要的是正确选项</li></ul></li></ol><p><strong><em>切忌：过度推断；生活经验</em></strong></p><p>典型错误选项：</p><ul><li>答非所问：题干定位线索和题目问题不一致，题干中出现表示因果关系的逻辑关系词；Because/so/since/for/as a result of … 基于因果关系，扩大阅读范围。</li><li>无中生有：选项改变了原文动作主题和对象、感情色彩、动名词搭配、并列连词、否定词；</li><li>虚假比较：选项中出现了原文中没有的比较级、最高级、绝对化（absolute/extreme/definite/total/entire/all/every/any/never）、范围扩张（some/many/plenty/majority/major/most of）</li><li>优先认定包含虚假比较的选项为错误选项，如果原文有一一对应则该选项为正确选项；</li></ul><h3 id="题型四：Negative-Factual-Information-Questions"><a href="#题型四：Negative-Factual-Information-Questions" class="headerlink" title="题型四：Negative Factual Information Questions"></a>题型四：Negative Factual Information Questions</h3><h4 id="做题方法："><a href="#做题方法：" class="headerlink" title="做题方法："></a>做题方法：</h4><ul><li>定位</li><li>精读</li><li>排除</li><li>对应规则：<ul><li>对应原文集中举例：注意平行结构；</li><li>对应原文分散举例：选项排除法；</li><li>段落中存在多项并列的内容，往往有排除题；</li></ul></li></ul><h3 id="题型五：Inference-Questions"><a href="#题型五：Inference-Questions" class="headerlink" title="题型五：Inference Questions"></a>题型五：Inference Questions</h3><p>正确答案不在文章中提及。</p><h4 id="做题方法：-1"><a href="#做题方法：-1" class="headerlink" title="做题方法："></a>做题方法：</h4><ul><li>定位</li><li>精读</li><li>排除</li><li>因果推断：结果 ≈ 原因</li></ul><h3 id="题型七：Insert-Text-Question"><a href="#题型七：Insert-Text-Question" class="headerlink" title="题型七：Insert Text Question"></a>题型七：Insert Text Question</h3><p>grammatical connections.</p><p>时间压力大，不按文章顺序出</p><p>指代、逻辑、重复</p><h4 id="做题方法：-2"><a href="#做题方法：-2" class="headerlink" title="做题方法："></a>做题方法：</h4><ul><li>线索提取 =&gt; 题干</li><li>线索匹配 =&gt; 原文</li><li>连贯性检查 =&gt; 题干 + 原文</li></ul><p>代词：代词所在句子位于被指代名字所在句子的后面。</p><p>逻辑：</p><ul><li>词性：<ul><li>conj. ——&gt; 句子内 ——&gt; 简化；</li><li>adv. ——&gt; 句间 ——&gt; 插入；</li></ul></li><li>感情色彩：A but B<ul><li>正面：因果（感情色彩一致）</li><li>反面：转折、让步、比较；</li></ul></li></ul><p>重复信息：</p><ul><li>标志词：<ul><li>that is to say / that is / namely / in other words 换句话说；</li><li>in fact / indeed : give extra details to the topic just mentioned.；</li><li>similarly / likewise : 相似的，相同的；</li><li>举例：for example 观点 =&gt; 细节（例子）</li></ul></li><li>无标志词：同义词、同义替换；</li><li>“观点阐述”原则：概括、抽象在前；具体，细节在后；</li></ul><h5 id="题干-——-gt-找线索"><a href="#题干-——-gt-找线索" class="headerlink" title="题干 ——&gt; 找线索"></a>题干 ——&gt; 找线索</h5><ul><li>指代 ——&gt; pron. 往后放</li><li>逻辑 ——&gt; 正/反 往反放；</li><li>重复 ——&gt; 往后放；</li></ul><h3 id="题型八：Rhetorical-Purpose-Question"><a href="#题型八：Rhetorical-Purpose-Question" class="headerlink" title="题型八：Rhetorical Purpose Question"></a>题型八：Rhetorical Purpose Question</h3><p>{具体信息，段落功能，段落关系}</p><h4 id="做题方法：-3"><a href="#做题方法：-3" class="headerlink" title="做题方法："></a>做题方法：</h4><ol><li>定位</li><li>当前句是观点，是答案；</li><li>当前句不是观点，看前一句；</li><li>前一句也不是观点，看段落主旨句；</li></ol><p>当前句包含明确举例词的时候，看前一句</p><p>当前句中没有明确举例词的时候，判断：</p><ul><li>举例主题是具体细节内容；</li><li>和前一句话没有观点冲突；</li></ul><h5 id="目的题："><a href="#目的题：" class="headerlink" title="目的题："></a>目的题：</h5><p>当前句</p><ul><li>举例词——前一句</li><li>无举例词<ul><li>具体/无冲突——前一句</li><li>冲突——当前句</li></ul></li></ul><h5 id="段落功能"><a href="#段落功能" class="headerlink" title="段落功能"></a>段落功能</h5><p>What is the purpose/function/organization of the paragraph?</p><p>What is the relationship between Para1. and the rest of the passage in the larger discussion of xxx?</p><p>正确选项：main idea + 紧密相关的重要内容；</p><h5 id="段落关系"><a href="#段落关系" class="headerlink" title="段落关系"></a>段落关系</h5><p>Relationship between p1 and p2?</p><ol><li>阅读范围：两句话——前段末句和后段首句；</li><li>关系类型：顺承；转折/对比；举例解释<ul><li>顺承 =&gt; 语意链接；</li><li>转折/对比 =&gt; 逻辑关系词 however/on the contrary</li><li>举例 =&gt; for example</li><li>解释：explain/illustrate/elaborate/interpret</li></ul></li><li>判断方式<ul><li>变化：change/move/shift/migration/become/deteriorate/diminish</li><li>重要：important/significant</li><li>影响：effect/influence/impact</li><li>关系：relate/connect</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>TOEFL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TOEFL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>week2_Grade2_fall</title>
    <link href="/2020/09/18/week2-Grade2-fall/"/>
    <url>/2020/09/18/week2-Grade2-fall/</url>
    
    <content type="html"><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>​        上个期末考试期结束，就打算每周做一个小的总结，一是方便后续的总复习，而来能够 push 自己按时按计划复习。本学期主要学习的课程有《计组》、《算法》、《数据结构》、《数据科学基础》还有《线代》。数学课的内容重点在于刷题，不会像其他课一样总结主要概念和框架，可能会总结一些偏重难点。尽量 push 自己在每天都补充一些内容，以便于在一周的周六内发布。</p><h2 id="算法设计与分析"><a href="#算法设计与分析" class="headerlink" title="算法设计与分析"></a>算法设计与分析</h2><h3 id="0-尾递归"><a href="#0-尾递归" class="headerlink" title="0. 尾递归"></a>0. 尾递归</h3><p>我们常常用尾递归的方式将递归转化为迭代。</p><h4 id="0-0-回顾-SICP-中-Scheme-的尾递归"><a href="#0-0-回顾-SICP-中-Scheme-的尾递归" class="headerlink" title="0.0. 回顾 SICP 中 Scheme 的尾递归"></a>0.0. 回顾 SICP 中 Scheme 的尾递归</h4><p>因为函数式语言的最大特征之一是无法赋值，因此无法使用过程式语言中的 for 或者 while 循环来实现迭代。为了减小开销使得递归的效率更高，Scheme 引入了尾递归。(调用之后释放空间，与传统递归不同)</p><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">fact</span> n)  (<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">fact-tail</span> n result)    (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">&lt;=</span></span> n <span class="hljs-number">1</span>)        result        (<span class="hljs-name">fact-tail</span> (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> n <span class="hljs-number">1</span>) (<span class="hljs-name"><span class="hljs-builtin-name">*</span></span> n result))))  (<span class="hljs-name">fact-tail</span> n <span class="hljs-number">1</span>))</code></pre><p>Scheme 中的递归会使用一个辅助函数。每调用一次辅助函数之后，函数不需要在返回到调用者的函数，而是直接带着 result 调用后续的函数。</p><h4 id="0-1-尾递归的基本概念"><a href="#0-1-尾递归的基本概念" class="headerlink" title="0.1. 尾递归的基本概念"></a>0.1. 尾递归的基本概念</h4><ul><li>尾递归：一个递归函数仅仅在运算的最后才递归调用自身，并且调用后直接返回。</li><li><p>尾递归转换为迭代的方法：</p><ul><li>将每个参数转换为变量声明；</li><li>将函数体转换为一个循环体，并且对于基本情况直接返回相应的结果；递归调用时，首先计算新的参数并赋予相关的变量，后面跟上 continue 的语句。</li></ul></li><li><p>e.g.</p><pre><code class="hljs C">Euclid_recursion(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)&#123;<span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> m;    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">int</span> rem = m % n;        <span class="hljs-keyword">return</span> Euclid_Recursion(n, rem);    &#125;&#125;Euclid_tailRecursion(<span class="hljs-keyword">int</span> m1, <span class="hljs-keyword">int</span> n1)&#123;    <span class="hljs-keyword">int</span> m = m1;    <span class="hljs-keyword">int</span> n = n1;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<span class="hljs-comment">//while(true)模式，一般情况下可以转换为for循环。</span>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> m;        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">int</span> tmp = n;            n = m % n;            m = n;        &#125;    &#125;&#125;</code></pre></li></ul><h3 id="1-排序问题和排序算法-1"><a href="#1-排序问题和排序算法-1" class="headerlink" title="1. 排序问题和排序算法-1"></a>1. 排序问题和排序算法-1</h3><h4 id="1-1-插入排序（Insertion-Sort"><a href="#1-1-插入排序（Insertion-Sort" class="headerlink" title="1. 1. 插入排序（Insertion Sort)"></a>1. 1. 插入排序（Insertion Sort)</h4><h5 id="1-1-1-插入排序的基本内涵和实现"><a href="#1-1-1-插入排序的基本内涵和实现" class="headerlink" title="1.1.1. 插入排序的基本内涵和实现"></a>1.1.1. 插入排序的基本内涵和实现</h5><ul><li><p>基本情况：n == 1时，不需要排序。</p></li><li><p>递归情况：n &gt; 1时，分成两组——任意数 v 和其余的n-1个数；然后递归地排好剩下的n-1个数，再将v插入到已经排序完成的数列的适当位置，得到排序完成的数组。</p></li><li><p>如何插入？(下面的Insert_Abs就是插入算法)</p><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] Insert_Abs(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span>[] list)&#123;<span class="hljs-keyword">if</span>(list.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> v;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v &lt;= Head(list)) <span class="hljs-keyword">return</span> &#123;v&#125; + list;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> Head(list) + Insert_Abs(v, Tail(list));&#125;</code></pre></li><li><p>实现</p><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] insert(<span class="hljs-keyword">int</span>[] A)&#123;    <span class="hljs-keyword">int</span> i, j;    <span class="hljs-keyword">int</span> len = A.length;    <span class="hljs-keyword">int</span> target;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;len-<span class="hljs-number">1</span>; i++)&#123;        j = i;        target = A[i];<span class="hljs-comment">//等价于ppt中推导时所用到的v</span>        <span class="hljs-keyword">while</span>(j&gt;<span class="hljs-number">0</span> &amp;&amp; target&lt;A[j-<span class="hljs-number">1</span>])&#123;<span class="hljs-comment">//一旦target比前面的元素大，那么就插入它的后面</span>            A[j] = A[--j];<span class="hljs-comment">//否则将元素后移一位，空出位置给target。</span>        &#125;<span class="hljs-comment">//这个算法的实现和课上所讲的略有不同</span>        A[j] = target;<span class="hljs-comment">//这个算法是从前向后插入，课上是从后向前</span>    &#125;    <span class="hljs-keyword">return</span> A;&#125;</code></pre></li></ul><h5 id="1-1-2-插入排序-Insert-函数的循环不变式"><a href="#1-1-2-插入排序-Insert-函数的循环不变式" class="headerlink" title="1.1.2. 插入排序 Insert 函数的循环不变式"></a>1.1.2. 插入排序 Insert 函数的循环不变式</h5><ul><li>初始情况下，从start+1到end是排好序的；</li><li>在经过一次操作之后，从start到end是排好序；</li><li>循环一定是可以终止在 i = len-1的；</li></ul><h5 id="1-1-3-最坏情况分析"><a href="#1-1-3-最坏情况分析" class="headerlink" title="1.1.3. 最坏情况分析"></a>1.1.3. 最坏情况分析</h5><ul><li><p>最坏情况：逆序</p></li><li><p>时间复杂度：Ο(n<sup>2</sup>)</p></li><li><p>平均情况：对于每一个 i ，对应会有 j 个比较次数（内循环）。</p><script type="math/tex; mode=display">\frac{1}{i+1}\sum_{j=1}^{i}j + \frac{1}{i+1}(i) = \frac{i}{2}+1-\frac{1}{i+1}</script><p>求和之后，仍是 Ο(n<sup>2</sup>)。</p></li></ul><h4 id="1-2-快速排序"><a href="#1-2-快速排序" class="headerlink" title="1.2. 快速排序"></a>1.2. 快速排序</h4><h5 id="1-2-1-基本思路和实现"><a href="#1-2-1-基本思路和实现" class="headerlink" title="1.2.1 基本思路和实现"></a>1.2.1 基本思路和实现</h5><ul><li><p>按照某个数进行划分，小于这个数的作为一部分，大于这个数的作为另一部分。</p></li><li><p>采用分划算法 Partition(v, list) 将list分划成两个list：smallerList中的值都小于v，biggerList中都大于等于v。</p></li><li><p>有关实现：</p><ul><li>Partition 函数分割后的值仍然存放在这个区域。</li><li>QuickSort 之后得到的数据仍然存放在相同的区域。</li></ul></li><li><p>以下是“挖坑法”：（均在数组的原地址空间内进行改动）</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span>&#123;  <span class="hljs-keyword">if</span>(end &lt;= start) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> pivotIndex = partition(arr, start, end);    quickSort(arr, start, pivotIndex-<span class="hljs-number">1</span>);    quickSort(arr, pivotIndex+<span class="hljs-number">1</span>, end);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span>&#123;    <span class="hljs-keyword">int</span> pivot = arr[start];    <span class="hljs-keyword">int</span> left = start;    <span class="hljs-keyword">int</span> right = end;    <span class="hljs-keyword">int</span> index = start; <span class="hljs-comment">//挖坑的位置</span>    <span class="hljs-keyword">while</span> (left &lt;= right)&#123;        <span class="hljs-comment">//从右边向左边找到比标记更小的，将它转移到标记的左边</span>        <span class="hljs-keyword">while</span> (left &lt;= right)&#123;            <span class="hljs-keyword">if</span>(arr[right] &lt; pivot)&#123;                arr[left] = arr[right];                index = right;                left++;                <span class="hljs-keyword">break</span>;            &#125;            right--;        &#125;        <span class="hljs-comment">//从左向右找到比标记更大的，将它换转移到标记的右边，若上面发生了更换，那么这里也一定是把Pivot填写在上一个循环挖出的空间中；</span>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;            <span class="hljs-keyword">if</span> (arr[left] &gt; pivot)&#123;                arr[right] = arr[left];                index = left;                right--;                <span class="hljs-keyword">break</span>;            &#125;            left++;        &#125;    &#125;<span class="hljs-comment">//补上漏洞</span>    arr[index] = pivot;    <span class="hljs-keyword">return</span> index;&#125;</code></pre><ul><li>“指针交换法”：先把pivot以外的元素排好，再把pivot插入到其中相应的位置。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span>&#123;    <span class="hljs-keyword">if</span>(start &gt;= end) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> pivotIndex = partition(arr, start, end);    quickSort(arr, start, pivotIndex-<span class="hljs-number">1</span>);    quickSort(arr, pivotIndex+<span class="hljs-number">1</span>, end);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span>&#123;    <span class="hljs-keyword">int</span> pivot = arr[start];    <span class="hljs-keyword">int</span> left = start;    <span class="hljs-keyword">int</span> right = end;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-comment">//控制right指针比较并左移</span>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[right]&gt;pivot)&#123;        right--;    &#125;        <span class="hljs-comment">//控制right指针比较并右移</span>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot)&#123;            left++;        &#125;        <span class="hljs-comment">//交换left和right指向的元素</span>    <span class="hljs-keyword">if</span>(arr[left]&gt;arr[right])&#123;            <span class="hljs-keyword">int</span> p = arr[left];            arr[left] = arr[right];            arr[right] = p;        &#125;    &#125;        <span class="hljs-comment">//pivot和指针重合点交换，大概是中点的位置</span>    <span class="hljs-keyword">int</span> p = arr[left];    arr[left] = arr[start];    arr[start] = p;    <span class="hljs-keyword">return</span> left;&#125;</code></pre><ul><li>可以用“栈”重写非递归形式的快速排序：</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span>&#123;    Stack&lt;Map&lt;String, Integer&gt;&gt; quickSortStack = <span class="hljs-keyword">new</span> Stack&lt;Map&lt;String, Integer&gt;&gt;();    Map&lt;String, Integer&gt; rootParam = <span class="hljs-keyword">new</span> HashMap&lt;String, Integer&gt;();    rootParam.put(<span class="hljs-string">&quot;start&quot;</span>, start);    rootParam.put(<span class="hljs-string">&quot;end&quot;</span>, end);    quickSortStack.push(rootParam);      <span class="hljs-keyword">while</span> (!quickSortStack.isEmpty()) &#123;        Map&lt;String, Integer&gt; param = quickSortStack.pop();        <span class="hljs-keyword">int</span> pivotIndex = partition(arr, param.get(<span class="hljs-string">&quot;start&quot;</span>), param.get(<span class="hljs-string">&quot;end&quot;</span>));        <span class="hljs-keyword">if</span>(param.get(<span class="hljs-string">&quot;start&quot;</span>) &lt; pivotIndex-<span class="hljs-number">1</span>)&#123;            Map&lt;String, Integer&gt; leftParam = <span class="hljs-keyword">new</span> HashMap&lt;String, Integer&gt;();            leftParam.put(<span class="hljs-string">&quot;start&quot;</span>, param.get(<span class="hljs-string">&quot;start&quot;</span>));            leftParam.put(<span class="hljs-string">&quot;end&quot;</span>, pivotIndex-<span class="hljs-number">1</span>);            quickSortStack.push(leftParam);        &#125;          <span class="hljs-keyword">if</span>(pivotIndex+<span class="hljs-number">1</span> &lt; param.get(<span class="hljs-string">&quot;end&quot;</span>)) &#123;            Map&lt;String, Integer&gt; rightParam = <span class="hljs-keyword">new</span> HashMap&lt;String, Integer&gt;();            rightParam.put(<span class="hljs-string">&quot;start&quot;</span>, pivotIndex+<span class="hljs-number">1</span>);            rightParam.put(<span class="hljs-string">&quot;end&quot;</span>, param.get(<span class="hljs-string">&quot;end&quot;</span>));            quickSortStack.push(rightParam);        &#125;    &#125;&#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span>&#123;    <span class="hljs-keyword">int</span> pivot = arr[start];    <span class="hljs-keyword">int</span> left = start;    <span class="hljs-keyword">int</span> right = end;      <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[right]&gt;pivot)&#123;            right--;        &#125;          <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot)&#123;            left++;        &#125;          <span class="hljs-keyword">if</span>(arr[left]&gt;arr[right])&#123;            <span class="hljs-keyword">int</span> p = arr[left];            arr[left] = arr[right];            arr[right] = p;        &#125;          System.out.println(pivot);    &#125;      <span class="hljs-keyword">int</span> p = arr[left];    arr[left] = arr[start];    arr[start] = p;      <span class="hljs-keyword">return</span> left;&#125;</code></pre></li></ul><h2 id="计算机组织与结构"><a href="#计算机组织与结构" class="headerlink" title="计算机组织与结构"></a>计算机组织与结构</h2><h3 id="1-Introduction-前瞻"><a href="#1-Introduction-前瞻" class="headerlink" title="1. Introduction 前瞻"></a>1. Introduction 前瞻</h3><h4 id="1-1-结构与组织-Architecture-amp-Organization"><a href="#1-1-结构与组织-Architecture-amp-Organization" class="headerlink" title="1.1. 结构与组织 Architecture &amp; Organization"></a>1.1. 结构与组织 Architecture &amp; Organization</h4><h5 id="1-1-1-Architecture-结构"><a href="#1-1-1-Architecture-结构" class="headerlink" title="1.1.1. Architecture 结构"></a>1.1.1. Architecture 结构</h5><ul><li>对程序员可见（visible to programmer）；</li><li>对程序的逻辑加载有直接影响；</li></ul><h5 id="1-1-2-Organization-组织"><a href="#1-1-2-Organization-组织" class="headerlink" title="1.1.2 Organization 组织"></a>1.1.2 Organization 组织</h5><ul><li>对程序员不可见（encapuslated to programmer）；</li><li>操作单元和内部链接；</li></ul><h4 id="1-2-冯诺依曼架构"><a href="#1-2-冯诺依曼架构" class="headerlink" title="1.2. 冯诺依曼架构"></a>1.2. 冯诺依曼架构</h4><h5 id="1-2-1-组成部分"><a href="#1-2-1-组成部分" class="headerlink" title="1.2.1. 组成部分"></a>1.2.1. 组成部分</h5><ul><li>存储器：地址和存储的内容；</li><li>处理单元：执行信息的实际处理；</li><li>控制单元：指挥信息的处理；</li><li>输入设备：将信息送入计算机中；</li><li>输出设备：将处理结果以某种形式显示在计算机外；</li><li><img src="冯诺依曼.png" alt="冯诺依曼架构"></li></ul><h4 id="1-3-摩尔定律"><a href="#1-3-摩尔定律" class="headerlink" title="1.3. 摩尔定律"></a>1.3. 摩尔定律</h4><p>单个芯片上的晶体管数量每过18个月就会翻一倍。</p><p><img src="数据流向.png" alt="数据流向图"></p><h4 id="1-4-CPU表现（CPU-Performance）"><a href="#1-4-CPU表现（CPU-Performance）" class="headerlink" title="1.4. CPU表现（CPU Performance）"></a>1.4. CPU表现（CPU Performance）</h4><h5 id="1-3-1-系统时钟"><a href="#1-3-1-系统时钟" class="headerlink" title="1.3.1 系统时钟"></a>1.3.1 系统时钟</h5><ul><li>时钟频率（Clock rate）：计算机在进行基本操作时，一秒内的时钟周期频数。</li><li>时钟周期（Clock cycle）：CPU的一次电磁脉冲；</li><li>周期时间（Cycle time）：脉冲之间的时间；</li></ul><h5 id="1-3-2-指令加载"><a href="#1-3-2-指令加载" class="headerlink" title="1.3.2 指令加载"></a>1.3.2 指令加载</h5><ul><li><p>CPI（Cycles Per Instruction）：一条指令所经历的时钟周期数；</p></li><li><p>总CPI的计算公式：</p><script type="math/tex; mode=display">CPI = \frac{\sum_{i=1}^{n}(CPI_i×I_i)}{I_C}, I_C=\sum_{i-1}^{n}I_i</script></li><li><p>处理时间</p><script type="math/tex; mode=display">T=I_C×CPI×t</script><script type="math/tex; mode=display">T=I_C×[p+(m×k)]×t</script><p>p：从处理器到存储器之间传输消耗的时钟周期；</p></li><li><p>Million Instructions Per Second (MIPS)</p><script type="math/tex; mode=display">MIPS=\frac{I_C}{T×10^6}=\frac{f}{CPI×10^6}</script></li><li><p>Million Floating Point Operations Per Second (MFLOPS)</p><script type="math/tex; mode=display">MFLOPS=\frac{N_{floating-point op}}{T×10^6}</script></li></ul><h5 id="1-3-3-评价标准（Benchmarks）"><a href="#1-3-3-评价标准（Benchmarks）" class="headerlink" title="1.3.3 评价标准（Benchmarks）"></a>1.3.3 评价标准（Benchmarks）</h5><ul><li><p>评测系统的表现；</p></li><li><p>平均结果：</p><ul><li>算术平均值：结果之和除以总数，得到平均的结果；</li></ul><script type="math/tex; mode=display">R_A = \frac{1}{m}\sum_{i=1}^{m}R_i</script><ul><li>调和平均值：一次除以结果得到单次结果的倒数，对其求和再去除总次数得到调和平均值；</li></ul><script type="math/tex; mode=display">R_H=\frac{m}{\sum_{i=1}^{m}\frac{1}{R_i}}</script></li></ul><h3 id="2-计算机的顶层视角"><a href="#2-计算机的顶层视角" class="headerlink" title="2. 计算机的顶层视角"></a>2. 计算机的顶层视角</h3><h4 id="2-1-计算机组成元素"><a href="#2-1-计算机组成元素" class="headerlink" title="2.1. 计算机组成元素"></a>2.1. 计算机组成元素</h4><ul><li>数据和指令存储在一个可读可写存储器；</li><li>存储器可寻址；</li><li>指令的加载按一定顺序进行；</li></ul><h4 id="2-1-1-存储器"><a href="#2-1-1-存储器" class="headerlink" title="2.1.1. 存储器"></a>2.1.1. 存储器</h4><ul><li><img src="/img/内存墙.png" alt=""></li><li>Memory Wall：数据从主存到CPU之间的传输速度的发展速度难以跟得上CPU的发展速度。</li><li>解决方案：在主存和CPU之间添加一个cache来减少主存的高频访问和数据传送率；提高一次获取的信息量；</li><li><img src="/img/存储器.png" alt=""></li></ul><h5 id="2-1-1-1-约束条件"><a href="#2-1-1-1-约束条件" class="headerlink" title="2.1.1.1. 约束条件"></a>2.1.1.1. 约束条件</h5><ul><li>容量：越大越好；</li><li>速度：跟得上处理器；</li><li>成本：相比其他组件可以接受；</li></ul><h5 id="2-1-1-2-约束条件之间的关系"><a href="#2-1-1-2-约束条件之间的关系" class="headerlink" title="2.1.1.2. 约束条件之间的关系"></a>2.1.1.2. 约束条件之间的关系</h5><ul><li>访问时间越短，单位比特的成本越高；</li></ul><h5 id="2-1-1-3-解决措施"><a href="#2-1-1-3-解决措施" class="headerlink" title="2.1.1.3. 解决措施"></a>2.1.1.3. 解决措施</h5><ul><li>存储器层次结构（金字塔）；</li><li><img src="/img/存储器层次结构.png" alt=""></li></ul><h4 id="2-1-2-I-O"><a href="#2-1-2-I-O" class="headerlink" title="2.1.2. I/O"></a>2.1.2. I/O</h4><ul><li>在存储器、CPU和外部资源之间交换数据的模块；</li></ul><h5 id="2-1-2-1-Problem"><a href="#2-1-2-1-Problem" class="headerlink" title="2.1.2.1. Problem"></a>2.1.2.1. Problem</h5><ul><li>I/O 表现不能够跟得上 CPU 速度的增长；</li><li>解决方案：缓冲区；</li></ul><h4 id="2-1-3-CPU"><a href="#2-1-3-CPU" class="headerlink" title="2.1.3. CPU"></a>2.1.3. CPU</h4><h5 id="2-1-3-1-Problem"><a href="#2-1-3-1-Problem" class="headerlink" title="2.1.3.1. Problem"></a>2.1.3.1. Problem</h5><ul><li>CPU 在等待 I/O 设备时需要等待；</li><li>解决方案：<ul><li>中断：一种被其他模块打断并可能影响正常处理顺序时的机制；</li><li><img src="/img/中断机制.png" alt=""></li></ul></li><li>中断检测</li><li><img src="/img/中断处理.png" alt=""></li></ul><h5 id="2-1-3-2-多重中断（分优先级嵌套中断）"><a href="#2-1-3-2-多重中断（分优先级嵌套中断）" class="headerlink" title="2.1.3.2. 多重中断（分优先级嵌套中断）"></a>2.1.3.2. 多重中断（分优先级嵌套中断）</h5><ul><li><img src="/img/多中断.png" alt=""></li><li>还有一种执行完一个中断再执行下一个的中断；</li></ul><h5 id="2-1-3-3-Theoretical-maximum-performance"><a href="#2-1-3-3-Theoretical-maximum-performance" class="headerlink" title="2.1.3.3. Theoretical maximum performance"></a>2.1.3.3. Theoretical maximum performance</h5><p><img src="/img/处理差距.png" alt=""></p><ul><li>随着技术的发展，出现了流水线、高速缓存、多核多线程等等使得计算机性能表现突飞猛进；</li><li>时钟频率也在不断上涨，但是上涨到了一定数值就停滞了。如果时钟频率过高，单条指令的处理时间会缩短，处理能力会下降。</li></ul><h4 id="2-1-4-总线-Bus"><a href="#2-1-4-总线-Bus" class="headerlink" title="2.1.4. 总线 Bus"></a>2.1.4. 总线 Bus</h4><ul><li>连接多个设备的通路——总线；</li><li><img src="/img/总线.png" alt=""></li></ul><h5 id="2-1-4-1-数据传输类型"><a href="#2-1-4-1-数据传输类型" class="headerlink" title="2.1.4.1. 数据传输类型"></a>2.1.4.1. 数据传输类型</h5><ul><li>数据线：在系统模块之间传输数据；</li><li>地址线：指定<em>数据线上和I/O端口上</em>的数据的<strong>来源或者目的地</strong>的地址；</li><li>控制线：控制【访问】、【数据的使用】和【地址线的使用】；</li><li>数据线和地址线上的内容可以复用；控制线上的内容不能复用；</li><li><img src="/img/三种线.png" alt=""></li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="0-C-基础"><a href="#0-C-基础" class="headerlink" title="0. C++基础"></a>0. C++基础</h3><ul><li>系统开发的一种方法是把类的声明放在 header 文件中，成员函数的实现分开放在代码文件中，在函数的实现代码中通过<strong>作用域设定命令“::”</strong>，将该函数归属到某一类。</li><li>struct 的默认访问级别是public，而 class 中的默认访问级别是 private。除此之外，struct 与 class 是等价的。</li></ul><h3 id="1-算法"><a href="#1-算法" class="headerlink" title="1. 算法"></a>1. 算法</h3><h4 id="1-1-算法定义"><a href="#1-1-算法定义" class="headerlink" title="1.1. 算法定义"></a>1.1. 算法定义</h4><ul><li><strong>有输入</strong></li><li><strong>有输出</strong></li><li><strong>确定性</strong></li><li><strong>有穷性</strong></li><li><strong>能行性</strong></li></ul><h4 id="1-2-算法的性能标准"><a href="#1-2-算法的性能标准" class="headerlink" title="1.2. 算法的性能标准"></a>1.2. 算法的性能标准</h4><ul><li>正确性</li><li>可使用性</li><li>可读性</li><li>效率</li><li>健壮性</li><li>简单性</li></ul>]]></content>
    
    
    <categories>
      
      <category>WeeklyReview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WeeklyReview</tag>
      
      <tag>插入排序</tag>
      
      <tag>尾递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CoreJava-6</title>
    <link href="/2020/05/03/CoreJava-6/"/>
    <url>/2020/05/03/CoreJava-6/</url>
    
    <content type="html"><![CDATA[<h3 id="Chapter-6-接口、lambda表达式和内部类"><a href="#Chapter-6-接口、lambda表达式和内部类" class="headerlink" title="Chapter 6 接口、lambda表达式和内部类"></a>Chapter 6 接口、lambda表达式和内部类</h3><ol><li>接口是对类的一组需求描述。<ul><li>接口不能含有实例域。</li><li>实现一个接口的步骤：①将类声明为实现给定的接口。②对接口中的所有方法进行定义。</li><li>可以利用泛型为接口提供一个类型参数。</li></ul></li><li>接口的特性<ul><li>接口可以被拓展。</li><li>接口中可以包含常量。</li><li>接口中的域将被自动设为public static final。</li><li>每个类可以拥有多个接口。</li></ul></li><li><strong>一个类只能继承一个类，却可以有多个接口。</strong></li><li>默认方法，可以为接口方法提供一个默认实现。必须用default修饰符标记这样一个方法。</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(T other)</span></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;&#125;</code></pre><ol><li><strong>解决默认方法冲突</strong>。如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法。<ol><li>超类优先。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。</li><li>接口冲突。如果超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型相同的方法，必须覆盖这个方法来解决冲突。</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>Core Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Core Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CoreJava-5</title>
    <link href="/2020/04/26/CoreJava-5/"/>
    <url>/2020/04/26/CoreJava-5/</url>
    
    <content type="html"><![CDATA[<h3 id="Chapter-5-继承"><a href="#Chapter-5-继承" class="headerlink" title="Chapter 5 继承"></a>Chapter 5 继承</h3><ol><li><p>定义子类</p><ul><li>关键字extends表明正在构造的新类派生于一个已存在的类。已存在的类称为<strong>超类、基类、父类；</strong>新类称为<strong>子类、派生类或孩子类。</strong>子类的功能比超类更加丰富。</li><li>通过扩展超类定义子类的时候，仅需要指出子类与超类的不同之处。</li></ul></li><li><p>覆盖方法（override）</p><ul><li>Manager类的getSalary方法不能够直接地访问超类的私有域。只有Employee类的方法才能够访问私有部分。</li><li>super不是一个对象的引用，他只是一个指示编译器调用超类方法的指示器。<pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getSalary</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//double baseSalary = getSalary();这句也不可以，因为getSalary会循环调用；</span>    <span class="hljs-keyword">double</span> baseSalary = <span class="hljs-keyword">super</span>.gerSalary();    <span class="hljs-keyword">return</span> baseSalary + bonus;&#125;</code></pre></li></ul></li><li><p>子类构造器</p><ul><li>语句super(n, s, year, month, day)是“调用超类Employee中含有n、s、year、month、day参数的构造器”的简写形式。</li><li>Manager类不能访问Employee的私有域，所以必须利用Employee类的构造器对这部分私有域进行初始化。通过super实现对超类构造器的调用。<strong>使用super调用构造器的语句必须是子类构造器的第一条语句。</strong></li><li>没有使用super就会自动调用默认（即无参数）构造器。<pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Manager</span><span class="hljs-params">(String name, <span class="hljs-keyword">double</span> salary, <span class="hljs-keyword">int</span> year, <span class="hljs-keyword">int</span> month, <span class="hljs-keyword">int</span> day)</span></span>&#123;    <span class="hljs-keyword">super</span>(name, salary, year, month, day);    bonus = <span class="hljs-number">0</span>;&#125;</code></pre></li></ul></li><li><p>继承层次，继承并不限于一个层次。</p><ul><li>由一个公共超类派生出来的所有类的集合被称为<em>继承层次</em>。</li><li>在继承层次中，从某个特定的类到其祖先的路径被称为该类的<em>继承链</em>。</li></ul></li><li><p>多态</p><ul><li>“is-a”规则的另一种表述法是置换法则。它表明程序中出现超类的任何地方都可以用子类对象置换。</li><li>在Java中，子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换。</li></ul></li></ol><pre><code class="hljs Java">Manager[] manager = <span class="hljs-keyword">new</span> Manager[<span class="hljs-number">10</span>];Employee[] staff = managers;<span class="hljs-comment">//managers和staff引用的是同一个数组。</span></code></pre><ol><li><p><strong><em>理解方法调用</em></strong>，下面假设要调用x.f(args),隐式参数声明为一个类C的对象。</p><ul><li>编译器查看对象的声明类型和方法名。如果存在多个名字为f但参数类型不一样的方法，编译器会意义列举所有C类中名为f的方法和其超类中访问属性为public且名为f的方法（超类的私有方法不可访问）。</li><li>接下来，编译器将查看调用方法时提供的参数类型。如果在所有名为f的方法中存在一个与提供参数类型完全匹配，就选择这个方法。这个过程叫“<strong>重载解析</strong>”。允许类型转换。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报一个错误。</li><li>如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法，我们将这种方法称为<strong>静态绑定</strong>。与此对应的是，调用的方法<strong>依赖于隐式参数的实际类型</strong>，并且在运行时时间<strong>动态绑定</strong>。</li><li>当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个方法。<ul><li>假设x的实际类型是D，它是C类的子类。如果D类定义了方法f(String)，就直接调用它；否则，将在D类的超类中寻找f(String)，以此类推。</li></ul></li><li>方法表：列出了所有方法的签名和实际调用的方法。如果调用super.f(param)，编译器将对隐式参数超类的方法表进行搜索。</li><li>调用 e.getSalary() 的解析过程为：<ul><li>首先，虚拟机提取e的实际类型的方法表。</li><li>接下来，虚拟机搜索定义getSalary签名的类。此时，虚拟机已经知道应该调用哪个方法。</li><li>最后，虚拟机调用方法。</li></ul></li><li>动态绑定有一个重要的特性：无需对现存的代码进行修改，就可以对程序进行扩展。</li><li>在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别是，如果超类方法是public，子类方法一定要声明为public。</li></ul></li><li><p>阻止继承：final类和方法</p><ul><li>不允许扩展的类被称为final类。</li><li>声明格式：public final class Executive extends Manager{ … }</li><li>类中的特定方法也可以被声明为final。如果这样做，子类就不能覆盖这个方法，final类中所有的方法自动地成为final方法。</li><li>将方法或类声明为final主要目的是：确保它们不会在子类中改变语意。</li><li>如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理，这个过程被称为<em>内联</em>。如果子类中有覆盖这个方法，优化器将取消对覆盖方法的内联。</li></ul></li><li><p>强制类型转换，仅需要用一对圆括号将目标类名括起来，并放置在需要转换的对象引用之前就可以了。</p><ul><li>进行类型转换的唯一原因是：在暂时忽视对象的实际类型之后，使用对象的全部功能。</li><li>将一个子类的引用赋给一个超类变量，编译器是允许的。但将一个超类的引用赋给一个子类变量，必须进行类型转换，这样才能够通过运行时的检查。<ul><li><strong>在进行类型转换之前，先查看一下是否能够成功地转换。</strong></li><li><strong>只能在继承层次内进行类型转换</strong></li><li><strong>在将超类转换成子类之前，应该使用instanceof进行检查。</strong></li></ul></li><li>实际上，通过类型转换调整对象的类型并不是一种好的做法。因为多态性的动态绑定机制能够自动地找到对应的方法。在一般情况下，应该尽量少用类型转换和 instanceof 运算符。</li></ul></li></ol><pre><code class="hljs Java">Manager boss = <span class="hljs-keyword">new</span> Manager(...);staff[<span class="hljs-number">0</span>] = boss;staff[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Employee(...);staff[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> Employee(...);Manager boss = (Manager) staff[<span class="hljs-number">0</span>]; <span class="hljs-comment">//Allowed</span>Manager boss = (Manager) staff[<span class="hljs-number">1</span>]; <span class="hljs-comment">//Error</span><span class="hljs-keyword">if</span> (staff[<span class="hljs-number">1</span>] <span class="hljs-keyword">instanceof</span> Manager)&#123;    boss = (Manager) staff[<span class="hljs-number">1</span>];&#125; <span class="hljs-comment">//check the instance before</span></code></pre><ol><li>抽象类，从某种角度按，<em>祖先类</em>更加通用，人们只将它作为派生其他类的基类，而不作为想使用的特定的实例类。<ul><li>为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的。</li><li>许多程序员认为，在抽象类中不能包含具体方法。建议尽量通用的域和方法（不管是否是抽象的）放在超类（不管是不是抽象类）中。</li><li>扩展抽象类可以有两种选择。<ul><li>一种是在抽象类中定义部分抽象类或不定义抽象类方法，这样就必须将子类也标记为抽象类。</li><li>另一种是定义全部的抽象方法，这样一来子类就不是抽象的了。</li></ul></li><li>类即使不含抽象方法，也可以将类声明为抽象类。</li><li>抽象类不能被实例化。也就是说，如果将一个类声明为abstract，就不能创建这个类的对象。</li><li>可以定义一个抽象类的对象变量。但是它只能引用非抽象子类的实例。</li></ul></li></ol><pre><code class="hljs Java">Person p = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Vince Vu&quot;</span>, <span class="hljs-string">&quot;Economics&quot;</span>);</code></pre><ol><li>受访问保护<ul><li>子类也不能访问超类的私有域。</li><li>例如，如果超类Employee中的hireDay声明为protected，而不是私有的，Manager中的方法就可以直接访问它。不过，Manager类中的方法只能够访问Manager对象中的hireDay域，而不能访问其他Employee对象中的这个域。</li></ul></li></ol><div class="table-container"><table><thead><tr><th>修饰词</th><th>本类</th><th>同一个包的类</th><th>继承类</th><th>其他类</th></tr></thead><tbody><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr><tr><td>默认</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table></div><ol><li><p>Object类，它是Java中所有类的始祖，在Java中每个类都是由它扩展而来的。在Java中，只有基本类型不是对象。</p><ul><li>equals方法，用来检测一个对象是否等于另外一个对象。判断两个对象是否具有相同的引用（内容）。<pre><code class="hljs Java"><span class="hljs-comment">//重写equals</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object otherObject)</span></span>&#123;        <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">super</span>.equals(otherObject)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-comment">//super.equals checked that this and otherObject belong to the same class</span>        Manager other = (Manager) otherObject;        <span class="hljs-keyword">return</span> bonus == other.bonus;    &#125;&#125;</code></pre></li></ul></li><li><p>泛型数组列表ArrayList</p><ul><li>ArrayList  是一个采用类型参数的泛型类。为了指定数组列表保存的元素对象类型，需要用一对尖括号将类名括起来加在后面。</li><li>add方法可以将元素添加到数组列表中。</li><li>ensureCapacity(int num)方法，分配一个包含num个对象的内部数组。</li><li>.size()方法类似于length。</li><li>trimToSize() 将数组列表的存储容量削减到当前尺寸。</li><li>.set(i, harry)将第i个元素设置为harry。</li><li>.get()同理。</li><li>.toArray(int[] a)将其拷贝到一个数组中。</li><li>.remove(n)</li><li>将原始ArrayList赋值给一个类型化的ArrayList会得到一个警告。而一个类型化的数组传递给一个普通方法不会出现警告，并且不需要任何的类型转换。</li></ul></li><li>对象包装器与自动装箱（wrapper）<ul><li>自动装箱：list.add(3) 将自动转换成 list.add(Integer.ValueOf(3))，同样的将Integer对象赋值给一个int值的时候，会自动拆箱。</li><li>对象之间的比较要使用equals方法。</li></ul></li><li>枚举类</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Size</span></span>&#123;    SMALL(<span class="hljs-string">&quot;S&quot;</span>), MEDIUM(<span class="hljs-string">&quot;M&quot;</span>),LARGE(<span class="hljs-string">&quot;L&quot;</span>),EXTRA_LARGE(<span class="hljs-string">&quot;XL&quot;</span>);        <span class="hljs-keyword">private</span> String abbreviation;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Size</span><span class="hljs-params">(String abbreviation)</span> </span>&#123;      <span class="hljs-keyword">this</span>.abbreviation = abbreviation;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAbbreviation</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> abbreviation;    &#125;&#125;</code></pre><ol><li>Class类<ul><li>getName方法，返回类的名more字。</li><li>一个Class对象实际上表示的是一个类型，而这个类型未必一定是一种类。例如，int不是类，但int.class是一个Class类型的对象。</li><li>Class类实际上是一个泛型类。例如，Employee.class的类型是Class<Employee>。</li><li>虚拟机为每个类型管理一个Class对象。因此，可以用==运算符实现两个类对象的比较操作。</li><li>newInstance方法乐意用来动态创建一个类的实例。它会调用默认的构造器初始化新创建的对象。如果没有默认的构造器，会抛出一个异常。</li></ul></li><li><p>利用反射分析类的能力。Field、Method和Constructor分别用于描述类的域、方法和构造器。都有getName方法返回项目的名称。</p><ul><li>Field类有一个getType方法，用来返回所描述域所属类型的Class对象。</li><li>Modifier类中isPublic、isPrivate或isFinal判断方法或构造器判断是否是public、private或final。</li><li>Class的getFields、getMethods和getConstructor方法将分别返回类提供的public域、方法和构造器数组。</li></ul></li><li><p><strong>继承的设计技巧</strong></p><ol><li>将公共操作和域放在超类</li><li>不要使用受保护的域</li><li>使用继承实现”is-a”关系</li><li>除非所有继承的方法都有意义，否则不要使用继承</li><li>在覆盖方法时，不要改变预期的行为</li><li>使用多态，而非类型信息</li><li>不要过多使用反射</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>Core Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Core Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CoreJava-4</title>
    <link href="/2020/04/26/CoreJava-4/"/>
    <url>/2020/04/26/CoreJava-4/</url>
    
    <content type="html"><![CDATA[<h3 id="Chapter-4-对象与类"><a href="#Chapter-4-对象与类" class="headerlink" title="Chapter 4 对象与类"></a>Chapter 4 对象与类</h3><ol><li><p>封装：将数据和行为组合在一个包中，并对对象的使用者隐藏了数据的实现方式，对象中的数据成为实例域。</p><ul><li>实现封装的关键在于<strong>绝对不能</strong>让类中的方法直接地访问其他类的实例域。</li><li>封装的优点<ul><li>可以改变内部实现，除了该类的方法之外，不会影响其他的代码。</li><li>更改器方法可以执行错误检查，然而直接赋值不会进行这些处理。</li></ul></li></ul></li><li><p>对象</p><ul><li>对象的三个特性：<ul><li>对象的行为：可以对对象施加哪些操作，或可以对对象施加哪些方法？</li><li>对象的状态：当施加那些方法时，对象如何响应？</li><li>对象标识：如何辨别具有相同行为与状态的不同对象？</li></ul></li><li>对象的行为是用可调用的方法定义的。</li><li>每个对象都有一个唯一的<strong>身份</strong></li></ul></li><li><p>识别类</p><ul><li>从设计类开始，然后再往每个类中添加方法。</li><li>“找动词与名词”</li></ul></li><li><p>类之间的关系</p><ul><li>“依赖（use-a）”：如果一个类的方法操纵另一个类的对象，我们就说一个类依赖另一个类。<strong>应该尽可能将互相依赖的类减到最少——让类之间的耦合度最小。</strong></li><li>“聚合（has-a）”：类A的对象包含类B的对象。</li><li>“继承（is-a）”</li></ul></li><li><p>对象与对象变量：要想使用对象，就必须首先构造对象，并制定其初始状态。然后，对对象应用方法。</p><ul><li>构造器： 特殊的方法，用来构造并初始化对象。</li><li>一个对象变量并没有实际包含一个对象，而仅仅应用一个对象。deadline = birthday两个Date类的对象。</li><li>如果将方法应用到null对象上就会引发运行错误。</li><li>访问器方法——只访问对象而不修改对象的方法；修改的叫做构造器方法。</li></ul></li><li><p>Emplyee类</p><ul><li>最简单的类定义形式为：<pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassName</span></span>&#123;    field;    constructor;    method;&#125;</code></pre></li></ul></li><li><p>构造器</p><ul><li>构造器与类同名。</li><li>每个类可以有一个以上的构造器。</li><li>构造器可以有0个、1个或多个参数。</li><li>构造器没有返回值。</li><li>构造器总是伴随着new操作一起调用。</li><li><strong>不要在构造器中定义与实例域重名的局部变量</strong></li></ul></li><li><p>隐式参数与显式参数</p><ul><li>隐式参数是出现在方法名前的对象；</li><li>显式参数是方法名后面括号里的数值；</li><li>在每一个方法中，关键字</li></ul></li><li><p>一个方法可以访问所属类的所有对象的私有数据。</p></li><li><p>如果一个方法与当前实现机制非常紧密或者需要一个特别的协议以及一个特别的调用次序，最好将这样的方法设置成private的。</p><ul><li>只要方法是私有的，就可以确保它不会被外部的其他类所调用，因此可以将其删去。</li></ul></li><li><p>final实例域</p><ul><li>可以将实例域定义为final，在构建对象的时候必须将它初始化。并且在后面的操作中不能将它修改。</li><li>final修饰符大多应用于基本（primitive）类型域，或不可变类型域（类中的每个方法都不会改变其对象。）</li></ul></li><li><p>静态域： 如果将域定义为static，每个类中只有一个这样的域。而每一个对象对于所有的实例域却都有自己的一份拷贝。</p><ul><li>这个类的所有实例域将共享一个“nextID”域；</li><li>它属于类，不属于一个独立的对象；</li></ul></li><li><p>静态方法：不能向对象实施操作的方法。</p><ul><li>没有隐式的参数。静态方法是没有this参数的方法。</li><li>静态方法可以访问自身类中的静态域；</li><li>建议使用类名来调用静态方法；</li><li>在以下两种情况使用静态方法：<ul><li>一个方法不需要访问对象状态，其所需参数都是通过显示参数提供（如Math.pow）;</li><li>一个方法只需要访问类的静态域（如Employee.getNextID）；</li></ul></li></ul></li><li><p>工厂方法构造对象；</p><ul><li>将类的创建单独放到一个类里进行，这个类就叫做工厂。</li><li>不利用构造器有两个原因：<ol><li>无法命名构造器。构造器的名字必须和类名相同。但是货币的实例需要不同的名字；</li><li>当使用构造器时，无法改变所构造的对象类型。<pre><code class="hljs Java">NumberFormat currencyFormatter = NumberFormat.gerCurrencyInstance();NumberFormat percentFormatter = NumberFormat.getpercentInstance();</code></pre></li></ol></li></ul></li><li><p>main方法：<strong>不需要使用对象调用静态方法</strong></p><ul><li>例子：不需要构造Math对象就可以直接调用Math.pow。</li><li>main方法也是一个静态方法。main方法不对任何对象进行操作。事实上在程序启动时没有任何一个对象。静态的main方法将执行并创建程序所需要的对象。</li></ul></li><li><p>Java总是采用按值调用。</p><ul><li><strong>Java对对象采用的不是引用调用，实际上，对象引用是按值传递的。</strong></li><li>一个方法不能修改一个基本数据类型的参数（按值传递参数）；</li><li>一个方法可以改变一个对象的参数的状态；</li><li><strong>一个方法不能让对象参数引用一个新的对象 </strong></li></ul></li><li><p>重载：有些类可以有多个构造器。如果多个方法有相同的名字、不同的参数，便产生了重载；编译器通过用各个方法给出的参数类型与特定方法调用所使用的值的类型进行匹配来挑选出相应的方法（重载解析）。</p><ul><li>Java允许重载任何方法，不只是构造器方法。完整描述一个方法需要指出方法名以及参数类型。这叫做方法的<strong>签名</strong>。</li></ul></li><li><p>默认域初始化：数值为0、布尔值为false、对象引用为null。</p></li><li><p>无参数构造器，如果在编写一个类时没有编写构造器，系统就会提供一个无参数构造器。这个构造器将所有实数域设置为默认值。</p></li><li><p>显示域初始化，通过重载类的构造器方法，可以采用多种形式设置类的实例域的初始状态。</p></li><li><p>参数变量用同样的名字将实例域屏蔽起来。可以用this.salary的方式访问实例域。回想一下，this指示隐式参数，也就是所构造的对象。</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String name, <span class="hljs-keyword">double</span> salary)</span></span>&#123;    <span class="hljs-keyword">this</span>.name = name;    <span class="hljs-keyword">this</span>.salary = salary;&#125;</code></pre></li><li><p>调用另一个构造器。如果构造器的第一个语句形如this(…)，这个构造器将调用同一个类的另一个构造器。公共的构造器代码部分只编写一次即可。</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(<span class="hljs-keyword">double</span> s)</span></span>&#123;    <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;Emplyee #&quot;</span> + nextID, s);    nextID++; &#125;</code></pre></li><li><p>初始化块。在一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会被执行。</p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> nextID;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary;        <span class="hljs-comment">//object initialization block</span>    &#123;        id = nextID;        nextID++;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String n, <span class="hljs-keyword">double</span> s)</span></span>&#123;        <span class="hljs-keyword">this</span>.name = n;        <span class="hljs-keyword">this</span>.salary = s;    &#125;&#125;</code></pre><p>在上述示例中，无论使用哪个构造器构造对象，id域都在对象初始化模块中被初始化。<strong>运行初始化模块，然后才运行构造器的主体部分。</strong></p></li><li><p>调用构造器的具体处理步骤：</p><ol><li>所有数据域被初始化为默认值。</li><li>按照在类声明中出现的次序，一次执行所有域初始化语句和初始化块。</li><li>如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。</li><li>执行这个构造器的主体。</li></ol></li><li><p>静态初始化块</p><ul><li><strong>初始化块只调用一次（类加载时），而普通初始化块可以调用多次，随着对象的创建而加载。</strong></li><li>一个类中可以有多个静态初始化块和多个普通初始化块；静态初始化块的执行要早于普通初始化块；同一个类型的初始化块的执行顺序取决于定义的先后顺序！</li><li>在一个类中如果有多个不同的初始化块，初始化属性，构造器，执行顺序是：静态初始化块|静态属性初始化 &gt; 普通初始化块|普通属性初始化 &gt; 构造器</li></ul></li><li><p>对象析构与finalize方法</p><ul><li>Java自动回收垃圾，不支持析构器。</li><li>可以为任何一个类添加finalize方法。finalize方法在垃圾回收器清除对象之前调用。在实际应用中，不要依赖于使用finalize方法回收任何短缺的资源，这是因为很难知道这个方法什么时候才能够调用。</li></ul></li><li><p>包，Java允许使用包（package）将类组织起来。</p><ul><li>使用包的主要原因是确保类名的唯一性。</li><li>从编译器的角度来看，嵌套的包之间没有任何关系。例如，java.util包与java.util.jar包毫无关系。每一个都有独立的集合。</li></ul></li><li><p>静态导入</p><ul><li>在源文件顶部，添加一条import static java.lang.System.*;</li><li>可以更简洁比如Math.sqrt可以简写为sqrt</li></ul></li><li><p>将类放入包中，就必须将包的名字放在源文件的开头，包中定义类的代码之前。如果没有在源文件中放置package语句，这个源文件中的类就被放置在一个默认包中。</p></li><li><p>注释</p><ol><li>方法注释<ol><li>@param 变量描述</li><li>@return 描述</li><li>@throws 类描述</li></ol></li><li>通用注释<ol><li>@author 姓名</li><li>@version 版本</li><li>@since 引入特性的版本描述</li><li>@see 引用</li></ol></li><li>包注释单独在包中添加文档</li></ol></li><li><p>类设计技巧</p><ol><li>一定要保证数据私有，绝对不要破坏封装性。</li><li>一定要对数据初始化。</li><li>不要在类中使用过多的基本类型。</li><li>不是所有的域都需要独立的域访问器和域更改器。</li><li>将职责过多的类进行分解。</li><li>类名和方法名要能够体现它们的职责。</li><li>优先使用不可变的类。</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>Core Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Core Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CoreJava-3</title>
    <link href="/2020/04/26/CoreJava-3/"/>
    <url>/2020/04/26/CoreJava-3/</url>
    
    <content type="html"><![CDATA[<h3 id="Chapter-3-基本设计结构"><a href="#Chapter-3-基本设计结构" class="headerlink" title="Chapter 3 基本设计结构"></a>Chapter 3 基本设计结构</h3><ol><li><p>关键字<em>final</em>表示常量。关键字<em>final</em>表示这个变量只能被赋值一次。常量名全部使用大写。</p></li><li><p><em>static final</em>设置类常量。可在一个类的多个方法中使用。如果生命为public，即<em>public</em>，则其他类的方法也可以使用这个常量。</p></li><li><p><em>strictfp</em>关键字标记点方法必须使用严格的浮点计算来生成可再生的结果。</p></li><li><p>String 中的<em>substring</em>方法，s.substring(a, b)得到以a为index开头，到b为止但不包含b的字符串，长度为b-a。</p></li><li><p><em>join</em>方法，String.join(“/“, “S”, “M”, “L”, “XL”);得到的是字符串”S/M/L/XL”。</p></li><li><p>String类对象是不可变字符串。编译器可以让字符串共享。</p></li><li><p>检查字符串是否相等可以用.equals()方法。如果不区分大小写可以用equalsIgnoreCase方法。<em>一定不要使用==运算符来检测两个字符串是否相等。这只能确定两个字符串是否在同一个位置上</em></p></li><li><p>“”是空串，有长度有内容。null表示目前没有任何对象与该变量关联。</p></li><li><p>码点与代码单元</p></li></ol><ul><li>int[] codePoints = str.codePoints().toArray();将字符串转成一个数组。</li><li>String str = new String(codePoints, 0, codePoints.length);将码点数组转化成一个字符串。</li></ul><ol><li><p>构建字符串</p><pre><code class="hljs Java">StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();builder.append(ch);<span class="hljs-comment">// appends a single character</span>builder.append(str);<span class="hljs-comment">// appends a string</span>String completedString = builder.toString();</code></pre></li><li><p>控制台输入</p><pre><code class="hljs Java">Scanner in = <span class="hljs-keyword">new</span> Scanner(System.in);String name = in.nextLine();<span class="hljs-keyword">int</span> age = in.nextInt();</code></pre></li><li><p>文件出入与输出</p><pre><code class="hljs Java"><span class="hljs-comment">//input</span>Scanner in = <span class="hljs-keyword">new</span> Scanner(Paths.get(<span class="hljs-string">&quot;myfile.txt&quot;</span>), <span class="hljs-string">&quot;UTF-8&quot;</span>);<span class="hljs-comment">//output</span>PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(<span class="hljs-string">&quot;myfile.txt&quot;</span>), <span class="hljs-string">&quot;UTF-8&quot;</span>);</code></pre></li><li><p>Java SE 7 开始，switch中的case标签还可以是字符串字面量。</p></li><li><p>break或continue后接label, 可以在中断之后直接跳到label的位置继续执行。</p></li><li><p>大数值BigInteger实现大整数；BigDecimal实现大浮点数。</p><pre><code class="hljs Java">BigInteger a = BigInteger.valueOf(<span class="hljs-number">100</span>);<span class="hljs-comment">//将普通数值转换为大数值；</span>BigInteger c = a.add(b); <span class="hljs-comment">// c = a + b;</span>BigInteger d = c.multiply(b.add(BigInteger.valueOf(<span class="hljs-number">2</span>))); <span class="hljs-comment">// d = c * (b + 2)</span></code></pre></li><li><p>数组</p><pre><code class="hljs Java"><span class="hljs-keyword">int</span>[] a= <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100</span>];</code></pre></li></ol><ul><li>创建一个数组时，所有元素都初始化为0。boolean数组的元素会初始化为false。对象数组会初始化为null。<pre><code class="hljs Java"><span class="hljs-comment">//下面所有字符串都是null</span>String[] names = <span class="hljs-keyword">new</span> String[<span class="hljs-number">10</span>];<span class="hljs-comment">//下面所有字符串都是空串</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) names[i] = <span class="hljs-string">&quot;&quot;</span>;</code></pre></li><li>一旦创建了数组就不能改变它的大小。</li></ul><ol><li>for each 循环</li></ol><ul><li>for (variable : collection) statement<pre><code class="hljs Java">System.out.println(Arrays.toString(a));<span class="hljs-comment">//打印数组；</span></code></pre></li></ul><ol><li>数组拷贝<pre><code class="hljs Java"><span class="hljs-keyword">int</span>[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers, luckynumbers.length);</code></pre></li><li><p>Array.sort(a); 进行排序</p></li><li><p>不规则数组</p><pre><code class="hljs Java"><span class="hljs-keyword">int</span>[][] odds = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[MAX+<span class="hljs-number">1</span>][];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>; n &lt;= MAX; n+<span class="hljs-number">1</span>)    odds[n] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];<span class="hljs-comment">//以上生成的是一个三角形数组</span></code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>Core Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Core Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

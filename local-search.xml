<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Cache-Lab-COA</title>
    <link href="/2020/11/24/Cache-Lab-COA/"/>
    <url>/2020/11/24/Cache-Lab-COA/</url>
    
    <content type="html"><![CDATA[<h2 id="Cache-Lab"><a href="#Cache-Lab" class="headerlink" title="Cache Lab"></a>Cache Lab</h2><p><a href="https://github.com/wyh2023/COA2020/tree/main/Chapter2/CacheLab">代码的github地址</a></p><h4 id="前排吐槽"><a href="#前排吐槽" class="headerlink" title="前排吐槽"></a>前排吐槽</h4><p>这次的实验和以往有了比较大的不同。首先，从结构上看要复杂一些，有了不同的模块，更像是实现一个东西，而非过程式的实现得到特定输出的函数。当然，这也给测试代码带来了一些难度，同时增加了阅读框架代码的难度。同时，这也表明了计组这门课的考试难度不会简单，为即将到来的期末而担忧╮(╯▽╰)╭</p><h3 id="知识回顾"><a href="#知识回顾" class="headerlink" title="知识回顾"></a>知识回顾</h3><ul><li>Cache存在的目的是什么？<ul><li>处理器的处理速度远远超过了存储器提供信息的速度而产生了一个bar，Cache的作用就是在处理器与主存之间添加一个缓存，加快存取速度。</li><li>cache中保存的是主存中<strong>块</strong>的副本。</li></ul></li><li>Cache的工作原理是什么？<ul><li><img src="/img/COA/Cache.jpg" alt=""></li><li>CPU先向Cache索要数据（Check），如果找到则命中（Hit），如果不命中则在主存中寻找数据（Miss），将主存中的数据整块搬到Cache中，然后再从Cache中返回信息给CPU。</li><li>可这样理解，编程作业也是这样实现的：CPU只与Cache交互，从Cache当中Fetch信息，如果命中则返回信息（的位置），不命中则在主存中寻找信息并替换到Cache中。</li></ul></li><li>如何知道Cache是否命中？<ul><li>我们已知数据的地址，那么我们可以推知它在Cache的标志位（tags）是怎么样表示的。在组相联映射中，还要先推得组号，在对应的组中匹配标志。同时，我们还需要注意的是有效位（ValidBit），这一点在课上没有提及，如果有效位置为0，则Cache是不被使用的，因此，在FIFO下，判断Cache是否被使用除了判断时间戳（TimeStamp）还需要判断有效位是否是1。</li><li>因此，在标志位相匹配和有效位为1的情况下，Cache命中。</li></ul></li><li>时间局部性和空间局部性<ul><li>时间局部性：同一个数据在短时间内被使用多次；</li><li>空间局部性：临近的数据在短时间被被连续使用；</li></ul></li><li><img src="/img/COA/CacheCL.jpg" alt=""></li><li>在替换的过程中，搬运的<strong>是块而不是字</strong>。<ul><li><img src="/img/COA/CacheMove.jpg" alt=""></li></ul></li><li>Cache之所以需要更多的操作却还能节省时间：<ul><li>是因为它有较高的命中率；</li><li>Cache的存取时间远小于到主存的存取时间；</li></ul></li><li>Cache越大效果越好吗？<ul><li>增大Cache的大小可以提高命中率；</li><li>但是也增大了成本和Cache的存取时间；</li><li>不是，变好的幅度会越来越小。“局部性”，并不会牵扯到太大的范围，并且块越大块内寻找的成本就会越高。块太大了之后，带来的数据是局部性比较差的、比较老的数据。</li></ul></li><li>哪种映射方式更好？<ul><li><img src="/img/COA/Map.jpg" alt=""></li><li>组相联是直接映射和全相联的一个Trade Off。</li><li>当组相连的组大小为整个Cache时，映射模式本质上是全相联映射；当组大小为1时，本质上是直接映射；</li></ul></li><li>Cache系统的组成？<ul><li><img src="/img/COA/CacheSystem.jpg" alt=""></li></ul></li><li>替换算法都有什么？分别有怎样的特点和好处？<ul><li>LRU-最近最少用；</li><li>FIFO-先进先出；<ul><li>本次实验使用的主要算法：通过为Cache行添加上一个时间戳来标示CacheLine在Cache里面的存在时间，每次替换时间戳最大的那个。</li></ul></li><li>LFU-使用频率最低；</li><li>Random-随机；</li></ul></li><li>写策略的异同？<ul><li>直写法（Write Through）<ul><li>替换的时候同时写主存和Cache；</li><li>一改就要访问主存；</li><li>提高了cache和主存的一致性；</li></ul></li><li>回写法（Write Back）<ul><li>只修改Cache。只有当替换算法要驱逐这个更新过的块时，才把它写到第一层中；</li><li>需要一个脏位来表示这一个块是否被调整过；如果是1就写回去，如果是0就替换掉；</li><li>优点：减少对主存的操作到最小的程度；</li></ul></li></ul></li><li>CacheLine的行大小是不是越多越好？<ul><li>当行大小从很小变大的时候，命中率会相对提高——更多有用的信息会被搬到Cache中去；</li><li>但当行大小过大，命中率就会降低<ul><li>Cache中的行数会减少，从而导致更多的行替换；</li><li>添加进去的字距离需要的字比较远，以至于小概率在短期内会被用到；</li></ul></li></ul></li><li>多级Cache有什么好处？（亟待补充）</li></ul><hr><h3 id="实验概览"><a href="#实验概览" class="headerlink" title="实验概览"></a>实验概览</h3><h4 id="框架梳理"><a href="#框架梳理" class="headerlink" title="框架梳理"></a>框架梳理</h4><h4 id="Cache的数据结构"><a href="#Cache的数据结构" class="headerlink" title="Cache的数据结构"></a>Cache的数据结构</h4><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * Cache行，每行长度为(1+22+&#123;<span class="hljs-doctag">@link</span> Cache#LINE_SIZE_B&#125;)</span><span class="hljs-comment"> */</span><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CacheLine</span> </span>&#123;  <span class="hljs-comment">// 有效位，标记该条数据是否有效</span>  <span class="hljs-keyword">boolean</span> validBit = <span class="hljs-keyword">false</span>;  <span class="hljs-comment">// 脏位，标记该条数据是否被修改</span>  <span class="hljs-keyword">boolean</span> dirty = <span class="hljs-keyword">false</span>;  <span class="hljs-comment">// 用于LRU和FIFO算法，记录该条数据时间戳</span>  Long timeStamp = -<span class="hljs-number">1L</span>;  <span class="hljs-comment">// 标记，占位长度为()22位，有效长度取决于映射策略：</span>  <span class="hljs-comment">// 直接映射: 12 位</span>  <span class="hljs-comment">// 全关联映射: 22 位</span>  <span class="hljs-comment">// (2^n)-路组关联映射: 22-(10-n) 位</span>  <span class="hljs-comment">// 注意，tag在物理地址中用高位表示，如：直接映射(32位)=tag(12位)+行号(10位)+块内地址(10位)，</span>  <span class="hljs-comment">// 那么对于值为0b1111的tag应该表示为0000000011110000000000，其中前12位为有效长度，</span>  <span class="hljs-comment">// 因为测试平台的原因，我们无法使用4GB的内存，但是我们还是选择用32位地址线来寻址</span>  <span class="hljs-keyword">char</span>[] tag = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">22</span>];  <span class="hljs-comment">// 数据</span>  <span class="hljs-keyword">char</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[LINE_SIZE_B];  <span class="hljs-keyword">char</span>[] getData() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.data;  &#125;  <span class="hljs-keyword">char</span>[] getTag() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.tag;  &#125;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] tagN, <span class="hljs-keyword">char</span>[] input)</span></span>&#123;    validBit = <span class="hljs-keyword">true</span>;    timeStamp = <span class="hljs-number">0L</span>;    System.arraycopy(tagN, <span class="hljs-number">0</span>, tag, <span class="hljs-number">0</span>, tagN.length);    System.arraycopy(input, <span class="hljs-number">0</span>, data, <span class="hljs-number">0</span>, input.length);  &#125;</code></pre><p>以上删去了无用的数据结构，这里的成员变量都已经在注释中解释的很清楚，不做过多解读了。主要说一下<code>update</code>，这里的update的主要目的是启用一个新的Cache，重置了它的有效位、时间戳以及内容。</p><blockquote><p>故事要从$Cache$的读写开始说起。由于$Cache$需要进行分块读写，所以我们提供了一个<code>helper</code>函数，这个函数已经写好了，他做的事情就是分块读写，然后根据参数来判断究竟是读还是写。在<code>helper</code>中，我们调用了<code>fetch</code>函数，这个函数会检查$Cache$是否包含某一个特定的$block$，如果检查到了就会返回，没有检查到就会从内存中加载。因为我们只需要实现一种替换策略，所以这里你可以硬编码一个<code>FIFO</code>进去，对于映射策略来说，本质上只有一种映射策略。</p></blockquote><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">char</span>[] helper(String eip, <span class="hljs-keyword">int</span> len, <span class="hljs-keyword">char</span>[] writeData)&#123;  <span class="hljs-keyword">char</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[len];  Transformer t = <span class="hljs-keyword">new</span> Transformer();  <span class="hljs-keyword">int</span> addr =  Integer.parseInt(t.binaryToInt(<span class="hljs-string">&quot;0&quot;</span> + eip));  <span class="hljs-keyword">int</span> upperBound = addr + len;  <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span> (addr &lt; upperBound) &#123;    <span class="hljs-keyword">int</span> nextSegLen = LINE_SIZE_B - (addr % LINE_SIZE_B);    <span class="hljs-keyword">if</span> (addr + nextSegLen &gt;= upperBound) &#123;      <span class="hljs-comment">//为满足循环终止条件，补满nextSegLen</span>      nextSegLen = upperBound - addr;    &#125;    <span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span>(writeData == <span class="hljs-keyword">null</span>)&#123;      <span class="hljs-keyword">int</span> rowNO = fetch(t.intToBinary(String.valueOf(addr)), nextSegLen);      <span class="hljs-keyword">char</span>[] cache_data = cache.get(rowNO).getData();      <span class="hljs-keyword">while</span> (i &lt; nextSegLen) &#123;        data[index] = cache_data[addr % LINE_SIZE_B + i];        index++;        i++;      &#125;    &#125;    <span class="hljs-keyword">else</span>&#123;      <span class="hljs-keyword">int</span> rowNO = fetch(t.intToBinary(String.valueOf(addr)), nextSegLen);      <span class="hljs-keyword">char</span>[] input = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[LINE_SIZE_B];      Arrays.fill(input, <span class="hljs-string">&#x27;0&#x27;</span>);      <span class="hljs-keyword">while</span> (i &lt; nextSegLen) &#123;        input[addr % LINE_SIZE_B + i] = writeData[index];        index++;        i++;      &#125;      writeStrategy.write(rowNO, input);    &#125;    addr += nextSegLen;  &#125;  <span class="hljs-keyword">return</span> data;&#125;</code></pre><p><code>helper</code>用在<code>read</code>和<code>write</code>之中，减少了很大程度的重复代码；因为字符串操作的蛋疼性（手动熊猫擦汗），因此对<code>addr</code>需要一个神奇的操作。<code>upperBound</code>表示的是读写的终点。<code>nextSegLen</code>表示一行中还有多少剩余的位置。根据读写的数据量（即$len$的不同，很有可能会产生跨Cache行的读写，也很有可能产生不足一个Cache行的读写。</p><pre><code class="hljs java"><span class="hljs-keyword">if</span> (addr + nextSegLen &gt;= upperBound) &#123;  nextSegLen = upperBound - addr;&#125;</code></pre><p>的目的之一就是就是将<code>addr += nextSegLen</code>使得<code>addr</code>能达到循环终止的条件。至于<code>fetch</code>为什么有两个参数这里不是很明白……因为Cache中总是以块为操作单位的，这里的第二个参数<code>len</code>是做什么的呢(._.)</p><p>后面的代码都比较好理解，判断是否有内容需要写，从而决定是读还是写。如果是读的话，返回cache中的data。如果是写的话，通过写策略将Cache中写入内容。</p><p>以上是本次编程作业的一个主要逻辑单元。那么基于此开始总结本次的编程作业，首先是第一个我们参与到的函数——<code>fetch</code></p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">fetch</span><span class="hljs-params">(String sAddr, <span class="hljs-keyword">int</span> len)</span> </span>&#123;  <span class="hljs-comment">//TODO</span>  <span class="hljs-keyword">int</span> blockNO = getBlockNO(sAddr);  <span class="hljs-keyword">int</span> hit = mappingStrategy.map(blockNO);  <span class="hljs-keyword">if</span>(hit != -<span class="hljs-number">1</span>)&#123;    <span class="hljs-keyword">return</span> hit;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">return</span> mappingStrategy.writeCache(blockNO);  &#125;&#125;</code></pre><p>这是知识回顾中一个简单流程的实现。</p><p><img src="/img/COA/Cache.jpg" alt=""></p><p>框架代码中提供了一个处理前22位的函数，它非常的简单，就是把标志位+组号转化为整数类型。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getBlockNO</span><span class="hljs-params">(String addr)</span> </span>&#123;  Transformer t = <span class="hljs-keyword">new</span> Transformer();  <span class="hljs-keyword">return</span> Integer.parseInt(t.binaryToInt(<span class="hljs-string">&quot;0&quot;</span> + addr.substring(<span class="hljs-number">0</span>, <span class="hljs-number">22</span>)));&#125;</code></pre><p>首先提取了块地址的有关信息——标志和组号。然后通过映射关系找到对应的Cache行（可能会不命中）。如果命中的话（这表明标志位和有效位均符合要求），返回相应的行号，流程结束！如果不命中的话……就有点麻烦了( ´▽` )ﾉ。我们需要通过替换策略，到主存中把需要的块替换到Cache中。</p><p>基于逻辑的顺序，首先我们来看<strong>映射策略</strong>中的映射如何实现的：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">map</span><span class="hljs-params">(<span class="hljs-keyword">int</span> blockNO)</span> </span>&#123;  <span class="hljs-comment">//TODO</span>  <span class="hljs-keyword">int</span> setNO = blockNO % SETS;  <span class="hljs-keyword">int</span> start = setNO * setSize;  <span class="hljs-keyword">int</span> end = (setNO + <span class="hljs-number">1</span>)*setSize;  <span class="hljs-keyword">char</span>[] tag = getTag(blockNO);  <span class="hljs-keyword">return</span> replacementStrategy.isHit(start, end, tag);&#125;</code></pre><p><code>SETS</code>表明了组数，<code>setSize</code>表明了组大小（全文均表示此意）。<code>setNO</code>表示组号，<code>start</code>表示起始的行号，<code>end</code>表示终点行号+1。接着在Cache中查找我们要找的Cache行是否存在我们要找的内容。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">isHit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">char</span>[] addrTag)</span> </span>&#123;  <span class="hljs-comment">//TODO</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=start; i&lt;end; i++)&#123;    <span class="hljs-keyword">if</span> (Cache.getCache().isMatch(i, addrTag)) <span class="hljs-keyword">return</span> i;  &#125;  <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isMatch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> lineNO, <span class="hljs-keyword">char</span>[] tag)</span></span>&#123;  CacheLine cacheLine = <span class="hljs-keyword">this</span>.cache.get(lineNO);    <span class="hljs-keyword">if</span>(cacheLine == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;  <span class="hljs-keyword">if</span> (!cacheLine.validBit) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;  <span class="hljs-keyword">if</span> (!Arrays.equals(cacheLine.tag, tag)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;&#125;</code></pre><p><code>isMatch</code>提供了判断逻辑——即我们需要首先有<code>cacheLine</code>，其次有效位需要为<code>true</code>，最后需要标志位匹配；如果判断命中，我们返回相应的行号，如果判断不命中返回-1。</p><p>回到<code>fetch</code>，如果命中，返回行号。如果不命中，我们就需要从主存中搬来信息。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">writeCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> blockNO)</span> </span>&#123;    <span class="hljs-comment">//TODO</span>    <span class="hljs-keyword">int</span> setNO = blockNO % SETS;    <span class="hljs-keyword">int</span> start = setNO * setSize;    <span class="hljs-keyword">int</span> end = (setNO + <span class="hljs-number">1</span>)*setSize;    <span class="hljs-keyword">char</span>[] tag = getTag(blockNO);    <span class="hljs-keyword">char</span>[] memory =Memory.getMemory().read(t.intToBinary(String.valueOf(Cache.LINE_SIZE_B * blockNO)), Cache.LINE_SIZE_B);    <span class="hljs-keyword">return</span> replacementStrategy.Replace(start, end, tag, memory);&#125;</code></pre><p><code>Memory.getMemory().read(t.intToBinary(String.valueOf(Cache.LINE_SIZE_B * blockNO)), Cache.LINE_SIZE_B);</code>这么老长一串是从主存中读到的信息。</p><p>我的替换算法实现的比较复杂TAT，水平太低，并且肉眼可见的低效。不过还是先简单说说我自己的想法：为每个Cache行标记一个时间戳，没有被使用到的Cache行置为-1。一旦被使用到则时间戳变为0。在FIFO算法中，替换首先得组满了再进行替换，如果没满，则先使用空闲的。空闲的Cache行有两种，一种是没被使用过时间戳为<code>-1</code>，一种是有效位为<code>false</code>。</p><p>如果存在没被使用过的，则替换第一个没被使用过的<code>free CacheLine</code>。</p><p>如果满了，就在全部的CacheLine中寻找时间戳最大，在Cache中存在最久的那个，将其替换。</p><p>随后为组中全部非空Cache的时间戳增加1。</p><p>最后更新CacheLine。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">Replace</span><span class="hljs-params">(<span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end, <span class="hljs-keyword">char</span>[] addrTag, <span class="hljs-keyword">char</span>[] input)</span> </span>&#123;  <span class="hljs-comment">//TODO</span>  <span class="hljs-comment">//find free</span>  <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;  <span class="hljs-keyword">boolean</span> isFull = <span class="hljs-keyword">true</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=start; i&lt;end; i++)&#123;    <span class="hljs-keyword">if</span>(Cache.getCache().getTimeStamp(i) == -<span class="hljs-number">1L</span> || !Cache.getCache().getValid(i))&#123;      index = i;      isFull = <span class="hljs-keyword">false</span>;      <span class="hljs-keyword">break</span>;    &#125;  &#125;  <span class="hljs-comment">//Sort &amp; Find the Oldest.</span>  <span class="hljs-keyword">if</span>(isFull)&#123;    <span class="hljs-keyword">long</span> maxTime = Cache.getCache().getTimeStamp(start);    index = start;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=start; i&lt;end; i++)&#123;      <span class="hljs-keyword">if</span>(maxTime &lt; Cache.getCache().getTimeStamp(i))&#123;        maxTime = Cache.getCache().getTimeStamp(i);        index = i;      &#125;    &#125;  &#125;  <span class="hljs-comment">//inc the TimeStamp</span>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=start; i&lt;end; i++)&#123;    <span class="hljs-keyword">long</span> time = Cache.getCache().getTimeStamp(i);    <span class="hljs-keyword">if</span>(time &gt;= <span class="hljs-number">0L</span>)&#123;      Cache.getCache().incTimeStamp(i);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">break</span>;    &#125;  &#125;  <span class="hljs-comment">//inc the TimeStamp of the new CacheLine</span>  <span class="hljs-keyword">if</span>(Cache.getCache().getTimeStamp(index)==-<span class="hljs-number">1L</span>)&#123;    Cache.getCache().incTimeStamp(index);  &#125;  <span class="hljs-comment">//Write Back</span>  <span class="hljs-keyword">if</span>(Cache.getCache().getDirty(index))&#123;    writeStrategy.writeBack(index);    Cache.getCache().setDirty(index, <span class="hljs-keyword">false</span>);  &#125;  Cache.getCache().updateCacheLine(index, addrTag, input);  <span class="hljs-keyword">return</span> index;&#125;</code></pre><p>更新Cache内容的方法放在Cache中：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateCacheLine</span><span class="hljs-params">(<span class="hljs-keyword">int</span> row, <span class="hljs-keyword">char</span>[] tag, <span class="hljs-keyword">char</span>[] input)</span></span>&#123;  CacheLine cacheLine = cache.get(row);  <span class="hljs-keyword">assert</span> cacheLine != <span class="hljs-keyword">null</span>;  cacheLine.update(tag, input);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] tagN, <span class="hljs-keyword">char</span>[] input)</span></span>&#123;  validBit = <span class="hljs-keyword">true</span>;  timeStamp = <span class="hljs-number">0L</span>;  System.arraycopy(tagN, <span class="hljs-number">0</span>, tag, <span class="hljs-number">0</span>, tagN.length);  System.arraycopy(input, <span class="hljs-number">0</span>, data, <span class="hljs-number">0</span>, input.length);&#125;</code></pre><p><code>update</code>之前有所提到，<code>updateCacheLine</code>就是在此基础之上，找到对应的Cache行，算是多了一层的抽象。</p><p>至此，Cache不命中也处理完了。</p><p>修改到这里应该就可以通过关于“读”的全部用例了。</p><p>那么关于“写”呢？</p><p>我们在知识回顾中提到了，本次实验所使用的回写法，只在替换算法要驱逐这个块的时候写回主存。【读操作不进行写回，因此可能产生一致性的问题】</p><p>所以在Replace中已经出现过了写回的判断——在更新cache行之前。</p><p>对Cache的写我们还是要看回<code>helper</code>。我们是通过<code>WriteStrategy</code>对Cache进行写操作的。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rowNo, <span class="hljs-keyword">char</span>[] input)</span> </span>&#123;  <span class="hljs-comment">//TODO</span>  Cache.getCache().setDirty(rowNo, <span class="hljs-keyword">true</span>);  Cache.getCache().setData(rowNo, input);&#125;</code></pre><p>首先，我们要把修改的那行Cache的脏位置为<code>true</code>，提醒主存在写操作（$altered）的时候回写。然后修改Cache里的内容，<code>setData</code>等函数不多赘述了。</p><p>写回的操作是这样的，先调用Cache，找到对应的Cache行，通过自身信息推导出需要写回的内存的地址，写入信息。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeBack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rowNo)</span> </span>&#123;  <span class="hljs-comment">//TODO</span>  Cache cache = Cache.getCache();  String pAddr = mappingStrategy.getPAddr(rowNo);  Memory.getMemory().writeBackM(pAddr, cache.getData(rowNo));&#125;</code></pre><p>上面是写操作策略中的<code>WriteBack</code>，首先我们需要推出对应的物理地址<code>pAddr</code>。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPAddr</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rowNo)</span> </span>&#123;  <span class="hljs-comment">//TODO</span>  <span class="hljs-comment">//</span>  <span class="hljs-keyword">int</span> setNum = rowNo / setSize;  String setStr = <span class="hljs-keyword">new</span> Transformer().intToBinary(String.valueOf(setNum)).substring(<span class="hljs-number">32</span>-countSets(SETS));  <span class="hljs-keyword">char</span>[] tag = Cache.getCache().getTag(rowNo);  String tagStr = String.valueOf(tag).substring(<span class="hljs-number">0</span>, <span class="hljs-number">22</span>-countSets(SETS));  <span class="hljs-keyword">return</span> tagStr + setStr + <span class="hljs-string">&quot;0000000000&quot;</span>;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countSets</span><span class="hljs-params">(<span class="hljs-keyword">int</span> SETS)</span></span>&#123;  <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;  SETS &gt;&gt;= <span class="hljs-number">1</span>;  <span class="hljs-keyword">while</span>(SETS != <span class="hljs-number">0</span>)&#123;    ret++;    SETS &gt;&gt;= <span class="hljs-number">1</span>;  &#125;  <span class="hljs-keyword">return</span> ret;&#125;</code></pre><p>首先需要算出的是组数，这可以通过<code>rowNo / setSize</code>得到，比如组大小是4行，在第17行说明在第4组。（以0为起始）。然后算出Tag，它的长度是22-组数的长度。末尾补上十位0就是对应的物理地址。【为什么补上0就可以呢？因为Cache是按块操作的，以<code>&quot;0000000000&quot;</code>对齐的就是一块。】</p><p>主存的写操作也是有不少值得说的地方，除了判断是否有内容需要写回，将脏位恢复之外。还需要将重写的地方对应的Cache无效化。然后再更新数据。下面给出<code>invalid</code>但不做过多解释。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invalid</span><span class="hljs-params">(String sAddr, <span class="hljs-keyword">int</span> len)</span> </span>&#123;  <span class="hljs-keyword">int</span> from = getBlockNO(sAddr);  Transformer t = <span class="hljs-keyword">new</span> Transformer();  <span class="hljs-keyword">int</span> to = getBlockNO(t.intToBinary(String.valueOf(Integer.parseInt(t.binaryToInt(<span class="hljs-string">&quot;0&quot;</span> + sAddr)) + len - <span class="hljs-number">1</span>)));  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> blockNO=from; blockNO&lt;=to; blockNO++) &#123;    <span class="hljs-keyword">int</span> rowNO = mappingStrategy.map(blockNO);    <span class="hljs-keyword">if</span> (rowNO != -<span class="hljs-number">1</span>) &#123;      cache.get(rowNO).timeStamp = -<span class="hljs-number">1L</span>;      cache.get(rowNO).validBit = <span class="hljs-keyword">false</span>;    &#125;  &#125;&#125;</code></pre><p>到这里差不多也就结束了！不过目前没有去管彩蛋，因为要做的事情有点多，这次的$Review$写了两个多小时头皮发麻，不知道码了大概多少字。其实看下来，这一次并没有写很复杂的逻辑，无非是把老师上课讲的流程付诸于实践。只不过相比从前多了几个抽象层次，并且更难去测试，使得这次的编程作业看起来变难了……</p><p>希望有更高的作业质量的同时也希望可以更好的$Survive$过去( ´▽` )ﾉ！</p><h3 id="重振软院荣光，我辈义不容辞！"><a href="#重振软院荣光，我辈义不容辞！" class="headerlink" title="重振软院荣光，我辈义不容辞！"></a>重振软院荣光，我辈义不容辞！</h3>]]></content>
    
    
    
    <tags>
      
      <tag>COA</tag>
      
      <tag>Cache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>COA-RAID</title>
    <link href="/2020/11/19/COA-RAID/"/>
    <url>/2020/11/19/COA-RAID/</url>
    
    <content type="html"><![CDATA[<h2 id="COA-RAID"><a href="#COA-RAID" class="headerlink" title="COA-RAID"></a>COA-RAID</h2><h3 id="RAID（磁盘冗余阵列）"><a href="#RAID（磁盘冗余阵列）" class="headerlink" title="RAID（磁盘冗余阵列）"></a>RAID（磁盘冗余阵列）</h3><ul><li>一组物理磁盘，但是在使用的时候感觉像是一块磁盘，在操作系统下被视为一个单一的逻辑驱动器。</li><li>数据以<strong>带化（striping）</strong>的方式分布在一组物理磁盘上。</li><li>冗余磁盘容量用于存储奇偶校验信息，磁盘出错的情况下，有一定的恢复能力。【0、1级不支持】</li><li>多个磁头和机械臂移动机构同时操作达到更高的I/O和传输速度，但多个设备的使用增加了出错概率。</li><li><img src="/img/COA/RAIDLevel.jpg" alt=""></li></ul><h4 id="RAID-Level-0"><a href="#RAID-Level-0" class="headerlink" title="RAID Level 0"></a>RAID Level 0</h4><ul><li><img src="/img/COA/L0.jpg" alt=""></li><li>IO相应快：好多个I/O过来的话，可以减少等待时间；</li><li>IO数据量较大可以存在不同的空间里，可以提高写的速度。</li><li>缺点：只要有一个盘坏了，会影响许多数据的读取。</li></ul><h4 id="RAID-Level-1"><a href="#RAID-Level-1" class="headerlink" title="RAID Level 1"></a>RAID Level 1</h4><ul><li><img src="/img/COA/L1.jpg" alt=""></li><li>镜像：不同时坏的时候，总能取到数据。</li><li>可以加速读取，同时读一块盘上的不同内容。两个请求能够并行发出，减少I/O的排队时间。</li><li>一个读请求可以由包含请求数据的两个磁盘中的某一个提供服务，只要它的寻道时间+旋转延迟较小；</li><li>一个写请求需要更新两个对应的条带，但这可以并行完成。</li><li>缺点：价格高昂，需要支持两倍于逻辑磁盘的磁盘空间。</li><li>有大批的读请求时，RAID 1能实现高速的I/O速率，性能几乎可以达到RAID 0的两倍。如果有大批的写请求，性能则不比RAID 0好多少。</li></ul><h4 id="RAID-Level-2"><a href="#RAID-Level-2" class="headerlink" title="RAID Level 2"></a>RAID Level 2</h4><ul><li><img src="/img/COA/L2.jpg" alt=""></li><li>每一个磁盘都会参与每一次I/O的运算。非常高的数据传输率——<strong>条带非常的小</strong>；</li><li>使用了海明码——每一次读写的时候都会读数据进行矫验。</li><li>对于单个读操作，所有磁盘同时读取，请求的数据和相关的纠错码辈传送到阵列控制器。IO响应也可以更快。</li><li>对于单个写操作，所有数据盘和奇偶校验盘必须被访问以进行写操作。</li><li>缺点：成本高昂，冗余磁盘的数目与数据磁盘数目的对数成正比；</li></ul><h4 id="RAID-Level-3"><a href="#RAID-Level-3" class="headerlink" title="RAID Level 3"></a>RAID Level 3</h4><ul><li><img src="/img/COA/L3.jpg" alt=""></li><li>使用了奇偶校验，对所有数据盘上同一位置的一组独立位进行简单计算的奇偶校验位；</li><li>如果有一个盘坏了，可以帮它恢复出来；<ul><li>P(b) = b<sub>1</sub>⊕b<sub>2</sub>⊕b<sub>3</sub>⊕b<sub>4</sub></li><li>b<sub>2</sub>⊕P(b)⊕P(b) = b<sub>2</sub>⊕b<sub>1</sub>⊕b<sub>2</sub>⊕b<sub>3</sub>⊕b<sub>4</sub>⊕P(b)</li><li>b<sub>2</sub> = b<sub>1</sub>⊕b<sub>3</sub>⊕b<sub>4</sub>⊕P(b)</li><li>每个数据条带的内容都可以从阵列中剩余磁盘的相应条带中重新生成。适用于3～6级。</li></ul></li><li>性能：非常小的条带，非常高的数据传输率。任何I/O请求将包含所有数据盘的并行数据传送。</li><li>缺点：同一时间只能加载一个IO请求。</li></ul><h4 id="RAID-Level-4"><a href="#RAID-Level-4" class="headerlink" title="RAID Level 4"></a>RAID Level 4</h4><ul><li><img src="/img/COA/L4.jpg" alt=""></li><li>独立存取技术。每个磁盘成员的操作是独立的，因此各个I/O请求能够并行处理。</li><li>各个盘之间不要牵绊——条带变大。每个盘变得相对独立；</li><li>每一次写操作，阵列管理软件不仅要修改用户数据，饿而且要修改相应的校验位。</li><li><img src="/img/COA/L4C.jpg" alt=""></li><li>为了计算新的奇偶校验位，阵列管理软件必须读取旧的数据条带和奇偶校验条带，然后用新的数据和新计算出的奇偶校验位更新上述的两个条带。因此每个条带的写操作包括两次读操作和两次写操作。</li><li>当涉及所有磁盘的数据条带的较大I/O写操作时，只需要和新的数据位来进行简单的计算即可得奇偶校验位。因此，奇偶校验盘和数据磁盘并行更新，不再需要另外的读或写操作。</li><li>在任何情况下，每一次读写操作必须涉及奇偶校验盘，因此它成为一个瓶颈。</li></ul><h4 id="RAID-Level-5"><a href="#RAID-Level-5" class="headerlink" title="RAID Level 5"></a>RAID Level 5</h4><ul><li><img src="/img/COA/L5.jpg" alt=""></li><li>冗余的任务分配在不同的盘上，所有磁盘上都分布了奇偶校验条带。</li><li>并不是完全独立了，只是好一点。</li></ul><h4 id="RAID-Level-6"><a href="#RAID-Level-6" class="headerlink" title="RAID Level 6"></a>RAID Level 6</h4><ul><li><img src="/img/COA/L6.jpg" alt=""></li><li>RAID 6 方案进行两种不同的奇偶校验计算，并将校验码以分开的块存于不同的磁盘中。因此，用户数据需要$N$个磁盘的RAID 6阵列，由$N+2$个磁盘组成。</li><li>P和Q是两个不同的数据校验算法，其中一个是用于RAID 4和RAID 5中的异或运算，另一个是一种独立的数据校验算法。这样，即使包含用户数据的两个盘出现故障了，数据照样能重新生成。</li><li>优点：极高的数据可用性，只在平均修复时间间隔内3个磁盘都出了故障才会使数据丢失。</li><li>每次写都要影响两个奇偶块。</li></ul>]]></content>
    
    
    <categories>
      
      <category>WeeklyReview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WeeklyReview</tag>
      
      <tag>RAID</tag>
      
      <tag>COA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Floating-point-Arithmetic-Review-2</title>
    <link href="/2020/11/13/Floating-point-Arithmetic-Review-2/"/>
    <url>/2020/11/13/Floating-point-Arithmetic-Review-2/</url>
    
    <content type="html"><![CDATA[<h2 id="浮点数乘除法运算编程作业总结"><a href="#浮点数乘除法运算编程作业总结" class="headerlink" title="浮点数乘除法运算编程作业总结"></a>浮点数乘除法运算编程作业总结</h2><p>多有说的不清楚以及还想不太清楚的地方，希望多多包涵( ´▽` )ﾉ</p><h3 id="浮点数乘法"><a href="#浮点数乘法" class="headerlink" title="浮点数乘法"></a>浮点数乘法</h3><h4 id="1-特殊情况"><a href="#1-特殊情况" class="headerlink" title="1. 特殊情况"></a>1. 特殊情况</h4><p>任何数和NaN相乘以及0和无穷相乘得到的结果都是NaN。我们首先需要对此进行特判：</p><pre><code class="hljs java"><span class="hljs-comment">//如果两个乘数中有一个是NaN，返回NaN</span><span class="hljs-keyword">if</span>(Pattern.matches(a, IEEE754Float.NaN) || Pattern.matches(b, IEEE754Float.NaN))&#123;  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NaN&quot;</span>;&#125;String ansExp;String ansFrac;<span class="hljs-keyword">char</span> signA = a.charAt(<span class="hljs-number">0</span>);<span class="hljs-keyword">char</span> signB = b.charAt(<span class="hljs-number">0</span>);String ansSign = (signA == signB)? <span class="hljs-string">&quot;0&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>;<span class="hljs-comment">//这么写麻烦了很多，在除法中的处理看起来更清爽一些。</span><span class="hljs-comment">//如果两个乘数中有一个是0，那么当另一个数：</span><span class="hljs-comment">//1.为NaN时【貌似重复判断了】结果为NaN</span><span class="hljs-comment">//2.为无穷的时候结果为NaN</span><span class="hljs-comment">//3.其他情况返回0，注意0的符号是两个乘数的异或结果</span><span class="hljs-keyword">if</span>(a.equals(IEEE754Float.N_ZERO) || b.equals(IEEE754Float.N_ZERO)   || a.equals(IEEE754Float.P_ZERO) || b.equals(IEEE754Float.P_ZERO))&#123;  <span class="hljs-keyword">if</span>(Pattern.matches(a, IEEE754Float.NaN) || Pattern.matches(b, IEEE754Float.NaN))&#123;    <span class="hljs-keyword">return</span> IEEE754Float.NaN;  &#125;  <span class="hljs-keyword">if</span>(a.startsWith(<span class="hljs-string">&quot;11111111&quot;</span>, <span class="hljs-number">1</span>) || b.startsWith(<span class="hljs-string">&quot;11111111&quot;</span>, <span class="hljs-number">1</span>))&#123;    <span class="hljs-keyword">return</span> IEEE754Float.NaN;  &#125;  <span class="hljs-keyword">return</span> ansSign + <span class="hljs-string">&quot;0000000000000000000000000000000&quot;</span>;&#125;</code></pre><h4 id="2-处理参数"><a href="#2-处理参数" class="headerlink" title="2. 处理参数"></a>2. 处理参数</h4><p>上面还处理了结果会用到的符号。下面对两个乘数进行处理，并且补上规格化隐去的小数点之前的0或者1。使用了countA和countB来代表参与运算的小数部分。</p><pre><code class="hljs java">String expA = a.substring(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>);String expB = b.substring(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>);String bitA = (expA.equals(<span class="hljs-string">&quot;00000000&quot;</span>))? <span class="hljs-string">&quot;0&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>;String bitB = (expB.equals(<span class="hljs-string">&quot;00000000&quot;</span>))? <span class="hljs-string">&quot;0&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>;String fracA = a.substring(<span class="hljs-number">9</span>);String fracB = b.substring(<span class="hljs-number">9</span>);String countA = bitA + fracA + <span class="hljs-string">&quot;0000&quot;</span>; <span class="hljs-comment">//28</span>String countB = bitB + fracB + <span class="hljs-string">&quot;0000&quot;</span>;</code></pre><h4 id="3-CF以及特判阶码"><a href="#3-CF以及特判阶码" class="headerlink" title="3. CF以及特判阶码"></a>3. CF以及特判阶码</h4><p>这里比较有意思，要单独说一下有关CF位。</p><p>CF位表示的是进位，当无符号数加减法溢出的时候CF会被置为1。什么情况下加法会溢出呢？当n位的两个二进制数相加得到的和大于2<sup>n</sup>时，溢出，也就是最后一位计算的时候CF为1。加法的情况下比较好理解，那么减法呢？在我的实现中，减法是将减数取反加一来实现的。因此，原本需要借位的数相加之后的CF为0，不需要的为1。所以加法和减法的溢出与否和CF的关系是相反的。</p><p>在这里，因为阶码比它的真实值多了127，两个数相乘之和阶码相加，也就加上了两个127，因此我们需要减一个127。正常的两个数之和的范围是0～508。而得到一个可以表示的结果的范围应该是127～381。</p><p>怎么样表示上溢出和下溢出的数更方便呢？</p><p>我们使用CF位！</p><p>如果一开始的加法溢出了，说明得到的结果大于255。如果之后的减法需要借位，说明得到的结果小于等于382（这也说明了还有一种加完得到255的情况）。小于382的情况是合法的，以上的关系都是充要的。因此，当一开始的加法溢出且减法不需要借位的时候，阶码上溢！根据之前对于CF的讨论，<strong>当加法之后的CF为1且减法之后的CF为1时，溢出得到结果无穷。</strong></p><p>如果一开始的加法没有溢出，说明结果小于等于255。如果之后-127的减法需要借位，说明结果处于0～126或256～382。取并集结果：0～126，我们可以知道<strong>当CF在加法之后为0，减127之后也为0的时候，阶码下溢出。</strong></p><p>以下是具体的处理：</p><pre><code class="hljs java">String tmp = add(expA, expB);<span class="hljs-comment">//CF 判断有没有溢出；</span><span class="hljs-keyword">char</span> tmpCF = CF;ansExp = sub(<span class="hljs-string">&quot;01111111&quot;</span>, tmp);<span class="hljs-comment">//CF 判断有没有借位；</span><span class="hljs-keyword">if</span>((tmpCF==<span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; CF==<span class="hljs-string">&#x27;1&#x27;</span>) || ansExp.equals(<span class="hljs-string">&quot;11111111&quot;</span>))&#123; <span class="hljs-comment">//一开始溢出了但是没有借位，说明</span>  <span class="hljs-keyword">if</span>(signA==signB) <span class="hljs-keyword">return</span> IEEE754Float.P_INF;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> IEEE754Float.N_INF;&#125;<span class="hljs-keyword">if</span>(tmpCF==<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; CF==<span class="hljs-string">&#x27;0&#x27;</span>)&#123; <span class="hljs-comment">//一开始没有溢出，但是有借位</span>  <span class="hljs-keyword">if</span>(signA==signB) <span class="hljs-keyword">return</span> IEEE754Float.P_ZERO;  <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> IEEE754Float.N_ZERO;&#125;</code></pre><p>之后的一步就是小数部分相乘得到结果的fraction。并对结果进行规格化（规格化的过程不多赘述）。</p><pre><code class="hljs java">ansFrac = mulFrac(countA, countB).substring(<span class="hljs-number">1</span>, <span class="hljs-number">25</span>);<span class="hljs-comment">//Normalize</span><span class="hljs-keyword">while</span> (ansFrac.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; !ansExp.equals(<span class="hljs-string">&quot;00000000&quot;</span>))&#123;  ansFrac = ansFrac.substring(<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;0&quot;</span>;  ansExp = sub(<span class="hljs-string">&quot;00000001&quot;</span>, ansExp);&#125;ansFrac = ansFrac.substring(<span class="hljs-number">1</span>, <span class="hljs-number">24</span>);<span class="hljs-keyword">return</span> ansSign + ansExp + ansFrac;</code></pre><h4 id="4-尾数乘法"><a href="#4-尾数乘法" class="headerlink" title="4. 尾数乘法"></a>4. 尾数乘法</h4><p>在这里给出mulFrac的具体代码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">mulFrac</span> <span class="hljs-params">(String src, String dest)</span></span>&#123;  String Y = dest;  String product = <span class="hljs-string">&quot;0000000000000000000000000000&quot;</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">28</span>; i++)&#123;    <span class="hljs-keyword">if</span>(Y.charAt(<span class="hljs-number">27</span>) == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;      product = add(src, product);    &#125;    product = <span class="hljs-string">&quot;0&quot;</span> + product;    Y = product.charAt(<span class="hljs-number">28</span>) + Y.substring(<span class="hljs-number">0</span>, <span class="hljs-number">28</span>);    product = product.substring(<span class="hljs-number">0</span>, <span class="hljs-number">28</span>);  &#125;  <span class="hljs-keyword">return</span> product;&#125;</code></pre><p>参数均是28位（1位规格化隐藏+23位fraction+4位保护位）。这里使用了ppt上的算法，当Y最后一位为1的时候，将部分积的第一位置为1，然后右移；反之置为0，再左移。得到的结果应当为部分积（也是28位），在mul中会被切割整理。以上的操作都是竖式乘法的一种实现，可以用该思路辅助理解。</p><p>ppt截图：</p><p><img src="/img/COA/FloatMul.jpg" alt=""></p><h3 id="浮点数除法"><a href="#浮点数除法" class="headerlink" title="浮点数除法"></a>浮点数除法</h3><h4 id="1-判断特殊情况"><a href="#1-判断特殊情况" class="headerlink" title="1. 判断特殊情况"></a>1. 判断特殊情况</h4><p>当被除数为0且除数也为0的时候，结果为NaN。除此之外，当被除数为0的时候，结果也为0（注意判断符号）；当除数为0的时候抛出错误。</p><pre><code class="hljs java">String ansExp;String ansFrac;<span class="hljs-keyword">char</span> signA = a.charAt(<span class="hljs-number">0</span>);<span class="hljs-keyword">char</span> signB = b.charAt(<span class="hljs-number">0</span>);String ansSign = (signA == signB)? <span class="hljs-string">&quot;0&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>;<span class="hljs-keyword">if</span>(b.startsWith(<span class="hljs-string">&quot;0000000000000000000000000000000&quot;</span>, <span class="hljs-number">1</span>))&#123;  <span class="hljs-keyword">if</span>(a.equals(IEEE754Float.N_ZERO) || a.equals(IEEE754Float.P_ZERO))&#123;    <span class="hljs-keyword">return</span> IEEE754Float.NaN;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArithmeticException();  &#125;&#125;<span class="hljs-keyword">if</span>(a.startsWith(<span class="hljs-string">&quot;0000000000000000000000000000000&quot;</span>, <span class="hljs-number">1</span>))&#123;  <span class="hljs-keyword">return</span> ansSign + <span class="hljs-string">&quot;0000000000000000000000000000000&quot;</span>;&#125;</code></pre><h4 id="2-处理参数-1"><a href="#2-处理参数-1" class="headerlink" title="2. 处理参数"></a>2. 处理参数</h4><p>处理的操作和乘法一致</p><pre><code class="hljs java">String expA = a.substring(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>);String expB = b.substring(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>);String bitA = (expA.equals(<span class="hljs-string">&quot;00000000&quot;</span>))? <span class="hljs-string">&quot;0&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>;String bitB = (expB.equals(<span class="hljs-string">&quot;00000000&quot;</span>))? <span class="hljs-string">&quot;0&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>;String fracA = a.substring(<span class="hljs-number">9</span>);String fracB = b.substring(<span class="hljs-number">9</span>);String countA = bitA + fracA + <span class="hljs-string">&quot;0000&quot;</span>; <span class="hljs-comment">//28</span>String countB = bitB + fracB + <span class="hljs-string">&quot;0000&quot;</span>;String tmp = sub(expB, expA);</code></pre><h4 id="3-判断阶码的情况"><a href="#3-判断阶码的情况" class="headerlink" title="3. 判断阶码的情况"></a>3. 判断阶码的情况</h4><p>除法在阶码之间发生减法的时候，不会出现上溢出的情况。得到的结果范围是-254～254。如果得到了负数，则CF置为1。因为减法会将127抵消，因此得到的结果需要再加上一个127。<strong>这个时候阶码还是会有可能上溢的！</strong>但好像本次编程作业没有考虑这个情况，因此希望大家注意！</p><p>上溢出的情况是减法不借位，即第一次CF为1，加法进位，第二次的CF为1。得到的结果是无穷。</p><p>下溢出的情况是减法借位而加法不进位，即两次的CF均为0。得到的结果是0。</p><pre><code class="hljs java">String tmp = sub(expB, expA);<span class="hljs-comment">//CF 判断有没有溢出；</span><span class="hljs-keyword">char</span> tmpCF = CF;ansExp = add(<span class="hljs-string">&quot;01111111&quot;</span>, tmp);<span class="hljs-comment">//CF 判断有没有借位；</span><span class="hljs-keyword">if</span>(tmpCF == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; CF == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;  <span class="hljs-keyword">return</span> ansSign + <span class="hljs-string">&quot;0000000000000000000000000000000&quot;</span>;&#125;<span class="hljs-keyword">if</span>(tmpCF == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; CF == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;  <span class="hljs-keyword">return</span> ansSign + <span class="hljs-string">&quot;1111111100000000000000000000000&quot;</span>;&#125;</code></pre><h4 id="计算小数部分"><a href="#计算小数部分" class="headerlink" title="计算小数部分"></a>计算小数部分</h4><pre><code class="hljs java">ansFrac = divFrac(countB, countA).substring(<span class="hljs-number">0</span>, <span class="hljs-number">24</span>);<span class="hljs-comment">//Normalize</span><span class="hljs-keyword">while</span> (ansFrac.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; !ansExp.equals(<span class="hljs-string">&quot;00000000&quot;</span>))&#123;  ansFrac = ansFrac.substring(<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;0&quot;</span>;  ansExp = sub(<span class="hljs-string">&quot;00000001&quot;</span>, ansExp);&#125;ansFrac = ansFrac.substring(<span class="hljs-number">1</span>, <span class="hljs-number">24</span>);<span class="hljs-keyword">return</span> ansSign + ansExp + ansFrac;</code></pre><p>规格化不多赘述</p><p>重点是下面的小数部分除法。我们需要一个余数部分remainder，商quotient。<strong>对参数我们都在前面加上一位0。</strong></p><p>因为小数可能会出现无法除尽的情况。倘若只有28位，<strong>当remainder的最高位为1且不能减去除数的时候</strong>，最高位的1就会在左移之后消失，产生错误。因此这个最高位的1需要保留到下一次减法。现在的remainder是29位的，src，也就是除数，是28位的（第29位被我们手动置为0），所以当remainder的最高位为1的时候，remainder一定会大于src（除数），因此肯定可以使得减法进行。</p><p>这里首先减去除数，一旦减多了，就把除数加回来。怎么判断减多了？利用刚才仔细分析的CF。一旦CF为0，即减法需要借位，则说明减多了；一旦CF为1，说明“enough“，减对了。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">divFrac</span> <span class="hljs-params">(String src, String dest)</span></span>&#123;  String remainder = <span class="hljs-string">&quot;0&quot;</span> + dest;  String quotient = <span class="hljs-string">&quot;00000000000000000000000000000&quot;</span>;  src = <span class="hljs-string">&quot;0&quot;</span> + src;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">29</span>; i++)&#123;    remainder = sub(src, remainder);    <span class="hljs-keyword">char</span> tmp = quotient.charAt(<span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span>(CF == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;      quotient = quotient.substring(<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;1&quot;</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      remainder = add(src, remainder);      quotient = quotient.substring(<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;0&quot;</span>;    &#125;    remainder = remainder.substring(<span class="hljs-number">1</span>) + tmp;  &#125;  <span class="hljs-keyword">return</span> quotient;&#125;</code></pre><p>ppt截图：</p><p><img src="/img/COA/FloatMul.jpg" alt=""></p><h3 id="完整代码（包括辅助函数）"><a href="#完整代码（包括辅助函数）" class="headerlink" title="完整代码（包括辅助函数）"></a>完整代码（包括辅助函数）</h3><pre><code class="hljs java"><span class="hljs-function">String <span class="hljs-title">mul</span><span class="hljs-params">(String a, String b)</span> </span>&#123;  <span class="hljs-keyword">if</span>(Pattern.matches(a, IEEE754Float.NaN) || Pattern.matches(b, IEEE754Float.NaN))&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NaN&quot;</span>;  &#125;  String ansExp;  String ansFrac;  <span class="hljs-keyword">char</span> signA = a.charAt(<span class="hljs-number">0</span>);  <span class="hljs-keyword">char</span> signB = b.charAt(<span class="hljs-number">0</span>);  String ansSign = (signA == signB)? <span class="hljs-string">&quot;0&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>;  <span class="hljs-keyword">if</span>(a.equals(IEEE754Float.N_ZERO) || b.equals(IEEE754Float.N_ZERO)     || a.equals(IEEE754Float.P_ZERO) || b.equals(IEEE754Float.P_ZERO))&#123;    <span class="hljs-keyword">if</span>(Pattern.matches(a, IEEE754Float.NaN) || Pattern.matches(b, IEEE754Float.NaN))&#123;      <span class="hljs-keyword">return</span> IEEE754Float.NaN;    &#125;    <span class="hljs-keyword">if</span>(a.startsWith(<span class="hljs-string">&quot;11111111&quot;</span>, <span class="hljs-number">1</span>) || b.startsWith(<span class="hljs-string">&quot;11111111&quot;</span>, <span class="hljs-number">1</span>))&#123;      <span class="hljs-keyword">return</span> IEEE754Float.NaN;    &#125;    <span class="hljs-keyword">return</span> ansSign + <span class="hljs-string">&quot;0000000000000000000000000000000&quot;</span>;  &#125;  String expA = a.substring(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>);  String expB = b.substring(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>);  String bitA = (expA.equals(<span class="hljs-string">&quot;00000000&quot;</span>))? <span class="hljs-string">&quot;0&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>;  String bitB = (expB.equals(<span class="hljs-string">&quot;00000000&quot;</span>))? <span class="hljs-string">&quot;0&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>;  String fracA = a.substring(<span class="hljs-number">9</span>);  String fracB = b.substring(<span class="hljs-number">9</span>);  String countA = bitA + fracA + <span class="hljs-string">&quot;0000&quot;</span>; <span class="hljs-comment">//28</span>  String countB = bitB + fracB + <span class="hljs-string">&quot;0000&quot;</span>;  String tmp = add(expA, expB);  <span class="hljs-comment">//CF 判断有没有溢出；</span>  <span class="hljs-keyword">char</span> tmpCF = CF;  ansExp = sub(<span class="hljs-string">&quot;01111111&quot;</span>, tmp);  <span class="hljs-comment">//CF 判断有没有借位；</span>  <span class="hljs-keyword">if</span>((tmpCF==<span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; CF==<span class="hljs-string">&#x27;1&#x27;</span>) || ansExp.equals(<span class="hljs-string">&quot;11111111&quot;</span>))&#123; <span class="hljs-comment">//一开始溢出了但是没有借位，说明</span>    <span class="hljs-keyword">if</span>(signA==signB) <span class="hljs-keyword">return</span> IEEE754Float.P_INF;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> IEEE754Float.N_INF;  &#125;  <span class="hljs-keyword">if</span>(tmpCF==<span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; CF==<span class="hljs-string">&#x27;0&#x27;</span>)&#123; <span class="hljs-comment">//一开始没有溢出，但是有借位</span>    <span class="hljs-keyword">if</span>(signA==signB) <span class="hljs-keyword">return</span> IEEE754Float.P_ZERO;    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> IEEE754Float.N_ZERO;  &#125;  ansFrac = mulFrac(countA, countB).substring(<span class="hljs-number">1</span>, <span class="hljs-number">25</span>);  <span class="hljs-comment">//Normalize</span>  <span class="hljs-keyword">while</span> (ansFrac.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; !ansExp.equals(<span class="hljs-string">&quot;00000000&quot;</span>))&#123;    ansFrac = ansFrac.substring(<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;0&quot;</span>;    ansExp = sub(<span class="hljs-string">&quot;00000001&quot;</span>, ansExp);  &#125;  ansFrac = ansFrac.substring(<span class="hljs-number">1</span>, <span class="hljs-number">24</span>);  <span class="hljs-keyword">return</span> ansSign + ansExp + ansFrac;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment">     * compute the float mul of a / b</span><span class="hljs-comment">     */</span><span class="hljs-function">String <span class="hljs-title">div</span><span class="hljs-params">(String a, String b)</span> </span>&#123;  String ansExp;  String ansFrac;  <span class="hljs-keyword">char</span> signA = a.charAt(<span class="hljs-number">0</span>);  <span class="hljs-keyword">char</span> signB = b.charAt(<span class="hljs-number">0</span>);  String ansSign = (signA == signB)? <span class="hljs-string">&quot;0&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>;  <span class="hljs-keyword">if</span>(b.startsWith(<span class="hljs-string">&quot;0000000000000000000000000000000&quot;</span>, <span class="hljs-number">1</span>))&#123;    <span class="hljs-keyword">if</span>(a.equals(IEEE754Float.N_ZERO) || a.equals(IEEE754Float.P_ZERO))&#123;      <span class="hljs-keyword">return</span> IEEE754Float.NaN;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArithmeticException();    &#125;  &#125;  <span class="hljs-keyword">if</span>(a.startsWith(<span class="hljs-string">&quot;0000000000000000000000000000000&quot;</span>, <span class="hljs-number">1</span>))&#123;    <span class="hljs-keyword">return</span> ansSign + <span class="hljs-string">&quot;0000000000000000000000000000000&quot;</span>;  &#125;  String expA = a.substring(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>);  String expB = b.substring(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>);  String bitA = (expA.equals(<span class="hljs-string">&quot;00000000&quot;</span>))? <span class="hljs-string">&quot;0&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>;  String bitB = (expB.equals(<span class="hljs-string">&quot;00000000&quot;</span>))? <span class="hljs-string">&quot;0&quot;</span>:<span class="hljs-string">&quot;1&quot;</span>;  String fracA = a.substring(<span class="hljs-number">9</span>);  String fracB = b.substring(<span class="hljs-number">9</span>);  String countA = bitA + fracA + <span class="hljs-string">&quot;0000&quot;</span>; <span class="hljs-comment">//28</span>  String countB = bitB + fracB + <span class="hljs-string">&quot;0000&quot;</span>;  String tmp = sub(expB, expA);  <span class="hljs-comment">//CF 判断有没有溢出；</span>  <span class="hljs-keyword">char</span> tmpCF = CF;  ansExp = add(<span class="hljs-string">&quot;01111111&quot;</span>, tmp);  <span class="hljs-comment">//CF 判断有没有借位；</span>  <span class="hljs-keyword">if</span>(tmpCF == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; CF == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;    <span class="hljs-keyword">return</span> ansSign + <span class="hljs-string">&quot;0000000000000000000000000000000&quot;</span>;  &#125;  <span class="hljs-keyword">if</span>(tmpCF == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; CF == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;    <span class="hljs-keyword">return</span> ansSign + <span class="hljs-string">&quot;1111111100000000000000000000000&quot;</span>;  &#125;  ansFrac = divFrac(countB, countA).substring(<span class="hljs-number">0</span>, <span class="hljs-number">24</span>);  <span class="hljs-comment">//Normalize</span>  <span class="hljs-keyword">while</span> (ansFrac.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span> &amp;&amp; !ansExp.equals(<span class="hljs-string">&quot;00000000&quot;</span>))&#123;    ansFrac = ansFrac.substring(<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;0&quot;</span>;    ansExp = sub(<span class="hljs-string">&quot;00000001&quot;</span>, ansExp);  &#125;  ansFrac = ansFrac.substring(<span class="hljs-number">1</span>, <span class="hljs-number">24</span>);  <span class="hljs-keyword">return</span> ansSign + ansExp + ansFrac;&#125;<span class="hljs-function">String <span class="hljs-title">add</span><span class="hljs-params">(String src, String dest)</span> </span>&#123;  <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;  <span class="hljs-keyword">char</span>[] srcArr = src.toCharArray();  <span class="hljs-keyword">char</span>[] destArr = dest.toCharArray();  <span class="hljs-keyword">int</span> len = srcArr.length;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=len-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;    <span class="hljs-keyword">if</span>(srcArr[i]==<span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; destArr[i]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;      destArr[i] = (carry==<span class="hljs-number">1</span>)? <span class="hljs-string">&#x27;1&#x27;</span>:<span class="hljs-string">&#x27;0&#x27;</span>;      carry = <span class="hljs-number">1</span>;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (srcArr[i]==<span class="hljs-string">&#x27;1&#x27;</span> || destArr[i]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;      <span class="hljs-keyword">if</span>(carry==<span class="hljs-number">1</span>)&#123;        destArr[i] = <span class="hljs-string">&#x27;0&#x27;</span>;      &#125; <span class="hljs-keyword">else</span> &#123;        destArr[i] = <span class="hljs-string">&#x27;1&#x27;</span>;        carry = <span class="hljs-number">0</span>;      &#125;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (carry == <span class="hljs-number">1</span>)&#123;      destArr[i] = <span class="hljs-string">&#x27;1&#x27;</span>;      carry = <span class="hljs-number">0</span>;    &#125;  &#125;  <span class="hljs-keyword">this</span>.CF = (carry == <span class="hljs-number">1</span>)? <span class="hljs-string">&#x27;1&#x27;</span>:<span class="hljs-string">&#x27;0&#x27;</span>;  <span class="hljs-keyword">return</span> String.valueOf(destArr);&#125;<span class="hljs-function">String <span class="hljs-title">sub</span><span class="hljs-params">(String src, String dest)</span> </span>&#123;  <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;  <span class="hljs-keyword">char</span>[] srcArr = src.toCharArray();  <span class="hljs-keyword">char</span>[] destArr = dest.toCharArray();  <span class="hljs-keyword">int</span> len = srcArr.length;  <span class="hljs-keyword">int</span> flg = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=len-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;    <span class="hljs-keyword">if</span>(flg == <span class="hljs-number">1</span>)&#123;      srcArr[i] = (srcArr[i]==<span class="hljs-string">&#x27;0&#x27;</span>)? <span class="hljs-string">&#x27;1&#x27;</span>:<span class="hljs-string">&#x27;0&#x27;</span>;    &#125;    <span class="hljs-keyword">if</span>(srcArr[i]!=<span class="hljs-string">&#x27;0&#x27;</span>)&#123;      flg = <span class="hljs-number">1</span>;    &#125;  &#125;  <span class="hljs-keyword">return</span> add(String.valueOf(srcArr), dest);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">mulFrac</span> <span class="hljs-params">(String src, String dest)</span></span>&#123;  String Y = dest;  String product = <span class="hljs-string">&quot;0000000000000000000000000000&quot;</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">28</span>; i++)&#123;    <span class="hljs-keyword">if</span>(Y.charAt(<span class="hljs-number">27</span>) == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;      product = add(src, product);    &#125;    product = <span class="hljs-string">&quot;0&quot;</span> + product;    Y = product.charAt(<span class="hljs-number">28</span>) + Y.substring(<span class="hljs-number">0</span>, <span class="hljs-number">28</span>);    product = product.substring(<span class="hljs-number">0</span>, <span class="hljs-number">28</span>);  &#125;  <span class="hljs-keyword">return</span> product;&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">divFrac</span> <span class="hljs-params">(String src, String dest)</span></span>&#123;  String remainder = <span class="hljs-string">&quot;0&quot;</span> + dest;  String quotient = <span class="hljs-string">&quot;00000000000000000000000000000&quot;</span>;  src = <span class="hljs-string">&quot;0&quot;</span> + src;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">29</span>; i++)&#123;    remainder = sub(src, remainder);    <span class="hljs-keyword">char</span> tmp = quotient.charAt(<span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span>(CF == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;      quotient = quotient.substring(<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;1&quot;</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      remainder = add(src, remainder);      quotient = quotient.substring(<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;0&quot;</span>;    &#125;    remainder = remainder.substring(<span class="hljs-number">1</span>) + tmp;  &#125;  <span class="hljs-keyword">return</span> quotient;&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>WeeklyReview</tag>
      
      <tag>Integer</tag>
      
      <tag>COA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据科学基础期中复习</title>
    <link href="/2020/11/06/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/"/>
    <url>/2020/11/06/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6%E5%9F%BA%E7%A1%80%E6%9C%9F%E4%B8%AD%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>不情不愿地来复习这门课（怒捶桌子，哥们半个学期作业没留一道，也不知道学了什么，就知道这学期不光有期中期末，还得来个大作业。吐槽吐槽吐槽……，唉，但最近又被留学顾问push了GPA，之前也被ly老师push了排名，不卷还是不行……不过就剩几天的时间了，还是死亡冲刺一下吧。我也是再也不想学和数据科学有关的课了= =头疼。</p><h3 id="这哥们这半学期都讲了点啥？"><a href="#这哥们这半学期都讲了点啥？" class="headerlink" title="这哥们这半学期都讲了点啥？"></a>这哥们这半学期都讲了点啥？</h3><p>让我们来数一数有多少窟窿需要补的🤔，先不进行细节补充，只列举知识点。</p><ol><li>数据类型（这真的会考？</li><li>中位数、四分位数；</li><li>平均数及算术平均数求和稳定性。</li><li>全距（极差）、内距（内四分位距）；</li><li>偏差平方和（方差*总数）；</li><li>古典概型、几何概型；</li><li>条件概率、全概率公式、贝叶斯公式；</li><li>分布函数、分布律、概率密度函数；</li><li>矩、原点矩、中心矩；</li><li>数学期望、方差；</li><li>伯努利分布、二项分布（n重伯努利分布）、泊松分布、柏松逼近、几何分布、超几何分布；</li><li>均匀分布、指数分布、正态分布</li><li>抽样分布定理、切比雪夫不等式、大数定律、中心极限定理；</li><li>卡方分布、t-分布、F-分布【他真的讲了这个？】</li></ol><h2 id="为期2天的光速预习开始了！"><a href="#为期2天的光速预习开始了！" class="headerlink" title="为期2天的光速预习开始了！"></a>为期2天的光速预习开始了！</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>定类数据——没有顺序大小之分的低级数据；</li><li>定序数据——有等级之分的数据；</li><li>定距数据——有类别或次序之间的距离的数据；</li><li>定比数据——可作为比率的基数的数据，具有绝对零点；</li></ul><h3 id="中位数、四分位数、众数"><a href="#中位数、四分位数、众数" class="headerlink" title="中位数、四分位数、众数"></a>中位数、四分位数、众数</h3><ul><li><p>众数不受极值的影响。</p></li><li><p>当数据中存在极值时,算术平均数便会歪曲数据反映的信息。此时算术平均数并不是描述这类数据集 中趋势的最佳度量。</p></li><li><p>求和稳定性</p><ul><li><script type="math/tex; mode=display">\sum_{i=1}^n(X_i-\overline X) = 0</script></li></ul></li><li></li></ul><h3 id="全距（极差）、内距（内四分位距）；"><a href="#全距（极差）、内距（内四分位距）；" class="headerlink" title="全距（极差）、内距（内四分位距）；"></a>全距（极差）、内距（内四分位距）；</h3><ul><li>全距——最大值与最小值的差；</li><li>内距——第三四分位数与第一四分位数的差（相比较全距受极值的影响小）。<ul><li>不能提供精确的数据分布信息。 </li><li>不能用来进行精确的统计推断。</li></ul></li></ul><h3 id="条件概率"><a href="#条件概率" class="headerlink" title="条件概率"></a>条件概率</h3><ul><li><script type="math/tex; mode=display">P(A|B)=\frac{P(AB)}{P(B)}</script></li><li><script type="math/tex; mode=display">P(AB)={P(B)}{P(A|B)}</script></li><li><script type="math/tex; mode=display">P(A)=\sum_{i=1}^nP(B_i)P(A|B_i)</script></li></ul><p>  例题1：考卷中一道选择题有4个答案，仅有一个是正确的，设一个学生知道 正确答案或不知道而乱猜是等可能的。 如果这个学生答对了，求他确实知道正确答案的概率？</p><p>  样本空间可以划分为事件A：知道正确答案，以B表示学生答对事件。</p><script type="math/tex; mode=display">  P(B)=P(A)P(B|A)+P(\overline A)P(B|\overline A)</script><script type="math/tex; mode=display">  P(A|B)=\frac{P(AB)}{P(B)}=\frac{4}{5}</script><h3 id="贝叶斯公式"><a href="#贝叶斯公式" class="headerlink" title="贝叶斯公式"></a>贝叶斯公式</h3><script type="math/tex; mode=display">p(A|B)=\frac{P(B|A)*P(A)}{P(B)}</script><h3 id="分布函数"><a href="#分布函数" class="headerlink" title="分布函数"></a>分布函数</h3><ul><li><p>归一性：</p><ul><li><script type="math/tex; mode=display">lim_{x\rightarrow-\infty}F(x)=0</script></li><li><script type="math/tex; mode=display">lim_{x\rightarrow+\infty}F(x)=1</script></li></ul></li><li><p>单调不减性；</p></li><li><p>连续性；</p></li></ul><h3 id="概率密度函数"><a href="#概率密度函数" class="headerlink" title="概率密度函数"></a>概率密度函数</h3><ul><li><script type="math/tex; mode=display">f(x) \ge 0</script></li><li><script type="math/tex; mode=display">\int_{-\infty}^{+\infty}f(x)=1</script></li><li><script type="math/tex; mode=display">P(a<X<b)=\int_a^bf(x)dx=F(b)-F(a)</script></li></ul><h3 id="数学期望"><a href="#数学期望" class="headerlink" title="数学期望"></a>数学期望</h3><ul><li><p>连续随机变量数学期望</p></li><li><script type="math/tex; mode=display">E(X)=\int_{-\infty}^{+\infty}xf(x)dx</script></li><li><p>数学期望的性质</p></li><li><script type="math/tex; mode=display">E(CX)=CE(X)</script></li><li><script type="math/tex; mode=display">E(X+Y)=E(X)+E(Y)</script></li><li><p>当X和Y独立，</p></li><li><script type="math/tex; mode=display">E(XY)=E(X)E(Y)</script></li></ul><h3 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h3><ul><li><script type="math/tex; mode=display">D(X)=E(X^2)-(EX)^2</script></li><li><script type="math/tex; mode=display">D(X+C)=D(X)</script></li><li><script type="math/tex; mode=display">D(CX)=C^2D(X)</script></li><li><p>当X和Y相互独立</p></li><li><script type="math/tex; mode=display">D(X\pm Y)=D(X)\pm D(Y)</script></li></ul><h3 id="伯努利分布"><a href="#伯努利分布" class="headerlink" title="伯努利分布"></a>伯努利分布</h3><p>0-1分布</p><script type="math/tex; mode=display">E(X)=p</script><script type="math/tex; mode=display">D(X)=p(1-p)</script><h3 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a>二项分布</h3><script type="math/tex; mode=display">E(X)=np</script><script type="math/tex; mode=display">D(X)=np(1-p)</script><h3 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a>泊松分布</h3><script type="math/tex; mode=display">P(X=k)=\frac{\lambda^k}{k!}e^{-\lambda}</script><ul><li><p>柏松逼近</p></li><li><script type="math/tex; mode=display">lim_{n\rightarrow\infty}B(n, p_n)=\pi(\lambda)</script></li><li><script type="math/tex; mode=display">\lambda = np</script></li></ul><h3 id="几何分布"><a href="#几何分布" class="headerlink" title="几何分布"></a>几何分布</h3><script type="math/tex; mode=display">E(X)=\sum_{i=1}^{\infty}ipq^{i-1}=\frac{1}{1-q}=\frac{1}{p}</script><script type="math/tex; mode=display">D(X)=E(X^2)-(EX)^2=\frac{1-p}{p^2}</script><p><strong>几何分布无记忆性。</strong></p><h3 id="超几何分布"><a href="#超几何分布" class="headerlink" title="超几何分布"></a>超几何分布</h3><script type="math/tex; mode=display">p = \frac{M}{N}</script><h3 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a>均匀分布</h3><script type="math/tex; mode=display">f(x)=\frac{1}{b-a}</script><script type="math/tex; mode=display">EX=\frac{a+b}{2}</script><script type="math/tex; mode=display">D(X)=\frac{(b-a)^2}{12}</script><h3 id="指数分布"><a href="#指数分布" class="headerlink" title="指数分布"></a>指数分布</h3><script type="math/tex; mode=display">f(x)=\frac{1}{\theta}e^{-\frac{x}{\theta}}</script><p>分布函数为：</p><script type="math/tex; mode=display">F(x)=1-e^{-\frac{x}{\theta}}</script><p>指数分布无记忆性</p><script type="math/tex; mode=display">E(X)=\theta</script><script type="math/tex; mode=display">D(X)={\theta}^2</script><h3 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a>正态分布</h3><script type="math/tex; mode=display">\phi</script>]]></content>
    
    
    <categories>
      
      <category>大二上期中复习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据科学</tag>
      
      <tag>期中复习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Integer-Arithmetic-Review-mul&amp;div</title>
    <link href="/2020/11/06/Integer-Arithmetic-Review/"/>
    <url>/2020/11/06/Integer-Arithmetic-Review/</url>
    
    <content type="html"><![CDATA[<h2 id="整数乘除运算编程作业总结"><a href="#整数乘除运算编程作业总结" class="headerlink" title="整数乘除运算编程作业总结"></a>整数乘除运算编程作业总结</h2><h5 id="注：本地作业调用的函数均为以前使用过的add、sub、neg"><a href="#注：本地作业调用的函数均为以前使用过的add、sub、neg" class="headerlink" title="注：本地作业调用的函数均为以前使用过的add、sub、neg"></a>注：本地作业调用的函数均为以前使用过的add、sub、neg</h5><h3 id="整数乘法"><a href="#整数乘法" class="headerlink" title="整数乘法"></a>整数乘法</h3><p>从代码结构上来看乘法十分简单，但是我们还是要好好复习一下部分积和布斯乘法的概念。</p><p><img src="/img/COA/Booth.jpg" alt=""></p><p>首先把其中的一个乘数按各位展开。</p><script type="math/tex; mode=display">2^n = 2^{n+1}-2^n</script><p>进行如上所示的变换。拆开括号二次组合，因此就可以得到一个合式。</p><script type="math/tex; mode=display">\sum_{i=0}^{n-1}(X×(Y_i-Y_{i+1})×2^{-(n-i)})</script><p>因此每一项的P都可以表示成为：</p><script type="math/tex; mode=display">P_{i+1}=2^{-1}×(P_i + X×(Y_i-Y_{i+1}))</script><p>在上面，首先，为了满足变换的条件，需要添加上一个Y0。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">mul</span> <span class="hljs-params">(String src, String dest)</span></span>&#123;  dest = dest + <span class="hljs-string">&quot;0&quot;</span>;  String product = <span class="hljs-string">&quot;00000000000000000000000000000000&quot;</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">32</span>; i++)&#123;    <span class="hljs-keyword">char</span> Y = dest.charAt(<span class="hljs-number">32</span>);    <span class="hljs-keyword">char</span> Yi = dest.charAt(<span class="hljs-number">31</span>);    <span class="hljs-keyword">if</span>(Y - Yi == <span class="hljs-number">1</span>)&#123;      product = add(src, product);    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(Y - Yi == -<span class="hljs-number">1</span>) &#123;      product = sub(src, product);    &#125;    dest = product.charAt(<span class="hljs-number">31</span>) + dest.substring(<span class="hljs-number">0</span>, <span class="hljs-number">32</span>);    product = product.charAt(<span class="hljs-number">0</span>) + product.substring(<span class="hljs-number">0</span>, <span class="hljs-number">31</span>);  &#125;  String ret = product + dest.substring(<span class="hljs-number">0</span>, <span class="hljs-number">32</span>);  <span class="hljs-keyword">return</span> ret.substring(<span class="hljs-number">32</span>, <span class="hljs-number">64</span>);&#125;</code></pre><p>然后，进行32次循环。每一次循环根据两个Y的差来判断是加上还是减去另一个乘数。然后右移部分积和返回结果。</p><h3 id="整数除法"><a href="#整数除法" class="headerlink" title="整数除法"></a>整数除法</h3><p>除法相比较来说会烦人很多。</p><p>因为被除数的正负问题，我将除法分成两个部分处理。</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">div</span><span class="hljs-params">(String operand1, String operand2)</span> </span>&#123;  <span class="hljs-comment">//TODO</span>  <span class="hljs-keyword">if</span>(operand2.equals(BinaryIntegers.ZERO))&#123;    <span class="hljs-keyword">if</span>(operand1.equals(BinaryIntegers.ZERO))&#123;      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NaN&quot;</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArithmeticException();    &#125;  &#125;  String overflow = <span class="hljs-string">&quot;0&quot;</span>;  <span class="hljs-keyword">if</span>(operand1.equals(IEEE754Float.N_ZERO) &amp;&amp; operand2.equals(BinaryIntegers.NegativeOne))&#123;    overflow = <span class="hljs-string">&quot;1&quot;</span>;  &#125;  <span class="hljs-keyword">char</span> aSign = operand1.charAt(<span class="hljs-number">0</span>);  <span class="hljs-keyword">char</span> bSign = operand2.charAt(<span class="hljs-number">0</span>);  <span class="hljs-keyword">if</span>(bSign == <span class="hljs-string">&#x27;1&#x27;</span>) operand2 = Neg(operand2);  String[] ans;  <span class="hljs-keyword">if</span>(aSign==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;    ans = posDiv(operand1, operand2);    <span class="hljs-keyword">if</span>(bSign==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;      ans[<span class="hljs-number">1</span>] = Neg(ans[<span class="hljs-number">1</span>]);    &#125;  &#125; <span class="hljs-keyword">else</span>&#123;    ans = negDiv(operand1, operand2);    <span class="hljs-keyword">if</span>(bSign==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;      ans[<span class="hljs-number">1</span>] = Neg(ans[<span class="hljs-number">1</span>]);    &#125;  &#125;  <span class="hljs-keyword">return</span> overflow + ans[<span class="hljs-number">1</span>] + ans[<span class="hljs-number">0</span>];&#125;</code></pre><p>首先需要特判一些边界情况。</p><pre><code class="hljs java"><span class="hljs-keyword">if</span>(operand2.equals(BinaryIntegers.ZERO))&#123;  <span class="hljs-keyword">if</span>(operand1.equals(BinaryIntegers.ZERO))&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NaN&quot;</span>;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ArithmeticException();  &#125;&#125;</code></pre><p>如果被除数和除数都为0，那么得到的结果将会是“NaN”。如果被除数不为0，而除数为0，那么将会产生除法错，抛出ArithmeticException。</p><p>关于溢出位，在x86体系中，我们判断除法是否溢出的方法是判断被除数的高位是否比被除数要大。在本次编程作业中，我们需要判断的是一个特殊情况——最小负数即-2<sup>31</sup>除以-1溢出。</p><pre><code class="hljs java">String overflow = <span class="hljs-string">&quot;0&quot;</span>;<span class="hljs-keyword">if</span>(operand1.equals(IEEE754Float.N_ZERO) &amp;&amp; operand2.equals(BinaryIntegers.NegativeOne))&#123;  overflow = <span class="hljs-string">&quot;1&quot;</span>;&#125;</code></pre><p>之后我们要记录下被除数和除数的符号，方便后续的比较。并且将负的除数转化为正数。这里要提到的是，除法运算中，同号得正，异号得负，仅需要在结果处判断即可。</p><p>因此，我们根据被除数的正负分别调用除法处理函数。（因为需要返回商和余数，所以返回值使用了String数组）</p><pre><code class="hljs java"><span class="hljs-keyword">if</span>(aSign==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;  ans = posDiv(operand1, operand2);  <span class="hljs-keyword">if</span>(bSign==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;    ans[<span class="hljs-number">1</span>] = Neg(ans[<span class="hljs-number">1</span>]);  &#125;&#125; <span class="hljs-keyword">else</span>&#123;  ans = negDiv(operand1, operand2);  <span class="hljs-keyword">if</span>(bSign==<span class="hljs-string">&#x27;0&#x27;</span>)&#123;    ans[<span class="hljs-number">1</span>] = Neg(ans[<span class="hljs-number">1</span>]);  &#125;&#125;</code></pre><p>首先来介绍正数除法处理函数：</p><pre><code class="hljs java">String[] posDiv(String quotient, String division)&#123;  String[] ans = <span class="hljs-keyword">new</span> String[<span class="hljs-number">2</span>];  String remainder = <span class="hljs-string">&quot;00000000000000000000000000000000&quot;</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">32</span>; i++)&#123;    remainder = remainder.substring(<span class="hljs-number">1</span>) + quotient.charAt(<span class="hljs-number">0</span>);    <span class="hljs-keyword">if</span>(sub(division, remainder).charAt(<span class="hljs-number">0</span>) != remainder.charAt(<span class="hljs-number">0</span>))&#123;      quotient = quotient.substring(<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;0&quot;</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      quotient = quotient.substring(<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;1&quot;</span>;      remainder = sub(division, remainder);    &#125;  &#125;  ans[<span class="hljs-number">0</span>] = remainder;  ans[<span class="hljs-number">1</span>] = quotient;  <span class="hljs-keyword">return</span> ans;&#125;</code></pre><p>首先在被除数前方补上n个0，作为余数。</p><p>想象一个除法竖式的操作。</p><p>首先，我们左移一位余数和商，如果余数减去除数仍为正数，那么这一位在商处得到1，如果为负数，得到0。</p><p>重复32次结束。在余数处剩下的就是整个计算的余数。</p><p>下面来看看负数的处理，相比较来说就要复杂一些。</p><pre><code class="hljs java">String[] negDiv(String quotient, String division)&#123;  String[] ans = <span class="hljs-keyword">new</span> String[<span class="hljs-number">2</span>];  String remainder = <span class="hljs-string">&quot;11111111111111111111111111111111&quot;</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;quotient.length(); i++)&#123;    remainder = remainder.substring(<span class="hljs-number">1</span>) + quotient.charAt(<span class="hljs-number">0</span>);    remainder = add(remainder, division);    <span class="hljs-keyword">if</span>(CF.equals(<span class="hljs-string">&quot;1&quot;</span>))&#123;      <span class="hljs-comment">//余数和除数之间的操作变成了加法，所以如果错加了一个除数，我们需要把它减回去。</span>      remainder = sub(division, remainder);      quotient = quotient.substring(<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;0&quot;</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      quotient = quotient.substring(<span class="hljs-number">1</span>) + <span class="hljs-string">&quot;1&quot;</span>;    &#125;  &#125;  <span class="hljs-keyword">if</span>(add(remainder, division).equals(BinaryIntegers.ZERO))&#123;    remainder = BinaryIntegers.ZERO;    quotient = add(<span class="hljs-string">&quot;00000000000000000000000000000001&quot;</span>, quotient);  &#125;  ans[<span class="hljs-number">0</span>] = remainder;  ans[<span class="hljs-number">1</span>] = quotient;  <span class="hljs-keyword">return</span> ans;&#125;</code></pre><p>大致原理和正数并没有区别。只不过因为符号位为1，所以最高位之前补上的是32个1。余数和除数之间的操作变成了加法，所以如果错加了一个除数，我们需要把它减回去。</p><p>不过最后为什么有一个特判呢？</p><p>因为在正数的处理中，正数减一个数为0是很正常的并且不需要改变符号位，所以余数为0的情况可以被处理到。</p><p>而在负数中并不如此，余数全部为1的情况下，它的基准就会是-1。每当我们想做负数的除法整除操作时，差的这一位1经常会make trouble。</p><p>这怎么办呢……</p><p>首先先想想，如果不是整除的情况下，我们的除法计算是不是好的？【No matter whether it’s right or not, it works!】在正数除法中，我们的余数取值范围是0～2<sup>31</sup>-1，而负数除法中是-1～-2<sup>31</sup>，所以我们更倾向于留下的负数是-1！我们在设计除法运算的时候，就没考虑整除现象的产生。</p><p>怎么办？减去1让除法先算了，再加回去并且把余数置为0呗……</p><pre><code class="hljs java"><span class="hljs-keyword">if</span>(add(remainder, division).equals(BinaryIntegers.ZERO))&#123;  remainder = BinaryIntegers.ZERO;  quotient = add(<span class="hljs-string">&quot;00000000000000000000000000000001&quot;</span>, quotient);&#125;</code></pre><p>大致如此啦！( ´▽` )ﾉ</p>]]></content>
    
    
    
    <tags>
      
      <tag>WeeklyReview</tag>
      
      <tag>Integer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Floating-point-Arithmetic-Review</title>
    <link href="/2020/11/02/Floating-point-Arithmetic-Review/"/>
    <url>/2020/11/02/Floating-point-Arithmetic-Review/</url>
    
    <content type="html"><![CDATA[<h2 id="浮点数运算编程作业总结"><a href="#浮点数运算编程作业总结" class="headerlink" title="浮点数运算编程作业总结"></a>浮点数运算编程作业总结</h2><p>基本的运算流程按照ppt上的流程图来实现：</p><p><img src="/img/浮点数运算.jpg" alt=""></p><p>因为IEEE 754表示浮点数的特性，对于浮点数来说，整数和负数之间的差别就只有第一位的符号位。所以对于减法来说，只要将减数的符号变换，即可转换为加法！</p><pre><code class="hljs java"><span class="hljs-function">String <span class="hljs-title">sub</span><span class="hljs-params">(String a,String b)</span></span>&#123;  <span class="hljs-comment">// TODO</span>  b = (b.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">&#x27;0&#x27;</span>)? (<span class="hljs-string">&quot;1&quot;</span>.concat(b.substring(<span class="hljs-number">1</span>))) : (<span class="hljs-string">&quot;0&quot;</span>.concat(b.substring(<span class="hljs-number">1</span>)));  <span class="hljs-keyword">return</span> add(a, b);&#125;</code></pre><p>下面对加法的整个过程进行细致的分析，因此会把整个方法拆分成几个部分，完整的函数在本页的最后给出！(因为仅仅作为作业提交，整个代码不考虑效率、安全、耦合性和冗余程度，并且有一些溢出没有考虑判断，前排提醒！也许以后有机会可以重写x)</p><pre><code class="hljs java"><span class="hljs-keyword">if</span>(a.startsWith(<span class="hljs-string">&quot;0000000000000000000000000000000&quot;</span>, <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> b;<span class="hljs-keyword">if</span>(b.startsWith(<span class="hljs-string">&quot;0000000000000000000000000000000&quot;</span>, <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> a;</code></pre><p>首先，对于a或者b等于0的情况进行判断！如果其中的一个等于0，那么返回另一个即可！</p><pre><code class="hljs java"><span class="hljs-comment">//取a和b的阶码；</span>String aExp = a.substring(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>);String bExp = b.substring(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>);<span class="hljs-comment">//取出符号位；</span><span class="hljs-keyword">char</span> aSign = a.charAt(<span class="hljs-number">0</span>);<span class="hljs-keyword">char</span> bSign = b.charAt(<span class="hljs-number">0</span>);<span class="hljs-comment">//取出尾数；</span>String aFriction = a.substring(<span class="hljs-number">9</span>);String bFriction = b.substring(<span class="hljs-number">9</span>);<span class="hljs-comment">//以下只是为了简化代码将阶码转化为了整数，为了方便循环的写法；</span><span class="hljs-keyword">int</span> expA = unsignedVal(aExp);<span class="hljs-keyword">int</span> expB = unsignedVal(bExp);<span class="hljs-comment">//将规格化数的1补上，非规格化的0补上；</span>aFriction = (expA == <span class="hljs-number">0</span>)? (<span class="hljs-string">&quot;0&quot;</span>+aFriction):(<span class="hljs-string">&quot;1&quot;</span>+aFriction);bFriction = (expB == <span class="hljs-number">0</span>)? (<span class="hljs-string">&quot;0&quot;</span>+bFriction):(<span class="hljs-string">&quot;1&quot;</span>+bFriction);<span class="hljs-comment">//添加上保护位！</span>aFriction = aFriction + <span class="hljs-string">&quot;0000&quot;</span>; <span class="hljs-comment">//guardBits!</span>bFriction = bFriction + <span class="hljs-string">&quot;0000&quot;</span>; <span class="hljs-comment">//guardBits!</span></code></pre><p>以上的操作相当于是对两个浮点数的机器级表示对预处理。下面进行对阶的操作。</p><pre><code class="hljs java"><span class="hljs-comment">//flg的作用是为了知道究竟是操作a和b中的哪一个阶码来对阶的。</span><span class="hljs-keyword">int</span> flg = <span class="hljs-number">0</span>;<span class="hljs-comment">//对阶操作。</span><span class="hljs-keyword">while</span> (expA &lt; expB)&#123;  flg = <span class="hljs-number">1</span>;  aExp = alu.add(<span class="hljs-string">&quot;00000001&quot;</span>, aExp);  expA++;  aFriction = <span class="hljs-string">&quot;0&quot;</span> + aFriction;&#125;<span class="hljs-keyword">while</span> (expB &lt; expA)&#123;  flg = <span class="hljs-number">2</span>;  bExp = alu.add(<span class="hljs-string">&quot;00000001&quot;</span>, bExp);  expB++;  bFriction = <span class="hljs-string">&quot;0&quot;</span> + bFriction;&#125;<span class="hljs-keyword">if</span>(flg == <span class="hljs-number">1</span>)&#123;  <span class="hljs-keyword">if</span>(aFriction.startsWith(<span class="hljs-string">&quot;00000000000000000000000&quot;</span>, <span class="hljs-number">1</span>))     <span class="hljs-keyword">return</span> b;&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(flg == <span class="hljs-number">2</span>)&#123;  <span class="hljs-keyword">if</span>(bFriction.startsWith(<span class="hljs-string">&quot;00000000000000000000000&quot;</span>, <span class="hljs-number">1</span>))     <span class="hljs-keyword">return</span> a;&#125;</code></pre><p>我使用的while循环来进行对阶，将阶码较小的向大的对齐【注意，现在的尾数部分已经是包含规格化补上的“1”或者“0”以及保护位的了】，我右移尾数部分的方法是在尾数前面补0，最后取前28位（1位补上，23位尾数部分，4位保护位】。flg设置的意义：判断是谁进行的对阶，然后判断它的尾数有没有变成0（此时，阶码已经对齐）！一旦它变成0，返回的结果就是另一个数。</p><pre><code class="hljs java"><span class="hljs-comment">//取前28位 1位规格化/非规格化，23位尾数，4位保护位；</span>aFriction = aFriction.substring(<span class="hljs-number">0</span>, <span class="hljs-number">28</span>);bFriction = bFriction.substring(<span class="hljs-number">0</span>, <span class="hljs-number">28</span>);<span class="hljs-comment">//Sign them!</span>aFriction = <span class="hljs-string">&quot;00&quot;</span> + aFriction;bFriction = <span class="hljs-string">&quot;00&quot;</span> + bFriction;StringBuilder ansBuilder = <span class="hljs-keyword">new</span> StringBuilder();String ansFriction;<span class="hljs-keyword">if</span>(aSign == bSign)&#123;  ansFriction = alu.add(aFriction, bFriction);&#125; <span class="hljs-keyword">else</span> &#123;  ansFriction = alu.sub(bFriction, aFriction); &#125;</code></pre><p>这里为什么要在小数位前面加上两个0呢？首先，我们之后要对尾数部分进行加减运算，因为我们要进行的是带符号运算，因此，我们应该补充上至少一个符号位。所以最左边的0是作为符号位的。那么第二个0，就是用来判断加减之后是否溢出的。</p><p>对于异号加法，我们转化为同号减法；对于同号，直接做加法。</p><p>如果想加减之后等于0，那么计算结果为0，返回0！</p><pre><code class="hljs java"><span class="hljs-keyword">if</span>(ansFriction.equals(<span class="hljs-string">&quot;000000000000000000000000000000&quot;</span>))&#123;  <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;00000000000000000000000000000000&quot;</span>;&#125;</code></pre><p>针对符号位，首先我们应该明白一件事：<strong>两个正数或者负数之间的减法不会发生溢出。</strong>所以，对于加法来说，这个溢出位只判断同符号数相加之后是否溢出。</p><pre><code class="hljs java"><span class="hljs-keyword">if</span>(aSign == bSign)&#123;  ansBuilder.append(aSign);&#125; <span class="hljs-keyword">else</span> &#123;  <span class="hljs-keyword">if</span>(ansFriction.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;    <span class="hljs-comment">//a + b</span>    <span class="hljs-keyword">if</span>(aSign == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;      ansBuilder.append(<span class="hljs-string">&quot;0&quot;</span>);    &#125; <span class="hljs-keyword">else</span> &#123;      ansBuilder.append(<span class="hljs-string">&quot;1&quot;</span>);    &#125;    ansFriction = Neg(ansFriction);  &#125; <span class="hljs-keyword">else</span> &#123;    ansBuilder.append(aSign);  &#125;&#125;</code></pre><p>当a与b的符号相同时，发生的是加法，并且两个数的尾数都是正数。所以结果的符号直接与a或b相同即可。当a和b异号的时候，我们需要知道的是a和b之间的差。通过减法，再将得到的结果取绝对值，就可以得到它们的差。至于符号，我们靠上面的代码来判断：注意，我们上面是用a减去b。<strong>那么如果得到的结果是负数并且a是负数，说明a的绝对值小于b的绝对值，a+b得到的是正数。</strong>所以我们将返回值的符号位设为和b相同即可（谁的绝对值大和谁的符号相同）。最后将尾数部分取绝对值。如果为正数，说明a的绝对值更大，符号和a相同。</p><pre><code class="hljs java"><span class="hljs-keyword">if</span>(ansFriction.charAt(<span class="hljs-number">1</span>)==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;  <span class="hljs-keyword">if</span>(aExp.equals(<span class="hljs-string">&quot;11111110&quot;</span>))&#123;    ansBuilder.append(<span class="hljs-string">&quot;1111111100000000000000000000000&quot;</span>);    <span class="hljs-keyword">return</span> ansBuilder.toString();  &#125;  aExp = alu.add(aExp, <span class="hljs-string">&quot;00000001&quot;</span>);  ansFriction = ansFriction.substring(<span class="hljs-number">1</span>, <span class="hljs-number">29</span>);&#125; <span class="hljs-keyword">else</span> &#123;  ansFriction = ansFriction.substring(<span class="hljs-number">2</span>, <span class="hljs-number">30</span>);&#125;</code></pre><p>这里判断两数相加之后是否进位，如果进位就在阶码处+1，将尾数左移一位。此处应该判断结果是否会溢出，若溢出则返回无穷。因为此时我的小数部分是30位（2位补充的“00”+1位规格化的0/1+23位尾数+4位保护位），因此取相应的1到28位（左移）或2到30位（无左移）；</p><pre><code class="hljs java"><span class="hljs-keyword">while</span> (ansFriction.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;  aExp = alu.sub(<span class="hljs-string">&quot;00000001&quot;</span>, aExp);  ansFriction = ansFriction + <span class="hljs-string">&quot;0&quot;</span>;  ansFriction = ansFriction.substring(<span class="hljs-number">1</span>, <span class="hljs-number">28</span>);&#125;</code></pre><p>每当目前的尾数的第一位不为1，则需要进行规格化操作；（因为前面已经处理过全为0的情况，因此该循环可以终止）</p><pre><code class="hljs java">ansFriction = ansFriction.substring(<span class="hljs-number">0</span>, <span class="hljs-number">24</span>);ansBuilder.append(aExp);ansBuilder.append(ansFriction, <span class="hljs-number">1</span>, <span class="hljs-number">24</span>);<span class="hljs-keyword">return</span> ansBuilder.toString();</code></pre><p>完成答案。</p><h3 id="辅助函数一览"><a href="#辅助函数一览" class="headerlink" title="辅助函数一览"></a>辅助函数一览</h3><ol><li>计算一串01序列的无符号整数值；</li></ol><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">unsignedVal</span><span class="hljs-params">(String str)</span></span>&#123;  <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;  <span class="hljs-keyword">int</span> len = str.length();  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=len-<span class="hljs-number">1</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;    <span class="hljs-keyword">if</span> (str.charAt(i) == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;      ret += (<span class="hljs-number">1</span>&lt;&lt;(len-<span class="hljs-number">1</span>-i));    &#125;  &#125;  <span class="hljs-keyword">return</span> ret;&#125;</code></pre><ol><li>对带符号整数取反；</li></ol><pre><code class="hljs java"><span class="hljs-function">String <span class="hljs-title">Neg</span><span class="hljs-params">(String src)</span></span>&#123;  <span class="hljs-keyword">char</span>[] binaryStr = src.toCharArray();  <span class="hljs-keyword">int</span> index = src.length()-<span class="hljs-number">1</span>;  <span class="hljs-keyword">int</span> flg = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span>(; index&gt;=<span class="hljs-number">0</span>; index--)&#123;    <span class="hljs-keyword">if</span> (flg == <span class="hljs-number">1</span>)&#123;      binaryStr[index] = (binaryStr[index]==<span class="hljs-string">&#x27;1&#x27;</span>)? <span class="hljs-string">&#x27;0&#x27;</span>:<span class="hljs-string">&#x27;1&#x27;</span>;    &#125;    <span class="hljs-keyword">if</span>(binaryStr[index]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;      flg = <span class="hljs-number">1</span>;    &#125;  &#125;  <span class="hljs-keyword">return</span> String.valueOf(binaryStr);&#125;</code></pre><h3 id="完整的ADD函数"><a href="#完整的ADD函数" class="headerlink" title="完整的ADD函数"></a>完整的ADD函数</h3><pre><code class="hljs java"><span class="hljs-function">String <span class="hljs-title">add</span><span class="hljs-params">(String a,String b)</span></span>&#123;  <span class="hljs-comment">// TODO</span>  <span class="hljs-keyword">if</span>(a.startsWith(<span class="hljs-string">&quot;0000000000000000000000000000000&quot;</span>, <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> b;  <span class="hljs-keyword">if</span>(b.startsWith(<span class="hljs-string">&quot;0000000000000000000000000000000&quot;</span>, <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> a;  String aExp = a.substring(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>);  String bExp = b.substring(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>);  <span class="hljs-keyword">char</span> aSign = a.charAt(<span class="hljs-number">0</span>);  <span class="hljs-keyword">char</span> bSign = b.charAt(<span class="hljs-number">0</span>);  String aFriction = a.substring(<span class="hljs-number">9</span>);  String bFriction = b.substring(<span class="hljs-number">9</span>);  <span class="hljs-keyword">int</span> expA = unsignedVal(aExp);  <span class="hljs-keyword">int</span> expB = unsignedVal(bExp);  aFriction = (expA == <span class="hljs-number">0</span>)? (<span class="hljs-string">&quot;0&quot;</span>+aFriction):(<span class="hljs-string">&quot;1&quot;</span>+aFriction);  bFriction = (expB == <span class="hljs-number">0</span>)? (<span class="hljs-string">&quot;0&quot;</span>+bFriction):(<span class="hljs-string">&quot;1&quot;</span>+bFriction);  aFriction = aFriction + <span class="hljs-string">&quot;0000&quot;</span>; <span class="hljs-comment">//guardBits!</span>  bFriction = bFriction + <span class="hljs-string">&quot;0000&quot;</span>; <span class="hljs-comment">//guardBits!</span>  <span class="hljs-keyword">int</span> flg = <span class="hljs-number">0</span>;  <span class="hljs-keyword">while</span> (expA &lt; expB)&#123;    flg = <span class="hljs-number">1</span>;    aExp = alu.add(<span class="hljs-string">&quot;00000001&quot;</span>, aExp);    expA++;    aFriction = <span class="hljs-string">&quot;0&quot;</span> + aFriction;  &#125;  <span class="hljs-keyword">while</span> (expB &lt; expA)&#123;    flg = <span class="hljs-number">2</span>;    bExp = alu.add(<span class="hljs-string">&quot;00000001&quot;</span>, bExp);    expB++;    bFriction = <span class="hljs-string">&quot;0&quot;</span> + bFriction;  &#125;  <span class="hljs-keyword">if</span>(flg == <span class="hljs-number">1</span>)&#123;    <span class="hljs-keyword">if</span>(aFriction.startsWith(<span class="hljs-string">&quot;00000000000000000000000&quot;</span>, <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> b;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(flg == <span class="hljs-number">2</span>)&#123;    <span class="hljs-keyword">if</span>(bFriction.startsWith(<span class="hljs-string">&quot;00000000000000000000000&quot;</span>, <span class="hljs-number">1</span>)) <span class="hljs-keyword">return</span> a;  &#125;  aFriction = aFriction.substring(<span class="hljs-number">0</span>, <span class="hljs-number">28</span>);  bFriction = bFriction.substring(<span class="hljs-number">0</span>, <span class="hljs-number">28</span>);  <span class="hljs-comment">//Sign them!</span>  aFriction = <span class="hljs-string">&quot;00&quot;</span> + aFriction;  bFriction = <span class="hljs-string">&quot;00&quot;</span> + bFriction;  StringBuilder ansBuilder = <span class="hljs-keyword">new</span> StringBuilder();  String ansFriction;  <span class="hljs-keyword">if</span>(aSign == bSign)&#123;    ansFriction = alu.add(aFriction, bFriction);  &#125; <span class="hljs-keyword">else</span> &#123;    ansFriction = alu.sub(bFriction, aFriction); <span class="hljs-comment">//b+ a-</span>  &#125;  <span class="hljs-keyword">if</span>(ansFriction.equals(<span class="hljs-string">&quot;000000000000000000000000000000&quot;</span>))&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;00000000000000000000000000000000&quot;</span>;  &#125;  <span class="hljs-keyword">if</span>(aSign == bSign)&#123;    ansBuilder.append(aSign);  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">if</span>(ansFriction.charAt(<span class="hljs-number">0</span>)==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;      <span class="hljs-comment">//a + b</span>      <span class="hljs-keyword">if</span>(aSign == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;        ansBuilder.append(<span class="hljs-string">&quot;0&quot;</span>);      &#125; <span class="hljs-keyword">else</span> &#123;        ansBuilder.append(<span class="hljs-string">&quot;1&quot;</span>);      &#125;      ansFriction = Neg(ansFriction);    &#125; <span class="hljs-keyword">else</span> &#123;      ansBuilder.append(aSign);    &#125;  &#125;  <span class="hljs-comment">/*</span><span class="hljs-comment">        if(unsignedVal(ansFriction.substring(26, 30))&gt;7)&#123;</span><span class="hljs-comment">            ansFriction = alu.add(ansFriction, &quot;000000000000000000000000001000&quot;);</span><span class="hljs-comment">        &#125;</span><span class="hljs-comment">         */</span>  <span class="hljs-keyword">if</span>(ansFriction.charAt(<span class="hljs-number">1</span>)==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;    <span class="hljs-keyword">if</span>(aExp.equals(<span class="hljs-string">&quot;11111110&quot;</span>))&#123;      ansBuilder.append(<span class="hljs-string">&quot;1111111100000000000000000000000&quot;</span>);      <span class="hljs-keyword">return</span> ansBuilder.toString();    &#125;    aExp = alu.add(aExp, <span class="hljs-string">&quot;00000001&quot;</span>);    ansFriction = ansFriction.substring(<span class="hljs-number">1</span>, <span class="hljs-number">29</span>);  &#125; <span class="hljs-keyword">else</span> &#123;    ansFriction = ansFriction.substring(<span class="hljs-number">2</span>, <span class="hljs-number">30</span>);  &#125;  <span class="hljs-comment">//normalize</span>  <span class="hljs-keyword">while</span> (ansFriction.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span>)&#123;    aExp = alu.sub(<span class="hljs-string">&quot;00000001&quot;</span>, aExp);    ansFriction = ansFriction + <span class="hljs-string">&quot;0&quot;</span>;    ansFriction = ansFriction.substring(<span class="hljs-number">1</span>, <span class="hljs-number">28</span>);  &#125;  ansFriction = ansFriction.substring(<span class="hljs-number">0</span>, <span class="hljs-number">24</span>);  ansBuilder.append(aExp);  ansBuilder.append(ansFriction, <span class="hljs-number">1</span>, <span class="hljs-number">24</span>);  <span class="hljs-keyword">return</span> ansBuilder.toString();&#125;</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>WeeklyReview</tag>
      
      <tag>Integer</tag>
      
      <tag>COA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>week6-Grade2-fall</title>
    <link href="/2020/11/02/week6-Grade2-fall/"/>
    <url>/2020/11/02/week6-Grade2-fall/</url>
    
    <content type="html"><![CDATA[<h2 id="算法分析与设计"><a href="#算法分析与设计" class="headerlink" title="算法分析与设计"></a>算法分析与设计</h2><h2 id="计算机组成与结构"><a href="#计算机组成与结构" class="headerlink" title="计算机组成与结构"></a>计算机组成与结构</h2><h3 id="磁盘"><a href="#磁盘" class="headerlink" title="磁盘"></a>磁盘</h3><ul><li><p>本身盘不带有磁性，磁性物质被洒在盘面上；</p></li><li><p>一个扇区的存储容量经常是512B；</p></li><li><p>内外圈读512B的时间都是一样的。只要保证一个角度（内圈）即可。每一圈都是一样的，很容易算出来它在哪个位置。</p></li><li><p>多划分（multiple zone recording）：每多一次扇区就要调整一次磁头的转速【成本高，容易坏】；提高了磁盘的利用效率可以多放几个512B；</p></li><li><p>相同磁道合起来是一个柱面；同一个柱面的数据每次一起写；</p></li><li><p>格式化</p><ul><li>gap多余——提供反应时间。不能够太短。</li></ul></li><li><p>读写数据</p><ul><li><p>寻道时间+旋转延迟+读写时间；</p></li><li><script type="math/tex; mode=display">T_a=T_s+\frac{1}{2r}+\frac{b}{rN}</script></li><li><p>r表示转速；</p></li></ul></li><li><p>磁头扫描算法</p><ul><li>FCFS：</li><li>SSTF：移动到距离当前磁道最近的。</li><li>SCAN：从0磁道到N；</li><li>C-SCAN：从N磁道到0；</li><li>为什么不来回扫呢？最坏等待时间会变短！</li></ul></li><li><p>磁道号、磁头号。</p><ul><li>同步字节——提醒需要开始读了。</li><li>为什么要加一个gap？——足够长的等待时间方便后面操作。避免所有的扇区划分在一起。</li></ul></li><li><p>写：</p><ul><li>电流——磁场——磁性物质不同排列——电阻变化——恒定电流</li></ul></li><li>寻道时间：磁头移动到目标磁道的时间；</li><li>CD<ul><li>一条线状均匀分布</li><li>CD盘的凹凸不平是压出来的——母盘。</li><li>刻录——高强度激光（反射时承担的两种状态 pit 和 land） </li></ul></li></ul><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><ul><li>海明码<ul><li>故障字（syndrome word）</li><li>总共有M+K+1种情况；</li></ul></li><li>只有一位出错的时候表示C出错</li><li>故障字的组合情况是唯一的。</li><li>生成多项式——f</li><li></li></ul>]]></content>
    
    
    <categories>
      
      <category>WeeklyReview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WeeklyReview</tag>
      
      <tag>DFS</tag>
      
      <tag>BFS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NBCD-Review</title>
    <link href="/2020/10/23/NBCD-Review/"/>
    <url>/2020/10/23/NBCD-Review/</url>
    
    <content type="html"><![CDATA[<p>因为NBCD在编程作业中的头疼程度，决定对他进行一个单独的篇章进行总结（但或许这个知识点本身并不是特别重要）。</p><h2 id="NBCD"><a href="#NBCD" class="headerlink" title="NBCD"></a>NBCD</h2><p>BCD(a.k.a. Binary-Coded Decimal)。NBCD码，也称8421码。将0～9表示成四位0000～1001。编程作业中的NBCD码固定为32位，表示1个符号和7个数字。而实际表示中，NBCD可以表示无限位的十进制整数。正号表示为“1100”，负号表示为“1101”。</p><ul><li>注：0在NBCD码中只有正0，需要注意。（也许这只是编程作业的feature）</li><li>32位的NBCD码中，若该位没有数字则用“0000”补充。</li></ul><h2 id="NBCD的加法"><a href="#NBCD的加法" class="headerlink" title="NBCD的加法"></a>NBCD的加法</h2><ul><li>符号系统有一些复杂，所以我做了这样的处理：<ul><li>1⃣️对于加法，同号继续，异号调用减法；</li><li>2⃣️对于减法，同号继续，异号调用加法；</li><li>注：这样的调用会增加程序的耦合性，是一种不好的编程习惯！</li></ul></li><li>NBCD的加法是单次四位操作的，每次使用位级加法。但这样会产生一个问题：结果产生在范围1010～1111，或产生了进位。因为十六进制表示的原因，位级加减得到的结果一旦需要进位，会比正常得到的结果少6。所以我们在需要进位的时候设置进位CF为1，并且为位级计算的结果加上“0110”。</li><li>别忘了在没有进位的时候设置进位Carry为0；</li><li>因为在我的设计中，加法处理的是同号的情况，所以计算结果应当和位级计算的结果同号；所以计算结果的符号和a的符号相同即可！</li><li>调用减法的时候需要注意替换符号，比如a和-b的情况（这里a和b都是绝对值），a+(-b)转化为a-b即可，也就是将b的符号“1101”换成“1100”就可以了。</li></ul><pre><code class="hljs java"><span class="hljs-function">String <span class="hljs-title">add</span><span class="hljs-params">(String a, String b)</span> </span>&#123;  <span class="hljs-comment">// TODO</span>  <span class="hljs-comment">//invoke cutStr to get slices;</span>  String[] aStr = cutStr(a);  String[] bStr = cutStr(b);  <span class="hljs-comment">//Accorrding to the sign, select which operation to take;</span>  String aSign = aStr[<span class="hljs-number">0</span>];  String bSign = bStr[<span class="hljs-number">0</span>];  <span class="hljs-keyword">if</span>(!aSign.equals(bSign))&#123;    <span class="hljs-keyword">if</span>(aSign.equals(<span class="hljs-string">&quot;1100&quot;</span>))&#123;      b = b.replace(<span class="hljs-string">&quot;1101&quot;</span>, <span class="hljs-string">&quot;1100&quot;</span>);      <span class="hljs-keyword">return</span> sub(b, a);    &#125; <span class="hljs-keyword">else</span> &#123;      a = a.replace(<span class="hljs-string">&quot;1101&quot;</span>, <span class="hljs-string">&quot;1100&quot;</span>);      <span class="hljs-keyword">return</span> sub(a, b);    &#125;  &#125;  String tmp;  StringBuilder ret = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-comment">//Carry Flag!</span>  <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">7</span>; i&gt;<span class="hljs-number">0</span>; i--)&#123;    <span class="hljs-comment">//Invoke alu.add to calculate the result of a and b;</span>    tmp = alu.add(aStr[i], bStr[i]);    <span class="hljs-keyword">if</span>(carry == <span class="hljs-number">1</span>)&#123;      tmp = alu.add(tmp, <span class="hljs-string">&quot;0001&quot;</span>); <span class="hljs-comment">//Carry One;</span>    &#125;    <span class="hljs-keyword">if</span>((aStr[i].charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;1&#x27;</span> || bStr[i].charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;1&#x27;</span>)&amp;&amp;(tmp.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span>)       || valOfNBCD(tmp)&gt;<span class="hljs-number">9</span>)&#123;         <span class="hljs-comment">// 1001 + 1000 = 0001 ? check overflow! if 1010 ~ 1111, overflow as well.</span>      carry = <span class="hljs-number">1</span>;      tmp = alu.add(tmp, <span class="hljs-string">&quot;0110&quot;</span>);    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">//Case: not overflow</span>      carry = <span class="hljs-number">0</span>;    &#125;    ret.insert(<span class="hljs-number">0</span>, tmp);  &#125;  <span class="hljs-comment">//Same as the two args;</span>  ret.insert(<span class="hljs-number">0</span>, aSign);  <span class="hljs-keyword">return</span> ret.toString();&#125;</code></pre><h2 id="NBCD的减法"><a href="#NBCD的减法" class="headerlink" title="NBCD的减法"></a>NBCD的减法</h2><p>整理（调用）的加法之所以相对简单是因为加法不会产生变号的现象。代码细节需要注意：b（第二个参数）为被减数，而第一个参数为减数。</p><ul><li><p>同理于加法，对于b和a异号的情况，调用加法进行计算。当b为负数a为正数的时候，转换为b和-a作加法。当b为正数a为负数的时候，转化为b和-a（正数）作加法。</p></li><li><p>减法的实质仍然是加法：</p></li><li><script type="math/tex; mode=display">A - B=A+(10^n-B)</script></li><li><p>因此在十进制中，我们<strong>对每一位数字取补（从右往左起的第一个非0位去减10（需要借位），后续的去减9。）</strong>。得到的结果与b（被减数）相加。这里加法的过程和加法是完全一样的；若对7位均进行操作，就不需要再“减掉”这个操作了，因为加上的10<sup>n</sup>会直接溢出。</p></li><li><p>因为这里加上了10<sup>n</sup>（n&lt;7），所以后面需要把他减掉。为了不影响原本为0的位，我们先把“0000”全部补上。</p><ul><li>关于这里需要判断一下carry的问题：这里其实判断的是溢出情况。比如说 333 - 300 = 33（假设这里只有3位），根据上面的操作，等效变成了 333 + 700 = 1033，这里就有一位的进位（进位到了千位）。而我们这里只有三位，这一位进位就会被自动舍弃，也就是说会自动减去一个1000，得到我们想要的结果：33。所以，在<strong>整体计算</strong>（即7位全部参与运算）之后，还有一位进位的情况下，不需要这个-10<sup>n</sup>的操作。</li><li>对于不需要进位的情况，我们根据刚才取补的方式：最低非0位去减10（10 - 最低非零位），从右起后续的每位去减9，就可以得到减去10之后的结果了。</li></ul></li><li><p>最后的一个重难点——<strong>判断符号</strong>。</p><ul><li><p>NBCD中没有负0，所以0我们要特判一下。</p></li><li><p>负数-负数的情况和正数-正数的情况相反，这里需要注意一下。比如(-3-(-4))不需要借位，但是它得到的是正数的结果；(1-2)同样是不需要借位的，但他得到的是负数的结果。</p></li><li><p>如果有进位（借位）：在正数相减中，有进位说明：被减数大于减数。我们回头去看一遍数学推导：</p><script type="math/tex; mode=display">A - B=A+(10^n-B)</script><p>如果有进位的话，说明：</p><script type="math/tex; mode=display">A - B=A+(10^n-B)>10^n</script><p>那么：</p><script type="math/tex; mode=display">A>B</script><p>说明了被减数大于减数，差应该和被减数同号！</p><p>如果没进位的话，结果就和上面正好相反：</p><script type="math/tex; mode=display">A<B</script><p>差应该和被减数异号！</p></li></ul></li></ul><p>以下就是一堆糟心的代码，可读性并不高，但可以根据上面的说明阅读一下。理论上还需要证明一下代码的正确性，但是太困了就算了吧QAQ</p><pre><code class="hljs java"><span class="hljs-comment">/***</span><span class="hljs-comment"> *</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> a A 32-bits NBCD String</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> b A 32-bits NBCD String</span><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> b - a</span><span class="hljs-comment"> */</span><span class="hljs-function">String <span class="hljs-title">sub</span><span class="hljs-params">(String a, String b)</span> </span>&#123;  <span class="hljs-comment">// TODO</span>  String[] aStr = cutStr(a);  String[] bStr = cutStr(b);  String aSign = aStr[<span class="hljs-number">0</span>];  String bSign = bStr[<span class="hljs-number">0</span>];  <span class="hljs-comment">//adjust sign bit;</span>  <span class="hljs-keyword">if</span>(!aSign.equals(bSign))&#123;    <span class="hljs-keyword">if</span>(aSign.equals(<span class="hljs-string">&quot;1100&quot;</span>))&#123;      a = a.replace(<span class="hljs-string">&quot;1100&quot;</span>, <span class="hljs-string">&quot;1101&quot;</span>);      <span class="hljs-keyword">return</span> add(a, b);    &#125; <span class="hljs-keyword">else</span> &#123;      a = a.replace(<span class="hljs-string">&quot;1101&quot;</span>, <span class="hljs-string">&quot;1100&quot;</span>);      <span class="hljs-keyword">return</span> add(a, b);    &#125;  &#125;  String tmpStr;  String[] ans = <span class="hljs-keyword">new</span> String[<span class="hljs-number">8</span>];  StringBuilder nTmp = <span class="hljs-keyword">new</span> StringBuilder();  <span class="hljs-keyword">int</span> i=<span class="hljs-number">7</span>;  <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;  <span class="hljs-keyword">int</span> carry = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span>(; i&gt;<span class="hljs-number">0</span>; i--)&#123;    <span class="hljs-keyword">if</span>(aStr[i].equals(<span class="hljs-string">&quot;0000&quot;</span>) &amp;&amp; bStr[i].equals(<span class="hljs-string">&quot;0000&quot;</span>)) <span class="hljs-keyword">break</span>;    tmpStr = alu.sub(aStr[i],<span class="hljs-string">&quot;1001&quot;</span>);    <span class="hljs-keyword">if</span>(i == <span class="hljs-number">7</span>) tmpStr = alu.add(tmpStr, <span class="hljs-string">&quot;0001&quot;</span>);   <span class="hljs-comment">//借位</span>    String tmp = tmpStr;    tmpStr = alu.add(tmpStr, bStr[i]);    <span class="hljs-keyword">if</span>(carry == <span class="hljs-number">1</span>)&#123;      tmpStr = alu.add(tmpStr, <span class="hljs-string">&quot;0001&quot;</span>);    &#125;    <span class="hljs-keyword">if</span>((tmp.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;1&#x27;</span> || bStr[i].charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;1&#x27;</span>)&amp;&amp;(tmpStr.charAt(<span class="hljs-number">0</span>) == <span class="hljs-string">&#x27;0&#x27;</span>) ||       valOfNBCD(tmpStr) &gt; <span class="hljs-number">9</span>)&#123;      <span class="hljs-comment">//carry和overflow还没判断呢！</span>      carry = <span class="hljs-number">1</span>;      tmpStr = alu.add(tmpStr, <span class="hljs-string">&quot;0110&quot;</span>);    &#125; <span class="hljs-keyword">else</span> &#123;      carry = <span class="hljs-number">0</span>;    &#125;    count++;    ans[i] = tmpStr;  &#125;  <span class="hljs-keyword">while</span> (i&gt;<span class="hljs-number">0</span>)&#123;    ans[i] = <span class="hljs-string">&quot;0000&quot;</span>;    i--;  &#125;  <span class="hljs-keyword">int</span> flg = <span class="hljs-number">0</span>;  <span class="hljs-keyword">if</span>(carry == <span class="hljs-number">0</span>)&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">7</span>; j&gt;<span class="hljs-number">7</span>-count; j--)&#123;      <span class="hljs-keyword">if</span>(ans[j].equals(<span class="hljs-string">&quot;0000&quot;</span>)) <span class="hljs-keyword">continue</span>;      <span class="hljs-keyword">if</span>(flg == <span class="hljs-number">0</span>)&#123;        ans[j] = alu.sub(ans[j], <span class="hljs-string">&quot;1010&quot;</span>);        flg = <span class="hljs-number">1</span>;      &#125; <span class="hljs-keyword">else</span> &#123;        ans[j] = alu.sub(ans[j], <span class="hljs-string">&quot;1001&quot;</span>);      &#125;    &#125;  &#125;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">7</span>; j&gt;<span class="hljs-number">0</span>; j--)&#123;    nTmp.insert(<span class="hljs-number">0</span>, ans[j]);  &#125;  String ret = nTmp.toString();  <span class="hljs-keyword">if</span> (ret.equals(<span class="hljs-string">&quot;0000000000000000000000000000&quot;</span>)) &#123; <span class="hljs-comment">//之前判断&quot;0&quot;有问题；</span>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;1100&quot;</span> + ret;  &#125;  <span class="hljs-keyword">if</span>(aSign.equals(<span class="hljs-string">&quot;1100&quot;</span>))&#123;    <span class="hljs-keyword">return</span> ((carry==<span class="hljs-number">1</span>)? <span class="hljs-string">&quot;1100&quot;</span>:<span class="hljs-string">&quot;1101&quot;</span>) + ret;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">return</span> ((carry==<span class="hljs-number">1</span>)? <span class="hljs-string">&quot;1101&quot;</span>:<span class="hljs-string">&quot;1100&quot;</span>) + ret;  &#125;&#125;</code></pre><h2 id="辅助函数一览"><a href="#辅助函数一览" class="headerlink" title="辅助函数一览"></a>辅助函数一览</h2><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">valOfNBCD</span><span class="hljs-params">(String a)</span></span>&#123;  <span class="hljs-keyword">char</span>[] aLst = a.toCharArray();  <span class="hljs-keyword">int</span> ret = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">4</span>; i++)&#123;    ret &lt;&lt;= <span class="hljs-number">1</span>;    ret += (aLst[i]==<span class="hljs-string">&#x27;1&#x27;</span>)? <span class="hljs-number">1</span>:<span class="hljs-number">0</span>;  &#125;  <span class="hljs-keyword">return</span> ret;&#125;</code></pre><p>计算四位BCD的值，即对应的0～9。</p><pre><code class="hljs java"><span class="hljs-keyword">static</span> String[] cutStr(String str)&#123;  String[] strArr = <span class="hljs-keyword">new</span> String[<span class="hljs-number">8</span>];  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">8</span>; i++)&#123;    strArr[i] = str.substring(<span class="hljs-number">4</span>*i, <span class="hljs-number">4</span>*(i + <span class="hljs-number">1</span>));  &#125;  <span class="hljs-keyword">return</span> strArr;&#125;</code></pre><p>将字符串以四个一组切分；</p><p>过程中还有调用ALU中的位级加减法，理解成整数相加减即可。</p>]]></content>
    
    
    
    <tags>
      
      <tag>WeeklyReview</tag>
      
      <tag>NBCD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>听不懂的短语汇总</title>
    <link href="/2020/10/21/%E5%90%AC%E4%B8%8D%E6%87%82%E7%9A%84%E7%9F%AD%E8%AF%AD%E6%B1%87%E6%80%BB/"/>
    <url>/2020/10/21/%E5%90%AC%E4%B8%8D%E6%87%82%E7%9A%84%E7%9F%AD%E8%AF%AD%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<ol><li>that’s only useful up to a point, … 在一定程度上有用，……</li><li>has been around for quite a while, … 问世已有一段时间，……</li></ol>]]></content>
    
    
    <categories>
      
      <category>TOEFL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TOEFL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>词根词缀</title>
    <link href="/2020/10/21/%E8%AF%8D%E6%A0%B9%E8%AF%8D%E7%BC%80/"/>
    <url>/2020/10/21/%E8%AF%8D%E6%A0%B9%E8%AF%8D%E7%BC%80/</url>
    
    <content type="html"><![CDATA[<h4 id="sid-坐-（sit）"><a href="#sid-坐-（sit）" class="headerlink" title="sid 坐 （sit）"></a>sid 坐 （sit）</h4><ul><li>residue 剩余，残留；</li><li>dissident 意见不同的（分开坐）；</li><li>subside 平息（坐下来了➡️息怒）；</li><li>assiduous 勤奋的，勤勉的；(as加强，加强坐下来了)</li></ul><h4 id="pend-花钱出去"><a href="#pend-花钱出去" class="headerlink" title="pend 花钱出去"></a>pend 花钱出去</h4><ul><li>dispense 分配；</li><li>expend （ex出+pend）花费；</li><li>dispensable 可分配的；indispensable 不可或缺的；</li></ul><h4 id="gest-带来；产生"><a href="#gest-带来；产生" class="headerlink" title="gest 带来；产生"></a>gest 带来；产生</h4><ul><li>ingest 摄入；（= take in）</li><li>digest 消化，吸收；（di分开；把营养分开带到不同的地方➡️消化）</li><li>indigestion 消化不良；</li></ul><h4 id="cept-拿"><a href="#cept-拿" class="headerlink" title="cept 拿"></a>cept 拿</h4><ul><li>susceptible 易受影响的（sus + cept + ible 能被拿下➡️易受影响)</li></ul><h4 id="indi-内部"><a href="#indi-内部" class="headerlink" title="indi 内部"></a>indi 内部</h4><ul><li>Indigenous 本土的；土著的；（indi + gen产生 + ous 内部产生➡️本土的）</li></ul><h4 id="rupt-break"><a href="#rupt-break" class="headerlink" title="rupt = break"></a>rupt = break</h4><ul><li>rupture v.破裂；</li><li>erupt v.爆发；</li><li>abrupt 突然；</li><li>bankrupt 破产；</li></ul><h4 id="ced-ceed-cede-cess-go-walk"><a href="#ced-ceed-cede-cess-go-walk" class="headerlink" title="ced ceed cede cess = go, walk"></a>ced ceed cede cess = go, walk</h4><ul><li>concede (都走了) =&gt; 割让，退让；</li><li>recede 往回走 =&gt; 撤退；</li><li>recessive 隐性的；</li><li>antecedent n.祖先；先驱（ante 在…之前，在之前走的=&gt;先驱）</li></ul><h4 id="dorm"><a href="#dorm" class="headerlink" title="dorm"></a>dorm</h4><ul><li>dormant 静止的</li><li>dormancy 冬眠，休眠，睡眠 （hibernation)</li></ul><h4 id="rod-bite"><a href="#rod-bite" class="headerlink" title="rod (= bite)"></a>rod (= bite)</h4><ul><li>erode 腐蚀，侵蚀；erosive</li><li>corrode</li><li>rodent 啮齿动物；</li></ul><h4 id="leg-lect-选择"><a href="#leg-lect-选择" class="headerlink" title="leg (=lect) 选择"></a>leg (=lect) 选择</h4><ul><li>select 选择；</li><li>elect （选出来 =&gt;） 选举</li><li>neglect （不选）=&gt; 忽视</li><li>elegant （被挑选出来的）=&gt; 很好的，优雅的；</li><li>legible 容易辨认的；</li></ul><h4 id="grav-重力"><a href="#grav-重力" class="headerlink" title="grav 重力"></a>grav 重力</h4><ul><li>gravity 重力；</li><li>aggravate 加重；（病情）恶化；</li><li>engrave 雕刻；</li></ul>]]></content>
    
    
    <categories>
      
      <category>TOEFL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TOEFL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>专业词汇</title>
    <link href="/2020/10/21/%E4%B8%93%E4%B8%9A%E8%AF%8D%E6%B1%87/"/>
    <url>/2020/10/21/%E4%B8%93%E4%B8%9A%E8%AF%8D%E6%B1%87/</url>
    
    <content type="html"><![CDATA[<h3 id="生物"><a href="#生物" class="headerlink" title="生物"></a>生物</h3><ul><li>invertebrate 无脊椎的； vertebrate 有脊椎的；</li><li>primates 灵长类；</li><li>mollusk 软体动物；</li><li>coelenterate 腔肠动物；</li><li>spineless 无脊椎的；没骨气的；Sipne 脊椎；</li><li>reproduce 繁殖；</li><li>recessive gene 隐性基因；</li></ul><h3 id="地质"><a href="#地质" class="headerlink" title="地质"></a>地质</h3><ul><li>sedimentation 沉淀（过程）；sediment 沉淀物；<ul><li>同义替换：deposit 沉淀；accumulation；</li></ul></li><li>grains 颗粒；纹理；</li><li>molten 熔化的；铸造的；</li><li>magma 岩浆；</li><li>lava 火山岩浆；</li><li>grantie 花岗岩；</li><li>lead 铅；</li><li>dating 确定年代；</li></ul><h4 id="商科"><a href="#商科" class="headerlink" title="商科"></a>商科</h4><ul><li>commodity/products/goods/merchandise 商品；<ul><li>commoditize 商品化；</li></ul></li><li>merchant 商业的；</li></ul>]]></content>
    
    
    <categories>
      
      <category>TOEFL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TOEFL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>独立写作题型分类</title>
    <link href="/2020/10/21/%E7%8B%AC%E7%AB%8B%E5%86%99%E4%BD%9C%E9%A2%98%E5%9E%8B%E5%88%86%E7%B1%BB/"/>
    <url>/2020/10/21/%E7%8B%AC%E7%AB%8B%E5%86%99%E4%BD%9C%E9%A2%98%E5%9E%8B%E5%88%86%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h3 id="1-A-should-题目"><a href="#1-A-should-题目" class="headerlink" title="1. A should 题目"></a>1. A should 题目</h3><ul><li>a. 标志词：should</li><li>b. 解题策略：分析<strong>利弊</strong></li></ul><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>（A/D：agree or disagree）</p><ul><li><p>A/D: Students <strong>should</strong> not take part-time jobs while they are studying in universities.</p><p>Disagree: </p><ol><li>Earn some money : become more economically independent.</li><li>Enlarge social circle.</li><li>Foster abilities and gain more social experience.</li></ol></li><li><p>A/D: University and colleges <strong>should</strong> provide students with work preparation before they graduate.</p><ol><li>To students: gain an <strong>edge(优势)</strong> over other competitors in <strong>job market</strong>.</li><li>To college: high employment rate is beneficial to the university’s <strong>reputation(fame)</strong></li><li>To company: <strong>get to(有机会；有能力做……)</strong> enjoy higher productivity.</li></ol></li><li><p>A/D: Parents should allow their children to make mistakes and let them learn from their own mistakes.</p><ol><li>To children: learn not to repeat the same mistake again.</li><li>To parent-child relationship: strengthen family bond/create family rapport.</li></ol></li></ul><h4 id="让步段🌟"><a href="#让步段🌟" class="headerlink" title="让步段🌟"></a>让步段🌟</h4><ul><li>Admittedly,…..  In that respect,……however,…    </li><li>to prevent this from happening. </li></ul><h4 id="或者：case-by-case"><a href="#或者：case-by-case" class="headerlink" title="或者：case-by-case"></a>或者：case-by-case</h4><ol><li>When children make some fatal errors such as doing drugs or gambling, it is imperative for parents to make a timely intervention.</li><li>When children make mistakes that won’t lead to serious consequences, letting them make mistakes is the best way to learn.</li></ol><h3 id="2-二选一题目"><a href="#2-二选一题目" class="headerlink" title="2. 二选一题目"></a>2. 二选一题目</h3><ul><li>a. 标志词：prefer/better/rather than</li><li>b. 解题策略：带着比较招利弊。做A比做B更好。</li><li>c. 比较对比原则：不可只提一方</li><li>d. 比较对比方法：<ul><li>段内比；</li><li>段简比；</li></ul></li></ul><h4 id="例题-1"><a href="#例题-1" class="headerlink" title="例题"></a>例题</h4><ul><li><p>(段内比)Some students prefer to study alone while others prefer to study with a group of students. What is your opinion?</p><ol><li>Get to exchange ideas - a better performance.(good academic performance)</li><li>Peer pressure - get over the habit of procrastination - boost learning efficiency </li><li>Cultivate teamwork spirit.</li></ol></li><li><p>A/D: University should spend more money <strong>supporting social activities</strong> rather than <strong>improving the food students eat.</strong></p><ul><li>观点：food quality</li></ul><ol><li>Physical health</li><li>Academic success</li><li>Social activities are also important, but …</li></ol></li></ul><h4 id="投资类二选一题目："><a href="#投资类二选一题目：" class="headerlink" title="投资类二选一题目："></a>投资类二选一题目：</h4><ul><li>1⃣️写2段A的好处/重要性</li><li><p>2⃣️让步段：Admittedly, B➡️重要。However, investments on B does <strong>not necessarily(不一定)</strong> rely only on government/school authority. We can also seek out for fund from somewhere else (commercial sponsorships/Non-Government Organizations)</p></li><li><p>A/D: For success in a future job, the ability to relate well to people is more important than studying hard in school.（不同工作偏向的能力不一样）</p><ol><li>Jobs that put much emphasis on interpersonal communication: the ability to relate well to people is more important.</li><li>Technology-oriented jobs: studying professional knowledge is more important.</li></ol></li></ul><h3 id="3-三选一"><a href="#3-三选一" class="headerlink" title="3. 三选一"></a>3. 三选一</h3><ul><li><p>a. 标志词：which is the best</p></li><li><p>b. 三选一对比原则：<strong><em>三者都要提及，缺一不可</em></strong></p></li><li><p>c. 解题策略</p><ul><li>段间比</li></ul><p>1⃣️</p><p>| Introduction |<br>| :—————: |<br>|      A+      |<br>|      B-      |<br>|      C-      |<br>|  Conclusion  |</p><p>2⃣️</p><p>| Introduction |<br>| :—————: |<br>|      A+      |<br>|      A+      |<br>|     BC-      |<br>|  Conclusion  |</p><p><em>Tips: 我可以写成让步段，也可以直接吐槽其不好</em></p></li></ul><h3 id="4-绝对词题目"><a href="#4-绝对词题目" class="headerlink" title="4. 绝对词题目"></a>4. 绝对词题目</h3><ul><li><p>a. 标志词：best/most/only/all/always/never</p></li><li><p>b. 观点取<strong><em>驳论</em></strong></p></li><li><p>c. 解题策略：</p><ul><li>辩证解法两步走：</li></ul><ol><li><p>承认合理性——把绝对词去掉；</p></li><li><p>反驳绝对性：</p><p>1⃣️找弊端、找局限</p><p>2⃣️针对绝对词来反驳</p><p>​        best - better</p><p>​        Only - other</p><p>​        all/never/always - exception</p></li></ol></li></ul><ul><li><p>A/D: The best way to learn a foreign country is from reading newspapers and magazines.</p><ol><li>承合: It is indeed a good way to learn a foreign country by reading newspapers and magazines. E.g. Broad coverage: political events, society, business, sports, entertainment, lifestyle… </li><li>驳绝-找弊端：It has some limitations. E.g. lack of sound and visual events; Possible delays: complicated publishing process➡️drafting, collecting, proofreading, printing, disturbing, etc.</li><li>驳绝-更好的方案: There are better ways to learn a country. E.g. visiting museums, traveling, reading books, watching movies.</li></ol></li><li><p>A/D: The best way to improve the quality of education is to increase teachers’ salaries.</p><ol><li>承合：Raising teachers’ salaries is a good way to boost better education performance. Motivate teachers to do a better jobs/Attract talents.</li><li>驳绝-找弊端：Make education unaffordable</li><li>驳绝-更好的方案：Provide teachers with trainings; improve facilities</li></ol></li></ul>]]></content>
    
    
    <categories>
      
      <category>TOEFL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TOEFL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TOEFL-writing-notes</title>
    <link href="/2020/10/20/TOEFL-writing-notes/"/>
    <url>/2020/10/20/TOEFL-writing-notes/</url>
    
    <content type="html"><![CDATA[<h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><div class="table-container"><table><thead><tr><th style="text-align:center">注意事项</th><th style="text-align:center">综合写作</th><th style="text-align:center">独立写作</th></tr></thead><tbody><tr><td style="text-align:center">形式</td><td style="text-align:center">读+听+写</td><td style="text-align:center">写</td></tr><tr><td style="text-align:center">时间</td><td style="text-align:center">20min</td><td style="text-align:center">30min</td></tr><tr><td style="text-align:center">字数</td><td style="text-align:center">150~225</td><td style="text-align:center">&gt;300</td></tr><tr><td style="text-align:center">题材</td><td style="text-align:center">Academic</td><td style="text-align:center">Non-Academic</td></tr><tr><td style="text-align:center">观点</td><td style="text-align:center">Objective</td><td style="text-align:center">Subjective</td></tr></tbody></table></div><h3 id="1-综合写作考试流程"><a href="#1-综合写作考试流程" class="headerlink" title="1. 综合写作考试流程"></a>1. 综合写作考试流程</h3><p>Wrting Based on reading and listening.</p><p>Step1: You will have <strong>3</strong> minute to read a passage.</p><ul><li>Structure: 总分结构，四段式<ul><li>一个总论点+三个分论点+理由细节</li></ul></li></ul><p>Step2: listening (阅读消失)</p><ul><li><p>You will hear a lecture for 2 minutes.</p></li><li><p>Tips: 听力与阅读的关系</p><ol><li>话题相同，观点相反</li><li>一一对应的反驳</li></ol></li></ul><p>Step3: Writing （阅读重现）</p><ul><li>Finish your essay in 20 minutes.</li><li>字数要求：150～225</li></ul><p>怎么写？</p><ul><li>第一段：阅读说了什么，听力不同意；</li><li>第二段：听力不同意阅读的第一个理由 + 听力细节；</li><li>第三段：听力不同意阅读的第二个理由 + 听力细节；</li><li>第四段：听力不同意阅读的第三个理由 + 听力细节；</li></ul><h3 id="2-独立写作"><a href="#2-独立写作" class="headerlink" title="2. 独立写作"></a>2. 独立写作</h3><p>Writing Based on Knowledge and experience.</p><p>Finish your essay in 30 minutes.</p><p>字数要求：300+</p><h3 id="3-段间结构的三种展开方式"><a href="#3-段间结构的三种展开方式" class="headerlink" title="3. 段间结构的三种展开方式"></a>3. 段间结构的三种展开方式</h3><h4 id="1-一边倒——有倾向性的观点。"><a href="#1-一边倒——有倾向性的观点。" class="headerlink" title="1. 一边倒——有倾向性的观点。"></a>1. <strong>一边倒</strong>——有倾向性的观点。</h4><div class="table-container"><table><thead><tr><th style="text-align:center">Introduction</th></tr></thead><tbody><tr><td style="text-align:center">A+/A&gt;B</td></tr><tr><td style="text-align:center">A+/A&gt;B</td></tr><tr><td style="text-align:center">A+/A&gt;B</td></tr><tr><td style="text-align:center">Conclusion</td></tr></tbody></table></div><h4 id="2-让步——仍然有自己明确段倾向性观点"><a href="#2-让步——仍然有自己明确段倾向性观点" class="headerlink" title="2. 让步——仍然有自己明确段倾向性观点"></a>2. 让步——仍然有自己明确段倾向性观点</h4><div class="table-container"><table><thead><tr><th style="text-align:center">Introduction</th></tr></thead><tbody><tr><td style="text-align:center">A+</td></tr><tr><td style="text-align:center">A+</td></tr><tr><td style="text-align:center">-(A-/B+)</td></tr><tr><td style="text-align:center">Conclusion</td></tr></tbody></table></div><ul><li>什么是让步段：不需要再去想出一个新的分论点去支持我方观点，而是也考虑到对立面的观点，承认我方观点也有一定缺陷，但是一定要<strong>转折回来（虚假妥协）。</strong><ul><li>使用条件：<ul><li>想不出足够理由的时候；</li><li>二选一题目中两者事物没有直接关联，无法直接比较时；</li><li>在绝对词题目中：承合段的本质是让步段；</li></ul></li></ul></li></ul><h4 id="3-Case-by-case"><a href="#3-Case-by-case" class="headerlink" title="3. Case-by-case"></a>3. Case-by-case</h4><p>无倾向性的观点。分别论述两方观点使用情况。</p><div class="table-container"><table><thead><tr><th style="text-align:center">Introduction</th></tr></thead><tbody><tr><td style="text-align:center">A+</td></tr><tr><td style="text-align:center">A-/B+</td></tr><tr><td style="text-align:center">Conclusion</td></tr></tbody></table></div><p>使用条件： 当我们发现话题的对立两面明显在世界中都存在且都明显不可或缺时，我们会考虑用这种写法。</p><p><strong><em>Tips：</em></strong>段落与段落之间应该满足什么要求？</p><ul><li>互斥：互不包含，互不因果</li><li>一个要点永远要自成一段，每个段落都必须充分展开，不能和其他段落有重合的部分。         </li></ul><p>辩证切入点：</p><ul><li>有时候，为了避免三个理由相同或相似，可以找不同段收益方或受损方。</li></ul><h3 id="4-托福独立写作评分标准"><a href="#4-托福独立写作评分标准" class="headerlink" title="4. 托福独立写作评分标准"></a>4. 托福独立写作评分标准</h3><ol><li>Effectively <strong>addresses</strong> the topic and task. 切题</li><li>Is well organized and well developed, using clearly appropriate explanations, exemplifications, and/or details. 组织良好，展开充分（事实性语言；具体有画面感）</li><li>Displays unity, progression, and coherence（统一性、递进性、连贯性）</li><li>Displays consistent facility in the use of language, demonstrating syntactic variety, appropriate word choice, and idiomaticity, though it may have minor lexical or grammatical errors.</li></ol>]]></content>
    
    
    <categories>
      
      <category>TOEFL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TOEFL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>week5-Grade2-fall</title>
    <link href="/2020/10/19/week5-Grade2-fall/"/>
    <url>/2020/10/19/week5-Grade2-fall/</url>
    
    <content type="html"><![CDATA[<h2 id="算法分析与设计"><a href="#算法分析与设计" class="headerlink" title="算法分析与设计"></a>算法分析与设计</h2><h3 id="1-并查集"><a href="#1-并查集" class="headerlink" title="1. 并查集"></a>1. 并查集</h3><h4 id="1-0-等价关系"><a href="#1-0-等价关系" class="headerlink" title="1.0 等价关系"></a>1.0 等价关系</h4><ul><li><p>自反性</p><script type="math/tex; mode=display">a \equiv a</script></li><li><p>对称性</p><script type="math/tex; mode=display">a \equiv b \Rightarrow b \equiv a</script></li><li><p>传递性</p><script type="math/tex; mode=display">a \equiv b, b \equiv c \Rightarrow a \equiv c</script></li><li><p>等价关系形成了一个划分——互不相交。</p></li></ul><h4 id="1-1-动态等价关系"><a href="#1-1-动态等价关系" class="headerlink" title="1.1 动态等价关系"></a>1.1 动态等价关系</h4><ul><li>判断是否等价；</li><li>合并两个等价关系；</li></ul><h3 id="1-2-Union-Find-的数据结构"><a href="#1-2-Union-Find-的数据结构" class="headerlink" title="1.2 Union-Find 的数据结构"></a>1.2 Union-Find 的数据结构</h3><ul><li>使用一棵树表示一个子集，子集中的元素互相等价。</li><li>真个集合划分称为互不相交的子集。</li><li>实现上：<ul><li>使用数组记住每个元素（结点）的父亲结点（的编号）。</li><li>树的根结点的父亲结点为-1。</li></ul></li></ul><h3 id="1-3-路经压缩"><a href="#1-3-路经压缩" class="headerlink" title="1.3 路经压缩"></a>1.3 路经压缩</h3><ul><li>树的形状越矮越好；</li><li>在一次find到过程中，将路径上所有的结点直接与根结点相连；</li><li>cFind花了两倍于find的时间（操作）；</li></ul><h3 id="wUnion-和-cFind-共同使用的开销"><a href="#wUnion-和-cFind-共同使用的开销" class="headerlink" title="wUnion 和 cFind 共同使用的开销"></a>wUnion 和 cFind 共同使用的开销</h3><ul><li><p><em>O</em>((<em>n</em>+<em>m</em>)<em>log<sup>\</em>&lt;/sup&gt;(n)*)</p><ul><li><p>worst case;</p></li><li><script type="math/tex; mode=display">H(0)=1</script><script type="math/tex; mode=display">H(i)=2^{H(i-1)}</script><p><em>log<sup>\</em>&lt;/sup&gt;(n)<em> = min{ </em>k<em> | H(</em>k<em>) &gt;= </em>j* }</p></li></ul></li></ul><p>有几条分界线，有几次开销。</p><h2 id="计算机组织与结构"><a href="#计算机组织与结构" class="headerlink" title="计算机组织与结构"></a>计算机组织与结构</h2><h3 id="1-内存"><a href="#1-内存" class="headerlink" title="1. 内存"></a>1. 内存</h3><ul><li>能存；</li><li>能初始化；</li><li>能够读出；</li></ul><h4 id="1-1-RAM"><a href="#1-1-RAM" class="headerlink" title="1.1 RAM"></a>1.1 RAM</h4><ul><li>读写都是简单且快速的；</li><li>但是有易失性（断电后不保存）；</li></ul><h5 id="1-1-1-DRAM"><a href="#1-1-1-DRAM" class="headerlink" title="1.1.1 DRAM"></a>1.1.1 DRAM</h5><ul><li>动态指的是：电容会有漏电的现象，需要刷新存储器中的内容，因此读写不能同时进行；</li><li>有点：成本低，集成度高；</li><li>缺点：不稳定，速度慢；</li><li>用作主存储器；</li></ul><h5 id="1-1-2-SRAM"><a href="#1-1-2-SRAM" class="headerlink" title="1.1.2 SRAM"></a>1.1.2 SRAM</h5><ul><li>缺点：集成度低，占空间；</li><li>用作Cache；</li></ul><h4 id="1-2-ROM"><a href="#1-2-ROM" class="headerlink" title="1.2 ROM"></a>1.2 ROM</h4><ul><li>只读存储器；</li><li>不需要能量来维持存储的信息；非易失；</li><li>只能写一次；通过出场设置来进行写；</li><li>安全性更好；</li></ul><h4 id="1-3-PROM"><a href="#1-3-PROM" class="headerlink" title="1.3 PROM"></a>1.3 PROM</h4><ul><li>大批量生产时，效率没有ROM高；</li><li>可编程ROM；</li><li>更加灵活和方便——个人使用；</li></ul><h4 id="1-4-Read-Mostly-Memory"><a href="#1-4-Read-Mostly-Memory" class="headerlink" title="1.4 Read-Mostly Memory"></a>1.4 Read-Mostly Memory</h4><ul><li>读操作远频繁于写操作；</li><li>非易失性存储；</li></ul><h5 id="1-4-1-EPROM"><a href="#1-4-1-EPROM" class="headerlink" title="1.4.1 EPROM"></a>1.4.1 EPROM</h5><ul><li>可擦除可编程只读存储器；</li><li>相比于PROM更贵，但是可以多次使用；</li><li>一次性擦除一整个芯片，擦除时间20分钟；</li></ul><h5 id="1-4-2-EEPROM"><a href="#1-4-2-EEPROM" class="headerlink" title="1.4.2 EEPROM"></a>1.4.2 EEPROM</h5><ul><li>电可擦除可编程只读存储器；</li><li>每次重写一个字节；</li><li>比EPROM更贵，但也有更低的集成度；</li><li>每次写操作需要几百微秒，写操作很慢；</li></ul><h4 id="1-5-Flash-Memory"><a href="#1-5-Flash-Memory" class="headerlink" title="1.5 Flash Memory"></a>1.5 Flash Memory</h4><ul><li>闪存，用于U盘。</li><li>功能性和稳定性介于EPROM和EEPROM之间；</li><li>和EPROM一样的高集成度；</li><li>可以在块级擦除，但字节不行；</li></ul><h4 id="1-6-Refreshing"><a href="#1-6-Refreshing" class="headerlink" title="1.6 Refreshing"></a>1.6 Refreshing</h4><h5 id="集中式刷新"><a href="#集中式刷新" class="headerlink" title="集中式刷新"></a>集中式刷新</h5><ul><li>刷新的过程中不能对存储器进行操作；</li><li>停止读写操作，集中刷新</li></ul><h5 id="非集中式刷新"><a href="#非集中式刷新" class="headerlink" title="非集中式刷新"></a>非集中式刷新</h5><ul><li>每次存储周期都刷新——读写周期会延长；</li></ul><h5 id="异步刷新"><a href="#异步刷新" class="headerlink" title="异步刷新"></a>异步刷新</h5><ul><li>避开现在正在使用的一行，若有一行一直都没有刷新，快到64ms都要强制刷新；</li></ul><h4 id="1-7"><a href="#1-7" class="headerlink" title="1.7"></a>1.7</h4><h5 id="1-7-1-位扩展"><a href="#1-7-1-位扩展" class="headerlink" title="1.7.1 位扩展"></a>1.7.1 位扩展</h5><ul><li>地址线没有变换；</li><li>扩展寻址单元个数——数据线增加；</li><li>用八块4K<em>1bit的芯片构成4K\</em>8的内存</li></ul><h5 id="1-7-2-增加寻址单元个数（字扩展）"><a href="#1-7-2-增加寻址单元个数（字扩展）" class="headerlink" title="1.7.2 增加寻址单元个数（字扩展）"></a>1.7.2 增加寻址单元个数（字扩展）</h5><ul><li><p>地址线增加；（2倍多一根）</p></li><li><script type="math/tex; mode=display">\lceil log_2(n) \rceil</script></li><li><p>数据线不变；</p></li><li><p>用四块16K<em>8bit的芯片来构成 64K\</em>8bit的芯片</p></li></ul><h5 id="1-73-同时扩展"><a href="#1-73-同时扩展" class="headerlink" title="1.73 同时扩展"></a>1.73 同时扩展</h5><ul><li>地址线增加；</li><li>数据线增加；</li><li>用8块16K<em>4bit的芯片来构成 64K\</em>8bit的芯片</li></ul><h3 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h3><ul><li>行列选择：选择线减少；</li><li>地址译码器；</li></ul><h3 id="2-Cache"><a href="#2-Cache" class="headerlink" title="2. Cache"></a>2. Cache</h3><h4 id="2-1-How-Cache-Works"><a href="#2-1-How-Cache-Works" class="headerlink" title="2.1 How Cache Works?"></a>2.1 How Cache Works?</h4><ul><li>Check</li><li>Hit</li><li>Miss</li></ul><h4 id="2-2-局部性原理"><a href="#2-2-局部性原理" class="headerlink" title="2.2 局部性原理"></a>2.2 局部性原理</h4><ul><li>空间局部性；</li><li>时间局部性；</li></ul><h4 id="2-3-Average-Access-Time"><a href="#2-3-Average-Access-Time" class="headerlink" title="2.3 Average Access Time"></a>2.3 Average Access Time</h4><ul><li><script type="math/tex; mode=display">T_A = p ×T_C+(1-p)×(T_C + T_M)</script></li><li><script type="math/tex; mode=display">T_A = T_C + (1-p)×T_M</script></li><li><script type="math/tex; mode=display">T_A < T_M， p>\frac{T_C}{T_M}</script></li></ul><h4 id="2-4-Elements-of-Cache-Design"><a href="#2-4-Elements-of-Cache-Design" class="headerlink" title="2.4 Elements of Cache Design"></a>2.4 Elements of Cache Design</h4><ul><li><p>Cache Size 越大越好？</p><ul><li>不是，变好的幅度会越来越小。“局部性”，并不会牵扯到太大的范围，并且块越大块内寻找的成本就会越高。块太大了之后，带来的数据是局部性比较差的、比较老的数据。</li></ul></li><li><p>Mapping Function</p><ul><li>Cache line</li><li>直接映射 Direct Mapping<ul><li>地址 = Tag + 行号 + 块内地址；<ul><li>先根据行号找到Cache对应的行，然后比对tag，若不相同则miss，否则根据块内地址选择对应的字节。若miss，根据tag+行号找到主存储器中的内容（低几位）相同，将内容放入cache并且重写tag，将放入内容（根据块内地址查找）送入cpu。</li></ul></li><li>每个块只能存入一个地方。查找很快。映射的时候也很快，每个块只有一个地方可以去。换的也快。</li><li>缺点：很容易引起“抖动（Thrashing）”。Cache小的时候容易引起抖动。换一个（很容易出现这个情况）就会换一整个块。</li></ul></li><li>关联映射 Associative Mapping<ul><li>地址 = Tag + 块内地址；</li><li>根据tag寻找（遍历）</li><li>避免了抖动，但是实现相对复杂，寻找的成本比较高。</li></ul></li><li>直接映射适合大容量cache，关联映射适合小的；<ul><li>大容量cache不容易出现抖动。</li><li>直接映射查找快，大cache影响小；关联映射遍历查找，小cache效率更高。</li></ul></li><li>组关联 Set Associative Mapping<ul><li>行的大小和块的大小一样大。</li><li>优点：在固定的组里进行操作；</li></ul></li><li>相关性：<ul><li>直接关联：1；</li><li>关联映射：C；</li><li>组关联：K；</li><li>相关性越低，命中率越低，cache越短。</li></ul></li></ul></li></ul><h4 id="替换算法"><a href="#替换算法" class="headerlink" title="替换算法"></a>替换算法</h4><ul><li>LRU 最近最少用算法；</li><li>FIFO 先进先出；</li><li>LFU 使用频率最少；</li><li>Random 随机。</li></ul><h4 id="写策略"><a href="#写策略" class="headerlink" title="写策略"></a>写策略</h4><ul><li><p>Write Through</p><ul><li>替换的时候同时写主存和Cache；</li><li>一改就要访问主存；</li><li>提高了cache和主存的一致性；</li></ul></li><li><p>Write Back</p><ul><li>只修改Cache。当块被替换的时候；</li><li>需要一个脏位来表示这一个块是否被调整过；如果是1就写回去，如果是0就替换掉；</li><li>优点：减少对主存的操作到最小的程度；</li></ul></li></ul><h4 id="行的大小"><a href="#行的大小" class="headerlink" title="行的大小"></a>行的大小</h4><p>行的大小会影响Cache的命中率；块太小，一次性拿进来的东西太少，块太大，拿进来没用的东西太多，减少行数会造成更换过于频繁。</p><h4 id="多级Cache"><a href="#多级Cache" class="headerlink" title="多级Cache"></a>多级Cache</h4>]]></content>
    
    
    <categories>
      
      <category>WeeklyReview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WeeklyReview</tag>
      
      <tag>并查集</tag>
      
      <tag>内存</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>brief-introduction-of-VM</title>
    <link href="/2020/10/16/brief-introduction-of-VM/"/>
    <url>/2020/10/16/brief-introduction-of-VM/</url>
    
    <content type="html"><![CDATA[<h1 id="Brief-Introduction-of-VM"><a href="#Brief-Introduction-of-VM" class="headerlink" title="Brief Introduction of VM"></a>Brief Introduction of VM</h1><h2 id="1-虚拟机简介"><a href="#1-虚拟机简介" class="headerlink" title="1. 虚拟机简介"></a>1. 虚拟机简介</h2><p>虚拟机是一个计算系统。计算系统的最终目标是执行预先编程的逻辑。</p><h3 id="1-1-虚拟机类型"><a href="#1-1-虚拟机类型" class="headerlink" title="1.1 虚拟机类型"></a>1.1 虚拟机类型</h3><ul><li>1⃣️ <strong>完整指令集架构（ISA）虚拟机</strong>，提供<strong>完整的计算机系统ISA模拟或虚拟化</strong>。（例如VitualBox、QEMU等等）</li><li>2⃣️ <strong>应用程序二进制接口（ABI）虚拟机</strong>，<strong>提供客户进程ABI模拟</strong>。</li><li>3⃣️ <strong>虚拟ISA虚拟机</strong>，提供一个运行时引擎，以便虚拟ISA编码的应用程序在其上执行。虚拟ISA通常定义了一套高层的、规模有限的ISA语义，所以不需要虚拟机模拟完整的计算机系统。（例如JVM等等）</li><li>4⃣️ <strong>语言虚拟机</strong>，提供一个运行时引擎来执行以客户语言编写的程序。程序通常以源码形式提供给虚拟机，并没有预先完成编译为机器码。运行时引擎需要解释或翻译程序等。（例如Lisp、Ruby的运行时引擎）</li></ul><p>前两种虚拟机有时被称为“模拟器”。另外两种虚拟机是语言运行时引擎。</p><h3 id="1-2-为什么需要虚拟机"><a href="#1-2-为什么需要虚拟机" class="headerlink" title="1.2 为什么需要虚拟机"></a>1.2 为什么需要虚拟机</h3><ul><li><p>虚拟机改善了（计算机）安全性、（程序）效率和（应用程序）可移植性。</p></li><li><p>对于安全语言（提供了内存安全、运算安全和控制安全特性），虚拟机上必要的。通过安全语言，能尽早安全地捕获程序bug或运行错误。</p><ul><li>内存安全：确保内存中某类型的数据总是遵循对这种类型的限制。</li><li>运算安全：确保对某种类型数据的运算总是遵循对这种类型的限制。</li><li>控制安全：确保代码执行流既不会卡住也不会跑飞。</li></ul><p>安全语言本身并不能满足所有的安全需求。（例如，程序需要虚拟机为它分配一块带有类型的内存，例如某种类型的对象）如果没有虚拟机，安全语言必须引入非安全的操作支持。</p></li><li><p>虚拟机为安全语言的代码和数据提供“托管”。</p></li><li><p>因为安全语言能在编译时或运行时尽早安全地捕获程序中的BUG。因此，提高了开发者的生产率。</p></li></ul><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ul><li>应用程序提供给JVM之后，<strong>JVM的类加载器加载并解析初始类文件，然后把项目放在内存中相应的数据结构中。接下来，JVM把所有的符号饮用解析到直接引用的内存地址。类初始化之后（即调用初始化器之后），JVM调用初始类的main()方法来执行这个应用程序。</strong></li></ul><h2 id="JVM调试——OpenJDK的安装以及Clion配合使用"><a href="#JVM调试——OpenJDK的安装以及Clion配合使用" class="headerlink" title="JVM调试——OpenJDK的安装以及Clion配合使用"></a>JVM调试——OpenJDK的安装以及Clion配合使用</h2><p>主要参考的blog有：</p><ul><li><a href="https://jishuin.proginn.com/p/763bfbd28c57">在MacOS系统上编译OpenJDK12并使用CLion调试</a></li><li><a href="https://blog.csdn.net/zy353003874/article/details/107555072">费尽九牛二虎之力，终于我成功编译并调试了JVM</a></li><li><a href="https://www.jianshu.com/p/ee7e9176632c">mac下编译openjdk1.9及集成clion动态调试</a></li><li><a href="https://blog.jetbrains.com/clion/2020/03/openjdk-with-clion/">Clion官方手册：Develop OpenJDK in CLion with Pleasure</a></li></ul><p>下面要进入真正的学习了( ´▽` )ﾉ</p>]]></content>
    
    
    <categories>
      
      <category>VM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>week4_Grade2_fall</title>
    <link href="/2020/10/16/week4-Grade2-fall/"/>
    <url>/2020/10/16/week4-Grade2-fall/</url>
    
    <content type="html"><![CDATA[<h2 id="计算机组织与结构"><a href="#计算机组织与结构" class="headerlink" title="计算机组织与结构"></a>计算机组织与结构</h2><h3 id="1-编程作业分析【尽可能不使用API】"><a href="#1-编程作业分析【尽可能不使用API】" class="headerlink" title="1. 编程作业分析【尽可能不使用API】"></a>1. 编程作业分析【尽可能不使用API】</h3><h4 id="1-1-整数int转化为二进制形式"><a href="#1-1-整数int转化为二进制形式" class="headerlink" title="1.1 整数int转化为二进制形式"></a>1.1 整数int转化为二进制形式</h4><ul><li>整数有32位，其中第一位（最左位）位符号位。</li><li>负数的符号位为“1”，与相对应的正数之间的关系为“取反加一”。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">intToBinary</span><span class="hljs-params">(String numStr)</span> </span>&#123;  <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span></span>  <span class="hljs-keyword">int</span> num = Integer.parseInt(numStr);  <span class="hljs-keyword">int</span> sign = <span class="hljs-number">0</span>;  <span class="hljs-keyword">if</span>(num &lt; <span class="hljs-number">0</span>)&#123;    sign = <span class="hljs-number">1</span>;    num = -num;  &#125;  <span class="hljs-keyword">char</span>[] binaryStr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">32</span>];  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">31</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;    <span class="hljs-keyword">if</span>(num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;      binaryStr[i] = <span class="hljs-string">&#x27;0&#x27;</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      binaryStr[i] = <span class="hljs-string">&#x27;1&#x27;</span>;    &#125;    num /= <span class="hljs-number">2</span>;  &#125;  <span class="hljs-comment">//deal with negative numbers</span>  <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">1</span>)&#123;    <span class="hljs-keyword">int</span> index = <span class="hljs-number">31</span>;    <span class="hljs-keyword">int</span> flg = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(; index&gt;=<span class="hljs-number">0</span>; index--)&#123;      <span class="hljs-keyword">if</span> (flg == <span class="hljs-number">1</span>)&#123;        binaryStr[index] = (binaryStr[index]==<span class="hljs-string">&#x27;1&#x27;</span>)? <span class="hljs-string">&#x27;0&#x27;</span>:<span class="hljs-string">&#x27;1&#x27;</span>;      &#125;      <span class="hljs-keyword">if</span>(binaryStr[index]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;        flg = <span class="hljs-number">1</span>;      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> String.valueOf(binaryStr);&#125;</code></pre><p>​       以上的操作比较简单，主要是把整数字符串转换为整数，再进行“除二取余”的操作。特别的，对于负数再进行一次“取反加一”的操作。这里没有直接用取反操作符，而是使用了<strong>“从末尾的0起到第一个1不变，下一位到起始处取反”</strong>的操作。</p><h4 id="1-2-二进制形式转化为整数int"><a href="#1-2-二进制形式转化为整数int" class="headerlink" title="1.2 二进制形式转化为整数int"></a>1.2 二进制形式转化为整数int</h4><ul><li>与上面的操作相对应。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">binaryToInt</span><span class="hljs-params">(String binStr)</span> </span>&#123;  <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span></span>  <span class="hljs-keyword">char</span>[] bits = binStr.toCharArray();  <span class="hljs-keyword">char</span> sign = bits[<span class="hljs-number">0</span>];  <span class="hljs-keyword">if</span>(sign == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;    <span class="hljs-keyword">int</span> index = <span class="hljs-number">31</span>;    <span class="hljs-keyword">int</span> flg = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(; index&gt;=<span class="hljs-number">0</span>; index--)&#123;      <span class="hljs-keyword">if</span> (flg == <span class="hljs-number">1</span>)&#123;        bits[index] = (bits[index]==<span class="hljs-string">&#x27;1&#x27;</span>)? <span class="hljs-string">&#x27;0&#x27;</span>:<span class="hljs-string">&#x27;1&#x27;</span>;      &#125;      <span class="hljs-keyword">if</span>(bits[index]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;        flg = <span class="hljs-number">1</span>;      &#125;    &#125;  &#125;  <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;  <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">31</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;    <span class="hljs-keyword">if</span>(bits[i] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;      ans += num;    &#125;    num &lt;&lt;= <span class="hljs-number">1</span>;  &#125;  <span class="hljs-keyword">if</span>(sign == <span class="hljs-string">&#x27;1&#x27;</span>) ans = -ans;  <span class="hljs-keyword">return</span> String.valueOf(ans);&#125;</code></pre><p>​       对1.1中的操作进行逆操纵，先对负数取反加一。然后根据</p><script type="math/tex; mode=display">S = \sum_{i=0}^{n}2^i×s</script><p>求得int的绝对值，在最后根据符号位补上符号。</p><h4 id="1-3-浮点数转二进制【最麻烦的部分】"><a href="#1-3-浮点数转二进制【最麻烦的部分】" class="headerlink" title="1.3 浮点数转二进制【最麻烦的部分】"></a>1.3 浮点数转二进制【最麻烦的部分】</h4><ul><li>浮点数的二进制表示有三个部分——符号（sign）、阶码（exponent）、尾数（fraction）</li><li>浮点数有规格化和非规格化之分；</li><li>在编写的过程中最好参考表格：</li><li><img src="/img/浮点数解释.png" alt=""></li><li>相信有更好的写法！</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">floatToBinary</span><span class="hljs-params">(String floatStr)</span> </span>&#123;  <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span></span>  String sign = <span class="hljs-string">&quot;0&quot;</span>;  String expStr;  String fracStr;  <span class="hljs-keyword">int</span> exponent = <span class="hljs-number">127</span>;  <span class="hljs-keyword">float</span> num = Float.parseFloat(floatStr);  <span class="hljs-keyword">if</span>(num &lt; <span class="hljs-number">0</span>)&#123;    sign = <span class="hljs-string">&quot;1&quot;</span>;    num = -num;  &#125;  <span class="hljs-keyword">while</span> (num-<span class="hljs-number">2</span> &gt; <span class="hljs-number">0</span>)&#123;    num /= <span class="hljs-number">2</span>;    exponent++;    <span class="hljs-keyword">if</span>(exponent == <span class="hljs-number">255</span>) <span class="hljs-keyword">break</span>;  &#125;  <span class="hljs-keyword">while</span> (num-<span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>)&#123;    num *= <span class="hljs-number">2</span>;    exponent--;    <span class="hljs-keyword">if</span>(exponent &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;  &#125;    <span class="hljs-keyword">if</span>(exponent &lt; <span class="hljs-number">1</span>)&#123;    expStr = <span class="hljs-string">&quot;00000000&quot;</span>;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exponent == <span class="hljs-number">255</span>)&#123;    expStr = <span class="hljs-string">&quot;11111111&quot;</span>;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">int</span> expTmp = exponent;    StringBuilder expBuilder = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">8</span>; i++)&#123;      <span class="hljs-keyword">if</span>(expTmp % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;        expBuilder.insert(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;1&quot;</span>);      &#125; <span class="hljs-keyword">else</span> &#123;        expBuilder.insert(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;0&quot;</span>);      &#125;      expTmp /= <span class="hljs-number">2</span>;    &#125;    expStr = expBuilder.toString();  &#125;  <span class="hljs-keyword">double</span> f = num - <span class="hljs-number">1</span>;  StringBuilder fracBuilder = <span class="hljs-keyword">new</span> StringBuilder();  <span class="hljs-keyword">if</span>(exponent == <span class="hljs-number">255</span>)&#123;    fracBuilder.append(<span class="hljs-string">&quot;00000000000000000000000&quot;</span>);  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">if</span>(exponent == <span class="hljs-number">0</span>)&#123;      f = num / <span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">while</span> (f &gt; <span class="hljs-number">0</span>)&#123;      f *= <span class="hljs-number">2</span>;      <span class="hljs-keyword">if</span>(f &gt;= <span class="hljs-number">1</span>)&#123;        fracBuilder.append(<span class="hljs-string">&quot;1&quot;</span>);        f -= <span class="hljs-number">1</span>;      &#125; <span class="hljs-keyword">else</span> &#123;        fracBuilder.append(<span class="hljs-string">&quot;0&quot;</span>);      &#125;    &#125;    <span class="hljs-keyword">int</span> pending = <span class="hljs-number">23</span>-fracBuilder.length();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;pending; i++)&#123;      fracBuilder.append(<span class="hljs-string">&quot;0&quot;</span>);    &#125;  &#125;  fracStr = fracBuilder.toString();  String ans = sign + expStr + fracStr;  <span class="hljs-comment">//下面几行有点奇怪，貌似是为了过oj而加入的，实际上不应该存在。</span>  <span class="hljs-keyword">if</span>(ans.equals(<span class="hljs-string">&quot;01111111100000000000000000000000&quot;</span>))&#123;    ans = <span class="hljs-string">&quot;+Inf&quot;</span>;  &#125;  <span class="hljs-keyword">if</span>(ans.equals(<span class="hljs-string">&quot;11111111100000000000000000000000&quot;</span>))&#123;    ans = <span class="hljs-string">&quot;-Inf&quot;</span>;  &#125;  <span class="hljs-keyword">return</span> ans;&#125;</code></pre><p>在这段代码中可以看到许多的特判（负数、无穷、溢出等等）。并且用到了许多浮点数比较（这是不好的习惯，但是不得已而为之）。</p><p>主要思路是：</p><p>1⃣️ 首先将负数的符号位设置好，并取它的绝对值。</p><p>2⃣️ 以规格化浮点数为界限，将<strong>整数部分大于等于2（即不是1的）</strong>和<strong>整数部分小于1（即也不是1的，而是0的）</strong>的进行规约。在这里需要注意的是，阶码是有上下界限的，一旦达到255或0，需要终止循环，这个时候得到的数值很可能是【无穷】、【0】、【非规格化浮点数】等等。</p><p>3⃣️ 算阶码部分：如果阶码=0直接置为“00000000”，阶码为255直接置为“11111111”，其余的按照转换为无符号整数的方法直接转化。</p><p>4⃣️ 规约结束，取浮点数的小数部分。在这里需要注意！有一个坑：对于2<sup>-127</sup>来说，它是非规格化的，需要用 2<sup>-126</sup>×0.5来表示。<em>【对于其他的非规格化数也同样如此，因为-126的缘故，我们在上面一步中的规约对于非规格化数其实是多乘来一个2。这样做的目的是使非规格化数和规格化数能够平滑过度】</em>因此，我们需要一个特判，如果阶码为0，那么我们需要把数次乘2之后的num除以一个2，<strong>为了补上-127转化到-126的坑</strong>。然后再进行尾数部分的转化——“乘二取整”，最后补齐23位。对于阶码为255的数，直接将尾数置为全0（无穷）。</p><p>5⃣️ 最后一步修正，将符号位、阶码和尾数三部分字符串组合起来，将正负无穷分别以“+Inf”和“-Inf”的形式表示。</p><h4 id="1-4-二进制转化为浮点数"><a href="#1-4-二进制转化为浮点数" class="headerlink" title="1.4 二进制转化为浮点数"></a>1.4 二进制转化为浮点数</h4><ul><li>这个题有点问题，明明是float，在oj判断的时候精度用的是double【吐槽】。但思路整体上是一样。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">binaryToFloat</span><span class="hljs-params">(String binStr)</span> </span>&#123;  <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span></span>  String sign = binStr.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);  String exponent = binStr.substring(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>);  String fraction = binStr.substring(<span class="hljs-number">9</span>, <span class="hljs-number">32</span>);  String ans = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">if</span>(exponent.equals(<span class="hljs-string">&quot;00000000&quot;</span>) &amp;&amp; fraction.equals(<span class="hljs-string">&quot;00000000000000000000000&quot;</span>))&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0.0&quot;</span>;  &#125;  <span class="hljs-keyword">int</span> exp = str2int(exponent, <span class="hljs-number">8</span>);  <span class="hljs-keyword">double</span> frac = <span class="hljs-number">0.0</span>;  <span class="hljs-keyword">if</span>( exp &gt; <span class="hljs-number">0</span> &amp;&amp; exp &lt; <span class="hljs-number">255</span> )&#123;    frac += str2flt(fraction);    frac += <span class="hljs-number">1</span>;    ans = Double.toString((frac * Math.pow(<span class="hljs-number">2</span>, exp-<span class="hljs-number">127</span>)));  &#125;  <span class="hljs-keyword">if</span>( exp == <span class="hljs-number">255</span> &amp;&amp; fraction.equals(<span class="hljs-string">&quot;00000000000000000000000&quot;</span>))&#123;    ans = <span class="hljs-string">&quot;Inf&quot;</span>;    <span class="hljs-keyword">if</span>(sign.equals(<span class="hljs-string">&quot;0&quot;</span>))&#123;      ans = <span class="hljs-string">&quot;+&quot;</span> + ans;    &#125;  &#125;  <span class="hljs-keyword">if</span>( exp == <span class="hljs-number">255</span> &amp;&amp; !fraction.equals(<span class="hljs-string">&quot;00000000000000000000000&quot;</span>))&#123;    ans = <span class="hljs-string">&quot;NaN&quot;</span>;  &#125;  <span class="hljs-keyword">if</span>( exp == <span class="hljs-number">0</span> )&#123;    frac += str2flt(fraction);    ans = Double.toString((frac * Math.pow(<span class="hljs-number">2</span>, exp-<span class="hljs-number">126</span>)));  &#125;  <span class="hljs-keyword">if</span>(sign.equals(<span class="hljs-string">&quot;1&quot;</span>))&#123;    ans = <span class="hljs-string">&quot;-&quot;</span> + ans;  &#125;  <span class="hljs-keyword">return</span> ans;&#125;</code></pre><p>主要思路：</p><p>1⃣️ 特判0；</p><p>2⃣️ 在这里封装了两个函数：将字符串转化为无符号整数，和字符串转化为浮点数。用到的就是之前的“除二取余”和“乘二取整”。</p><p>3⃣️ 根据符号位判断正负。</p><p>4⃣️ 这里的逻辑就简单了很多，根据表判断就可以——规格化数的时候是 2<sup>-127</sup>×(1.<em>f</em>)；正负无穷返回+/-Inf；还有NaN和非规格化数，最后不要忘记补上符号。</p><h4 id="1-5-十进制转化为NBCD"><a href="#1-5-十进制转化为NBCD" class="headerlink" title="1.5 十进制转化为NBCD"></a>1.5 十进制转化为NBCD</h4><ul><li>0～9对应0000～1001，正号用1100，负号用1101。</li><li>共有32位，即8个四位组合，如果不够需要补齐。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">decimalToNBCD</span><span class="hljs-params">(String decimal)</span> </span>&#123;  <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span></span>  <span class="hljs-keyword">char</span>[] numLst = decimal.toCharArray();  StringBuilder ansBuilder = <span class="hljs-keyword">new</span> StringBuilder();  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;  <span class="hljs-keyword">if</span>(numLst[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>)&#123;    ansBuilder.append(<span class="hljs-string">&quot;1101&quot;</span>);    i = <span class="hljs-number">1</span>;  &#125; <span class="hljs-keyword">else</span> &#123;    ansBuilder.append(<span class="hljs-string">&quot;1100&quot;</span>);  &#125;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">7</span>-numLst.length+i;j++)&#123;    ansBuilder.append(<span class="hljs-string">&quot;0000&quot;</span>);  &#125;  String BCD = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">for</span>(; i&lt;numLst.length; i++)&#123;    <span class="hljs-keyword">switch</span> (numLst[i])&#123;      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;0&#x27;</span>:        BCD = <span class="hljs-string">&quot;0000&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:        BCD = <span class="hljs-string">&quot;0001&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:        BCD = <span class="hljs-string">&quot;0010&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;3&#x27;</span>:        BCD = <span class="hljs-string">&quot;0011&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;4&#x27;</span>:        BCD = <span class="hljs-string">&quot;0100&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;5&#x27;</span>:        BCD = <span class="hljs-string">&quot;0101&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;6&#x27;</span>:        BCD = <span class="hljs-string">&quot;0110&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;7&#x27;</span>:        BCD = <span class="hljs-string">&quot;0111&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;8&#x27;</span>:        BCD = <span class="hljs-string">&quot;1000&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;9&#x27;</span>:        BCD = <span class="hljs-string">&quot;1001&quot;</span>; <span class="hljs-keyword">break</span>;    &#125;    ansBuilder.append(BCD);  &#125;  <span class="hljs-keyword">return</span> ansBuilder.toString();&#125;</code></pre><p>主要思路：单纯根据每个数字和符号取对应的BCD表示，需要注意的是补上0000满足位数的要求。总体来说相对简单。</p><h4 id="1-6-NBCD转化为十进制数"><a href="#1-6-NBCD转化为十进制数" class="headerlink" title="1.6 NBCD转化为十进制数"></a>1.6 NBCD转化为十进制数</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">NBCDToDecimal</span><span class="hljs-params">(String NBCDStr)</span> </span>&#123;  <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span></span>  StringBuilder strBuilder = <span class="hljs-keyword">new</span> StringBuilder();  String BCD = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;NBCDStr.length()-<span class="hljs-number">3</span>; i+=<span class="hljs-number">4</span>)&#123;    String swt = NBCDStr.substring(i, i+<span class="hljs-number">4</span>);    <span class="hljs-keyword">switch</span> (swt)&#123;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;0000&quot;</span>:        BCD = <span class="hljs-string">&quot;0&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;0001&quot;</span>:        BCD = <span class="hljs-string">&quot;1&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;0010&quot;</span>:        BCD = <span class="hljs-string">&quot;2&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;0011&quot;</span>:        BCD = <span class="hljs-string">&quot;3&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;0100&quot;</span>:        BCD = <span class="hljs-string">&quot;4&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;0101&quot;</span>:        BCD = <span class="hljs-string">&quot;5&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;0110&quot;</span>:        BCD = <span class="hljs-string">&quot;6&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;0111&quot;</span>:        BCD = <span class="hljs-string">&quot;7&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;1000&quot;</span>:        BCD = <span class="hljs-string">&quot;8&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;1001&quot;</span>:        BCD = <span class="hljs-string">&quot;9&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;1100&quot;</span>:        BCD = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;1101&quot;</span>:        BCD = <span class="hljs-string">&quot;-&quot;</span>; <span class="hljs-keyword">break</span>;    &#125;    strBuilder.append(BCD);  &#125;  <span class="hljs-keyword">while</span> (strBuilder.indexOf(<span class="hljs-string">&quot;0&quot;</span>)==<span class="hljs-number">0</span> &amp;&amp; strBuilder.length()&gt;<span class="hljs-number">1</span>)&#123;    strBuilder.delete(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);  &#125;  <span class="hljs-keyword">while</span> (strBuilder.indexOf(<span class="hljs-string">&quot;-&quot;</span>)==<span class="hljs-number">0</span> &amp;&amp; strBuilder.indexOf(<span class="hljs-string">&quot;0&quot;</span>)==<span class="hljs-number">1</span> &amp;&amp; strBuilder.length()&gt;<span class="hljs-number">1</span>)&#123;    strBuilder.delete(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  &#125;  <span class="hljs-keyword">return</span> strBuilder.toString();&#125;</code></pre><p>主要思路：每四个进行对应，将其转化为十进制的字符串。需要注意的是！因为32位的NBCD码要求，一些数字字符串中会有无用的0产生。需要将它们去除掉，在这里我使用的是——【对正数：第一位为0就去掉；对负数：当第一位为‘-’，第二位为0就去掉第二位的0。进行循环。】</p><p>总体来说，这次的作业有不少细节需要注意，会有一些小的细节的坑需要规避。比如浮点数转化为二进制字符串，如果不对太大的数字进行无穷的转换，就很可能在代码中产生死循环。以及负数的考虑：负数乘2再减1在数轴上会越来越偏离原点，导致死循环！还有规格化数到非规格化数到跳跃也是值得注意的重难点。</p><h2 id="算法设计与分析"><a href="#算法设计与分析" class="headerlink" title="算法设计与分析"></a>算法设计与分析</h2><h3 id="1-Hashing"><a href="#1-Hashing" class="headerlink" title="1. Hashing"></a>1. Hashing</h3><ul><li>Hashing的开销——几乎常量时间：O(1+α)</li></ul><h4 id="1-1-Collision-Handling"><a href="#1-1-Collision-Handling" class="headerlink" title="1.1 Collision Handling"></a>1.1 Collision Handling</h4><h5 id="1-1-Closed-Address"><a href="#1-1-Closed-Address" class="headerlink" title="1.1 Closed Address"></a>1.1 Closed Address</h5><ul><li><p>list在某一个空间的平均长度为<em>n</em>/<em>m</em>；</p></li><li><p>总共开销：Θ(1+ <em>n</em>/<em>m</em>)</p></li><li><p><strong>分析</strong>：对于一次成功的搜索，x<sub>i</sub>的可能性为1/n。对于给定的x<sub>i</sub>，被检测到的元素为<em>t+1</em>次（<em>t</em>是被插入同一个区域的元素数）。对于任意j，x<sub>j</sub>被插入同一个地方的可能性是<em>1/m</em>，因此花销为：</p><script type="math/tex; mode=display">1+\frac{1}{n}\sum_{i=1}^n(1+\sum_{j=i+1}^{n}\frac{1}{m})</script><p>1/m的和是“在要搜索的元素之前的链表中的元素数量”。计算结果大致是：</p><script type="math/tex; mode=display">\Theta(1+\alpha)</script></li></ul><h5 id="1-2-Open-Address"><a href="#1-2-Open-Address" class="headerlink" title="1.2 Open Address"></a>1.2 Open Address</h5><ul><li>不使用链表，所有的元素都存在哈希表中。</li><li>用”rehashing”来解决冲突。</li></ul><h5 id="1-3-Array-Doubling"><a href="#1-3-Array-Doubling" class="headerlink" title="1.3 Array Doubling"></a>1.3 Array Doubling</h5><ul><li><p>allocate a block of size <em>2size</em>; move all item into new table;</p></li><li><p>花销：size</p></li><li><p>执行n次操作，总共花销：</p><script type="math/tex; mode=display">\sum_{i=1}^nc_i{\leq}n+\sum_{j=0}^{log{n}}2^j<3n</script></li><li><p>每一个doubling的操作可以均摊到前面的每一次插入，足够多的准备。（均摊分析）</p></li></ul><h5 id="1-4-Amortized-Analysis"><a href="#1-4-Amortized-Analysis" class="headerlink" title="1.4 Amortized Analysis"></a>1.4 Amortized Analysis</h5><ul><li><em>amortized cost = actual cost + accounting cost</em></li></ul>]]></content>
    
    
    <categories>
      
      <category>WeeklyReview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WeeklyReview</tag>
      
      <tag>计组作业</tag>
      
      <tag>Hashing</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>week3_Grade2_fall</title>
    <link href="/2020/09/26/week3-Grade2-fall/"/>
    <url>/2020/09/26/week3-Grade2-fall/</url>
    
    <content type="html"><![CDATA[<h2 id="算法设计与分析"><a href="#算法设计与分析" class="headerlink" title="算法设计与分析"></a>算法设计与分析</h2><h3 id="1-红黑树"><a href="#1-红黑树" class="headerlink" title="1. 红黑树"></a>1. 红黑树</h3><p><a href="https://www.jianshu.com/p/e136ec79235c">30张图彻底理解红黑树</a></p><h4 id="1-1-红黑树定义"><a href="#1-1-红黑树定义" class="headerlink" title="1.1 红黑树定义"></a>1.1 红黑树定义</h4><ul><li>基本限制：<ul><li>满足二叉搜索树；</li><li>每个节点要么是黑色的，要么是红色的；</li><li>所有的外部节点都是黑色的（每个叶子结点【NIL】是黑色）；</li><li>颜色限制：红色结点没有红色的子节点（每个红色结点的两个子节点一定都是黑色的）；</li><li>黑色高度限制：每个从给定结点u到外部节点的路径的黑色长度相等。（任意一结点到每个叶子结点到路径都包含数量相同的黑结点）<ul><li>推论：如果一个结点存在黑子节点，那么该结点肯定有两个子节点；</li></ul></li><li>根结点是黑色的；</li></ul></li><li>ARB tree (Almost-red-black tree)<ul><li>根结点是红色的；</li></ul></li><li>递归定义<ul><li>约定高度为h的红黑树为RB<sub>h</sub>，高度为h的Almost-red-black Tree为ARB<sub>h</sub></li><li>一个二叉树是ARB<sub>h</sub>，那么<ul><li>根结点是红色的；</li><li>左右子树都是RB<sub>h-1</sub></li></ul></li><li>一个二叉树是RB<sub>h</sub>，那么<ul><li>根结点是黑色的；</li><li>左右子树是RB<sub>h-1</sub>或ARB<sub>h</sub></li></ul></li></ul></li></ul><h4 id="1-2-红黑树的插入"><a href="#1-2-红黑树的插入" class="headerlink" title="1.2 红黑树的插入"></a>1.2 红黑树的插入</h4><ul><li>```c++<br>RBtree rbtInset(RBtree oldRBtree, Element newElement){<br>  InsReturn ans = rbtIns(oldRBtree, newNode);<br>  if(ans.newTree.color != black){<pre><code>ans.newTree.color = black; //黑高度增加的途径。</code></pre>  }<br>  return ans.newTree;<br>}<pre><code class="hljs xl">- **插入红色结点不会影响黑色高度限制**；【每次插入都不改变黑高度】- 簇：一个黑色结点和所有可从该黑色结点经由非黑色边达到的红色结点组成的集合，称为**簇**。- 冲突簇（Critical cluster）：起因于<span class="hljs-number">3</span>或<span class="hljs-number">4</span>个红色结点的颜色冲突。如果存在一个从根结点开始到达某结点的通路的长度大于<span class="hljs-number">1</span>，那么这个簇称为**冲突簇**。因为一个簇中的所有边都是非黑边，那么存在一条长度为<span class="hljs-number">2</span>的通路说明簇中一个红色结点与另一个红色结点之间有一条边。- 颜色漂移（Color flip）：冲突簇的根结点和它的子结点变换颜色，当没有新的冲突簇出现时，插入结束。（教材原话：We perform a *<span class="hljs-built_in">color</span> flip* <span class="hljs-keyword">with</span> the root of the cluster, call it *r*, <span class="hljs-built_in">and</span> its two children.）对于三个结点的冲突簇情况不能使用颜色漂移。【三个结点的情况使得中间那个结点变为黑色】  - ```c++    void rb_tree_main::colorFlip(rb_tree * old_tree)&#123;      <span class="hljs-comment">//修改根结点的颜色</span>      <span class="hljs-function"><span class="hljs-title">if</span>(old_tree-&gt;</span><span class="hljs-built_in">color</span> == color_black)&#123;        <span class="hljs-function"><span class="hljs-title">old_tree</span>-&gt;</span><span class="hljs-built_in">color</span> = color_red;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-function"><span class="hljs-title">old_tree</span>-&gt;</span><span class="hljs-built_in">color</span> = color_black;      &#125;            <span class="hljs-comment">//修改根的左子结点的颜色</span>      <span class="hljs-function"><span class="hljs-title">if</span>(old_tree-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span>-&gt;</span><span class="hljs-built_in">color</span> == color_black)&#123;        <span class="hljs-function"><span class="hljs-title">old_tree</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span>-&gt;</span><span class="hljs-built_in">color</span> = color_red;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-function"><span class="hljs-title">old_tree</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span>-&gt;</span><span class="hljs-built_in">color</span> = color_black;      &#125;            <span class="hljs-comment">//修改根的右子节点的颜色</span>      <span class="hljs-function"><span class="hljs-title">if</span>(old_tree-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span>-&gt;</span><span class="hljs-built_in">color</span> == color_clack)&#123;        <span class="hljs-function"><span class="hljs-title">old_tree</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span>-&gt;</span><span class="hljs-built_in">color</span> = color_red;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-function"><span class="hljs-title">old_tree</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span>-&gt;</span><span class="hljs-built_in">color</span> = color_black;      &#125;    &#125;</code></pre></li></ul><h4 id="1-3-修正红黑树（RepairLeft-和-RepairRight）"><a href="#1-3-修正红黑树（RepairLeft-和-RepairRight）" class="headerlink" title="1.3 修正红黑树（RepairLeft 和 RepairRight）"></a>1.3 修正红黑树（RepairLeft 和 RepairRight）</h4><ul><li><p>ok：不需要修正；</p><ul><li>```c++<br>if(ansLeft.status == status.ok){<br>  ans.new_tree = old_tree;<br>  ans.status = status.ok;<br>  return ans<br>}<br>old_tree-&gt;left = ansLeft.new_tree;<pre><code class="hljs fortran">- rbr：不要调整；要将返回值存入相应的field。  - ```c++    <span class="hljs-keyword">if</span>(ansLeft<span class="hljs-number">.</span><span class="hljs-keyword">status</span> == <span class="hljs-keyword">status</span><span class="hljs-number">.</span>rbr)&#123;      ans<span class="hljs-number">.</span>new_tree = old_tree;      ans<span class="hljs-number">.</span><span class="hljs-keyword">status</span> = <span class="hljs-keyword">status</span><span class="hljs-number">.</span>ok;    &#125;</code></pre></li></ul></li><li><p>brb：如果父结点是黑色的，不修正；否则需要向上调整（若当前不调整，返回的状态为rrb）</p><ul><li>```c++<br>if(ansLeft.status == status.brb){<br>  ans.new_tree = old_tree;<br>  if(old_tree-&gt;color == color_black){<pre><code>ans.status = status.ok;</code></pre>  } else {<pre><code>ans.status = status_rrb;</code></pre>  }<br>}<pre><code class="hljs maxima">- rrb：【**当前的父结点的颜色一定为黑色**】根据oldTree的右（左）子节点的情况进行调整（分别对应<span class="hljs-number">4</span>-node和<span class="hljs-number">3</span>-node两种颜色冲突的情况）；  - ```c++    <span class="hljs-keyword">if</span>(ansLeft.<span class="hljs-built_in">status</span> == <span class="hljs-built_in">status</span>.rrb)&#123;     <span class="hljs-keyword">if</span>(old_tree-&gt;right-&gt;<span class="hljs-built_in">color</span> == color_red)&#123;       colorFlip(old_tree);       ans.new_tree = old_tree;       ans.<span class="hljs-built_in">status</span> = <span class="hljs-built_in">status</span>.brb;     &#125; <span class="hljs-keyword">else</span> &#123;       ans.new_tree = rebalLeft(old_tree, ansLeft.<span class="hljs-built_in">status</span>);       ans.<span class="hljs-built_in">status</span> = rbr;     &#125;    &#125;</code></pre></li></ul></li><li><p>brr：和rrb的处理情况类似；</p></li><li><p>所有的处理都不会对黑高度造成影响；</p></li></ul><h4 id="1-4-红黑树的删除"><a href="#1-4-红黑树的删除" class="headerlink" title="1.4 红黑树的删除"></a>1.4 红黑树的删除</h4><ul><li>只有一个子节点的结点可以直接删除；</li><li><strong>保持颜色限制，调整高度。</strong><ul><li>删除红色结点，黑高度不变，没有任何影响；</li><li>删除黑色结点，该结点所在的子树的黑高度减少了1，需要进行修正。<strong>并且这种修正可能导致更高的子树的黑高度降低，需要继续修正。</strong></li></ul></li><li>删除时，将该结点与它在中序遍历之后的后一个结点互换。删除互换后的该结点。将该结点的右结点代替被删除的集合。</li></ul><h3 id="2-渐进复杂性"><a href="#2-渐进复杂性" class="headerlink" title="2. 渐进复杂性"></a>2. 渐进复杂性</h3><h4 id="2-1-Ο"><a href="#2-1-Ο" class="headerlink" title="2.1 Ο"></a>2.1 <em>Ο</em></h4><ul><li><p>复杂度的上界（包含）</p></li><li><p>判断是否包含在<em>Ο</em>的时候可以使用【洛必达法则】。</p></li><li><p>对数复杂度小于幂函数复杂度！</p></li><li><script type="math/tex; mode=display">logn \in O(n^{\alpha}) ,{\forall}{\alpha}>0</script></li><li><p>幂函数复杂度小于指数复杂度！</p></li><li><script type="math/tex; mode=display">n^k \in O(c^n) ,{\forall}c>0</script></li><li><p>阶乘用斯特林公式处理：</p></li><li><script type="math/tex; mode=display">n!≈\sqrt{2{\pi}n}(\frac{n}{e})^n</script></li></ul><h4 id="2-2-Ω"><a href="#2-2-Ω" class="headerlink" title="2.2 Ω"></a>2.2 Ω</h4><ul><li>复杂度的下界（包含）</li></ul><h4 id="2-3-Θ"><a href="#2-3-Θ" class="headerlink" title="2.3 Θ"></a>2.3 Θ</h4><ul><li>复杂度上界与下界的交集——大致相同于真实复杂度；</li></ul><h4 id="2-4-Ο-Ω-Θ的性质"><a href="#2-4-Ο-Ω-Θ的性质" class="headerlink" title="2.4 Ο, Ω, Θ的性质"></a>2.4 <em>Ο</em>, Ω, Θ的性质</h4><ul><li><p><em>Ο</em>是一个等价关系——有传递性、对称性和自反性；</p></li><li><script type="math/tex; mode=display">O(f+g) = O(max(f,g))</script></li></ul><h4 id="2-5-o-和-ω"><a href="#2-5-o-和-ω" class="headerlink" title="2.5 o 和 ω"></a>2.5 o 和 ω</h4><ul><li>f与它的上界（下界）之间有一段不可忽视的距离。（不能大致相等）不光表示小于（大于），也表示f达不到g。</li></ul><h4 id="2-6-分治递归"><a href="#2-6-分治递归" class="headerlink" title="2.6 分治递归"></a>2.6 分治递归</h4><ul><li><p>将规模为n的问题分解成a个规模为n/b的子问题并递归地求解，并且分解/合成的总开销是f(n)的。</p></li><li><script type="math/tex; mode=display">T(n) = aT(\frac{n}{b})+f(n)</script></li><li><p>主定理：</p><ul><li><script type="math/tex; mode=display">f(n){\in}O(𝑛^{log_𝑏⁡{𝑎−𝜀}})，T(n)\in(𝑛^{log_𝑏⁡𝑎})</script></li><li><script type="math/tex; mode=display">f(n){\in}{\Theta}(𝑛^{log_𝑏⁡{𝑎}})，T(n){\in}{\Theta}(f(n)log(n))</script></li><li><p>具体见《算法导论》。</p></li><li>特别的一个特殊情况：</li></ul><script type="math/tex; mode=display">f(m)\in\Theta(m^Elog^a(m))</script><p>​       它的解为：</p><script type="math/tex; mode=display">T(n)\in\Theta(n^Elog^{a+1}(n))</script></li></ul><h2 id="计算机组成与设计"><a href="#计算机组成与设计" class="headerlink" title="计算机组成与设计"></a>计算机组成与设计</h2><h3 id="1-Carry-Look-Ahead-Adder"><a href="#1-Carry-Look-Ahead-Adder" class="headerlink" title="1. Carry Look Ahead Adder"></a>1. Carry Look Ahead Adder</h3><ul><li>Gate Latency<ul><li>AND：1</li><li>OR：1</li><li>XOR：3</li><li>计算CarryOut需要2个延迟</li></ul></li><li><img src="/img/加法器.png" alt="加法器及其延迟"></li><li>再上图中，计算<em>XY</em>和<em>X+Y</em>（即<em>P</em>和<em>G</em>）需要1个延迟，计算所有的<em>C</em>需要两个延迟，计算所有的<em>S</em>又需要3个延迟。（注：根据之前的推导，任意<em>C<sub>n</sub></em>都可以用<em>P、G、C<sub>n</sub></em>来表示）</li></ul><h3 id="2-Partial-Carry-Look-Ahead-Adder"><a href="#2-Partial-Carry-Look-Ahead-Adder" class="headerlink" title="2. Partial Carry Look Ahead Adder"></a>2. Partial Carry Look Ahead Adder</h3><ul><li><p><img src="/img/部分加法器.png" alt="部分加法器及其延迟"></p></li><li><p>在第一个时间周期内计算出所有的<em>P</em>和<em>G</em>，最右边的第一个CLA计算出<em>C8</em>需要3个延迟，往后的<em>C16</em>和<em>C24</em>都需要两个时间周期，最后计算最后的<em>C</em>和<em>S</em>还需要5个延迟。</p></li></ul><h3 id="3-Addition"><a href="#3-Addition" class="headerlink" title="3. Addition"></a>3. Addition</h3><p><em>overflow</em> = C<sub>n</sub>⊕C<sub>n-1</sub> ? Why?</p><p>证明和分析：如果overflow为0，只有两种情况——正数加正数得到负数和负数加负数得到正数。所以我们可以通过符号位来判断：<em>overflow</em> = X<sub>n</sub>Y<sub>n</sub>~S<sub>n</sub>+~X<sub>n</sub>~Y<sub>n</sub>S<sub>n</sub>，当X<sub>n</sub>Y<sub>n</sub>同时为1的时候，S<sub>n</sub>若为0则溢出。当X<sub>n</sub>Y<sub>n</sub>同时为0的时候，S<sub>n</sub>若为1则溢出。</p><h3 id="4-Subtraction"><a href="#4-Subtraction" class="headerlink" title="4. Subtraction"></a>4. Subtraction</h3><h3 id="5-Multiplication"><a href="#5-Multiplication" class="headerlink" title="5. Multiplication"></a>5. Multiplication</h3><ul><li><p>大概步骤：</p><ul><li>每一步计算部分和；</li><li>右移部分和；</li><li>如果<em>Y<sub>i</sub>=0</em>的话，只移动；</li></ul></li><li><p>Booth算法</p></li><li><script type="math/tex; mode=display">P_{i+1}=2^{-1}×(P_i+X×(Y_i-Y_{i+1}))</script><ul><li>初识情况令Y<sub>0</sub> = 0.</li><li>根据 <em>Y<sub>i+1</sub> - Y<sub>i</sub></em> 来判断是 <em>+X，-X，+0</em></li><li>右移部分和；</li><li>重复第二步和第三步；</li></ul></li><li><p>为了使结果正确，每一步应当使用算数右移。补充上去的符号位在计算出结果的符号位会被舍去。</p></li></ul><h3 id="6-Division"><a href="#6-Division" class="headerlink" title="6. Division"></a>6. Division</h3><ul><li>将被除数（remainder）的左边补上<em>n</em>位的<strong>符号位</strong>，除数左边补上<em>n</em>位的0，每一次将除数减被除数，再右移除数一位，若差大于等于0，则在此处的商置为1，将商左移一位。（原始版本）<ul><li>（remainder和quotient合在一起）依然是用division减remainder（前面的n位），如果是异号则用加法。</li></ul></li><li><strong>余数一定和被除数同号</strong>（用除数不断去逼近被除数，但是不能越过它）</li><li>当除数和被除数异号的时候，每次操作的减法变为<em>加法</em>。</li><li>若每次的加法或减法溢出，则做逆操作使得被除数恢复（recover）。</li><li>如果被除数和除数的异号的，我们需要对商修正——取反加一。</li><li><img src="/img/除法.png" alt="除法符号表"></li><li><strong>将错就错版本</strong>：<ul><li>符号扩展n位，然后存储在余数-商寄存器；</li><li>如果被除数和除数有相同的符号做减法，否则做加法：<ul><li>如果余数和除数有相同的符号，<em>Q<sub>n</sub></em>为1，反之为0。</li></ul></li><li>如果余数和除数有相同的符号，那么 <em>R<sub>i+1</sub> = 2R<sub>i</sub> - Y</em> ，否则 <em>R<sub>i+1</sub> = 2R<sub>i</sub> + Y</em> （注：有相同符号说明不需要补上之前错减的操作，继续-Y就可以；若不同说明需要减去之前的操作，因为前面已经错减了，左移*2之后，加上一个Y就可以）<ul><li>如果新的余数和除数有相同的符号，将商置为1，否则置为0。</li></ul></li><li>重复。</li></ul></li></ul><h3 id="7-浮点数运算"><a href="#7-浮点数运算" class="headerlink" title="7. 浮点数运算"></a>7. 浮点数运算</h3><ul><li>对阶</li></ul>]]></content>
    
    
    <categories>
      
      <category>WeeklyReview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WeeklyReview</tag>
      
      <tag>红黑树</tag>
      
      <tag>渐进复杂性</tag>
      
      <tag>ALU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TOEFL_reading_notes</title>
    <link href="/2020/09/22/TOEFL-reading-notes/"/>
    <url>/2020/09/22/TOEFL-reading-notes/</url>
    
    <content type="html"><![CDATA[<h3 id="题型一：Vocabulary-Questions"><a href="#题型一：Vocabulary-Questions" class="headerlink" title="题型一：Vocabulary Questions"></a>题型一：Vocabulary Questions</h3><p>only one of those meanings is relevant.</p><h4 id="做题方法"><a href="#做题方法" class="headerlink" title="做题方法"></a>做题方法</h4><ul><li>认识要选对；</li><li>没有不认识的；</li><li>求同：沾边就对；不存异：不做同义词辨析。</li></ul><h4 id="练习方法"><a href="#练习方法" class="headerlink" title="练习方法"></a>练习方法</h4><p>题干一个词 + 选项四个词 =&gt; 查英文词典记住；</p><h3 id="题型二：Sentence-Simplification-Questions"><a href="#题型二：Sentence-Simplification-Questions" class="headerlink" title="题型二：Sentence Simplification Questions"></a>题型二：Sentence Simplification Questions</h3><p>essential meaning.</p><h4 id="做题方法-1"><a href="#做题方法-1" class="headerlink" title="做题方法"></a>做题方法</h4><ol><li><p>确定题干句子的逻辑关系：</p><ul><li><p>逻辑关系词：1. 连词，2. 副词</p></li><li><p>感情色彩</p></li></ul></li><li><p>确定和逻辑关系相关的语义；</p></li><li>选择逻辑或者相关语义一致的选项；</li></ol><ul><li>常考逻辑：因果、比较、否定、最高级<ul><li>Because / so;</li><li>Lead to / cause;</li><li>encourage;</li><li>be responsible for;</li></ul></li><li>转折：but / while / whereas</li><li>让步：though / despite / albeit</li><li>条件：if / unless</li><li>并列：and / as well as</li></ul><p>逻辑作用的对象：</p><ul><li>因果：原因、结果；</li><li>比较：主题、对象；</li><li>否定、最高级</li></ul><p><strong>原则最简化 </strong> &amp;&amp;  <strong>先逻辑，后语意</strong></p><h3 id="题型三：Factual-Information-Questions"><a href="#题型三：Factual-Information-Questions" class="headerlink" title="题型三：Factual Information Questions"></a>题型三：Factual Information Questions</h3><p>explicitly stated <strong>明确提及</strong>            mentioned only in part of the passage.</p><p>Often the relevant information is in one or two sentences. <strong>在文章某一部分一到两句话明确提及的事实信息。</strong></p><h4 id="做题方法-2"><a href="#做题方法-2" class="headerlink" title="做题方法"></a>做题方法</h4><ul><li>先读一段文章，后做该段的题；</li><li>顺序：事实信息 ——&gt; 题干 ——&gt; 一到两句话 ——&gt; 选项 ——&gt; 排除（选对的）</li><li>干扰选项：① 答非所问；② 无中生有；③ 虚假比较；</li></ul><ol><li><p>定位【缩小阅读范围】</p><ul><li><p>定位方法：</p><p>a. 名词 &gt; 动词、形容词、副词；</p><p>b. 特殊 &gt; 普通；</p><p>​        特殊情况：</p><p>​                ① 题干定位线索在段落中多次出现；</p><p>​                ② 线索是 title 或 topic 用选项定位排除法；</p><p>c. 对名词修饰也在定位范围内；</p><p>d. 特殊疑问词（where/when/why/how）.</p></li></ul></li><li><p>精读：单词\语法\逻辑</p></li><li><p>同义改写：原文和选项之间同意信息点的对应；</p><ul><li>选项和原文信息点对应更多更重要的是正确选项</li></ul></li></ol><p><strong><em>切忌：过度推断；生活经验</em></strong></p><p>典型错误选项：</p><ul><li>答非所问：题干定位线索和题目问题不一致，题干中出现表示因果关系的逻辑关系词；Because/so/since/for/as a result of … 基于因果关系，扩大阅读范围。</li><li>无中生有：选项改变了原文动作主题和对象、感情色彩、动名词搭配、并列连词、否定词；</li><li>虚假比较：选项中出现了原文中没有的比较级、最高级、绝对化（absolute/extreme/definite/total/entire/all/every/any/never）、范围扩张（some/many/plenty/majority/major/most of）</li><li>优先认定包含虚假比较的选项为错误选项，如果原文有一一对应则该选项为正确选项；</li></ul><h3 id="题型四：Negative-Factual-Information-Questions"><a href="#题型四：Negative-Factual-Information-Questions" class="headerlink" title="题型四：Negative Factual Information Questions"></a>题型四：Negative Factual Information Questions</h3><h4 id="做题方法："><a href="#做题方法：" class="headerlink" title="做题方法："></a>做题方法：</h4><ul><li>定位</li><li>精读</li><li>排除</li><li>对应规则：<ul><li>对应原文集中举例：注意平行结构；</li><li>对应原文分散举例：选项排除法；</li><li>段落中存在多项并列的内容，往往有排除题；</li></ul></li></ul><h3 id="题型五：Inference-Questions"><a href="#题型五：Inference-Questions" class="headerlink" title="题型五：Inference Questions"></a>题型五：Inference Questions</h3><p>正确答案不在文章中提及。</p><h4 id="做题方法：-1"><a href="#做题方法：-1" class="headerlink" title="做题方法："></a>做题方法：</h4><ul><li>定位</li><li>精读</li><li>排除</li><li>因果推断：结果 ≈ 原因</li></ul><h3 id="题型七：Insert-Text-Question"><a href="#题型七：Insert-Text-Question" class="headerlink" title="题型七：Insert Text Question"></a>题型七：Insert Text Question</h3><p>grammatical connections.</p><p>时间压力大，不按文章顺序出</p><p>指代、逻辑、重复</p><h4 id="做题方法：-2"><a href="#做题方法：-2" class="headerlink" title="做题方法："></a>做题方法：</h4><ul><li>线索提取 =&gt; 题干</li><li>线索匹配 =&gt; 原文</li><li>连贯性检查 =&gt; 题干 + 原文</li></ul><p>代词：代词所在句子位于被指代名字所在句子的后面。</p><p>逻辑：</p><ul><li>词性：<ul><li>conj. ——&gt; 句子内 ——&gt; 简化；</li><li>adv. ——&gt; 句间 ——&gt; 插入；</li></ul></li><li>感情色彩：A but B<ul><li>正面：因果（感情色彩一致）</li><li>反面：转折、让步、比较；</li></ul></li></ul><p>重复信息：</p><ul><li>标志词：<ul><li>that is to say / that is / namely / in other words 换句话说；</li><li>in fact / indeed : give extra details to the topic just mentioned.；</li><li>similarly / likewise : 相似的，相同的；</li><li>举例：for example 观点 =&gt; 细节（例子）</li></ul></li><li>无标志词：同义词、同义替换；</li><li>“观点阐述”原则：概括、抽象在前；具体，细节在后；</li></ul><h5 id="题干-——-gt-找线索"><a href="#题干-——-gt-找线索" class="headerlink" title="题干 ——&gt; 找线索"></a>题干 ——&gt; 找线索</h5><ul><li>指代 ——&gt; pron. 往后放</li><li>逻辑 ——&gt; 正/反 往反放；</li><li>重复 ——&gt; 往后放；</li></ul><h3 id="题型八：Rhetorical-Purpose-Question"><a href="#题型八：Rhetorical-Purpose-Question" class="headerlink" title="题型八：Rhetorical Purpose Question"></a>题型八：Rhetorical Purpose Question</h3><p>{具体信息，段落功能，段落关系}</p><h4 id="做题方法：-3"><a href="#做题方法：-3" class="headerlink" title="做题方法："></a>做题方法：</h4><ol><li>定位</li><li>当前句是观点，是答案；</li><li>当前句不是观点，看前一句；</li><li>前一句也不是观点，看段落主旨句；</li></ol><p>当前句包含明确举例词的时候，看前一句</p><p>当前句中没有明确举例词的时候，判断：</p><ul><li>举例主题是具体细节内容；</li><li>和前一句话没有观点冲突；</li></ul><h5 id="目的题："><a href="#目的题：" class="headerlink" title="目的题："></a>目的题：</h5><p>当前句</p><ul><li>举例词——前一句</li><li>无举例词<ul><li>具体/无冲突——前一句</li><li>冲突——当前句</li></ul></li></ul><h5 id="段落功能"><a href="#段落功能" class="headerlink" title="段落功能"></a>段落功能</h5><p>What is the purpose/function/organization of the paragraph?</p><p>What is the relationship between Para1. and the rest of the passage in the larger discussion of xxx?</p><p>正确选项：main idea + 紧密相关的重要内容；</p><h5 id="段落关系"><a href="#段落关系" class="headerlink" title="段落关系"></a>段落关系</h5><p>Relationship between p1 and p2?</p><ol><li>阅读范围：两句话——前段末句和后段首句；</li><li>关系类型：顺承；转折/对比；举例解释<ul><li>顺承 =&gt; 语意链接；</li><li>转折/对比 =&gt; 逻辑关系词 however/on the contrary</li><li>举例 =&gt; for example</li><li>解释：explain/illustrate/elaborate/interpret</li></ul></li><li>判断方式<ul><li>变化：change/move/shift/migration/become/deteriorate/diminish</li><li>重要：important/significant</li><li>影响：effect/influence/impact</li><li>关系：relate/connect</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>TOEFL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TOEFL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>week2_Grade2_fall</title>
    <link href="/2020/09/18/week2-Grade2-fall/"/>
    <url>/2020/09/18/week2-Grade2-fall/</url>
    
    <content type="html"><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>​        上个期末考试期结束，就打算每周做一个小的总结，一是方便后续的总复习，而来能够 push 自己按时按计划复习。本学期主要学习的课程有《计组》、《算法》、《数据结构》、《数据科学基础》还有《线代》。数学课的内容重点在于刷题，不会像其他课一样总结主要概念和框架，可能会总结一些偏重难点。尽量 push 自己在每天都补充一些内容，以便于在一周的周六内发布。</p><h2 id="算法设计与分析"><a href="#算法设计与分析" class="headerlink" title="算法设计与分析"></a>算法设计与分析</h2><h3 id="0-尾递归"><a href="#0-尾递归" class="headerlink" title="0. 尾递归"></a>0. 尾递归</h3><p>我们常常用尾递归的方式将递归转化为迭代。</p><h4 id="0-0-回顾-SICP-中-Scheme-的尾递归"><a href="#0-0-回顾-SICP-中-Scheme-的尾递归" class="headerlink" title="0.0. 回顾 SICP 中 Scheme 的尾递归"></a>0.0. 回顾 SICP 中 Scheme 的尾递归</h4><p>因为函数式语言的最大特征之一是无法赋值，因此无法使用过程式语言中的 for 或者 while 循环来实现迭代。为了减小开销使得递归的效率更高，Scheme 引入了尾递归。(调用之后释放空间，与传统递归不同)</p><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">fact</span> n)  (<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">fact-tail</span> n result)    (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">&lt;=</span></span> n <span class="hljs-number">1</span>)        result        (<span class="hljs-name">fact-tail</span> (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> n <span class="hljs-number">1</span>) (<span class="hljs-name"><span class="hljs-builtin-name">*</span></span> n result))))  (<span class="hljs-name">fact-tail</span> n <span class="hljs-number">1</span>))</code></pre><p>Scheme 中的递归会使用一个辅助函数。每调用一次辅助函数之后，函数不需要在返回到调用者的函数，而是直接带着 result 调用后续的函数。</p><h4 id="0-1-尾递归的基本概念"><a href="#0-1-尾递归的基本概念" class="headerlink" title="0.1. 尾递归的基本概念"></a>0.1. 尾递归的基本概念</h4><ul><li>尾递归：一个递归函数仅仅在运算的最后才递归调用自身，并且调用后直接返回。</li><li><p>尾递归转换为迭代的方法：</p><ul><li>将每个参数转换为变量声明；</li><li>将函数体转换为一个循环体，并且对于基本情况直接返回相应的结果；递归调用时，首先计算新的参数并赋予相关的变量，后面跟上 continue 的语句。</li></ul></li><li><p>e.g.</p><pre><code class="hljs C">Euclid_recursion(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)&#123;<span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> m;    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">int</span> rem = m % n;        <span class="hljs-keyword">return</span> Euclid_Recursion(n, rem);    &#125;&#125;Euclid_tailRecursion(<span class="hljs-keyword">int</span> m1, <span class="hljs-keyword">int</span> n1)&#123;    <span class="hljs-keyword">int</span> m = m1;    <span class="hljs-keyword">int</span> n = n1;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<span class="hljs-comment">//while(true)模式，一般情况下可以转换为for循环。</span>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> m;        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">int</span> tmp = n;            n = m % n;            m = n;        &#125;    &#125;&#125;</code></pre></li></ul><h3 id="1-排序问题和排序算法-1"><a href="#1-排序问题和排序算法-1" class="headerlink" title="1. 排序问题和排序算法-1"></a>1. 排序问题和排序算法-1</h3><h4 id="1-1-插入排序（Insertion-Sort"><a href="#1-1-插入排序（Insertion-Sort" class="headerlink" title="1. 1. 插入排序（Insertion Sort)"></a>1. 1. 插入排序（Insertion Sort)</h4><h5 id="1-1-1-插入排序的基本内涵和实现"><a href="#1-1-1-插入排序的基本内涵和实现" class="headerlink" title="1.1.1. 插入排序的基本内涵和实现"></a>1.1.1. 插入排序的基本内涵和实现</h5><ul><li><p>基本情况：n == 1时，不需要排序。</p></li><li><p>递归情况：n &gt; 1时，分成两组——任意数 v 和其余的n-1个数；然后递归地排好剩下的n-1个数，再将v插入到已经排序完成的数列的适当位置，得到排序完成的数组。</p></li><li><p>如何插入？(下面的Insert_Abs就是插入算法)</p><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] Insert_Abs(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span>[] list)&#123;<span class="hljs-keyword">if</span>(list.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> v;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v &lt;= Head(list)) <span class="hljs-keyword">return</span> &#123;v&#125; + list;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> Head(list) + Insert_Abs(v, Tail(list));&#125;</code></pre></li><li><p>实现</p><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] insert(<span class="hljs-keyword">int</span>[] A)&#123;    <span class="hljs-keyword">int</span> i, j;    <span class="hljs-keyword">int</span> len = A.length;    <span class="hljs-keyword">int</span> target;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;len-<span class="hljs-number">1</span>; i++)&#123;        j = i;        target = A[i];<span class="hljs-comment">//等价于ppt中推导时所用到的v</span>        <span class="hljs-keyword">while</span>(j&gt;<span class="hljs-number">0</span> &amp;&amp; target&lt;A[j-<span class="hljs-number">1</span>])&#123;<span class="hljs-comment">//一旦target比前面的元素大，那么就插入它的后面</span>            A[j] = A[--j];<span class="hljs-comment">//否则将元素后移一位，空出位置给target。</span>        &#125;<span class="hljs-comment">//这个算法的实现和课上所讲的略有不同</span>        A[j] = target;<span class="hljs-comment">//这个算法是从前向后插入，课上是从后向前</span>    &#125;    <span class="hljs-keyword">return</span> A;&#125;</code></pre></li></ul><h5 id="1-1-2-插入排序-Insert-函数的循环不变式"><a href="#1-1-2-插入排序-Insert-函数的循环不变式" class="headerlink" title="1.1.2. 插入排序 Insert 函数的循环不变式"></a>1.1.2. 插入排序 Insert 函数的循环不变式</h5><ul><li>初始情况下，从start+1到end是排好序的；</li><li>在经过一次操作之后，从start到end是排好序；</li><li>循环一定是可以终止在 i = len-1的；</li></ul><h5 id="1-1-3-最坏情况分析"><a href="#1-1-3-最坏情况分析" class="headerlink" title="1.1.3. 最坏情况分析"></a>1.1.3. 最坏情况分析</h5><ul><li><p>最坏情况：逆序</p></li><li><p>时间复杂度：Ο(n<sup>2</sup>)</p></li><li><p>平均情况：对于每一个 i ，对应会有 j 个比较次数（内循环）。</p><script type="math/tex; mode=display">\frac{1}{i+1}\sum_{j=1}^{i}j + \frac{1}{i+1}(i) = \frac{i}{2}+1-\frac{1}{i+1}</script><p>求和之后，仍是 Ο(n<sup>2</sup>)。</p></li></ul><h4 id="1-2-快速排序"><a href="#1-2-快速排序" class="headerlink" title="1.2. 快速排序"></a>1.2. 快速排序</h4><h5 id="1-2-1-基本思路和实现"><a href="#1-2-1-基本思路和实现" class="headerlink" title="1.2.1 基本思路和实现"></a>1.2.1 基本思路和实现</h5><ul><li><p>按照某个数进行划分，小于这个数的作为一部分，大于这个数的作为另一部分。</p></li><li><p>采用分划算法 Partition(v, list) 将list分划成两个list：smallerList中的值都小于v，biggerList中都大于等于v。</p></li><li><p>有关实现：</p><ul><li>Partition 函数分割后的值仍然存放在这个区域。</li><li>QuickSort 之后得到的数据仍然存放在相同的区域。</li></ul></li><li><p>以下是“挖坑法”：（均在数组的原地址空间内进行改动）</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span>&#123;  <span class="hljs-keyword">if</span>(end &lt;= start) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> pivotIndex = partition(arr, start, end);    quickSort(arr, start, pivotIndex-<span class="hljs-number">1</span>);    quickSort(arr, pivotIndex+<span class="hljs-number">1</span>, end);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span>&#123;    <span class="hljs-keyword">int</span> pivot = arr[start];    <span class="hljs-keyword">int</span> left = start;    <span class="hljs-keyword">int</span> right = end;    <span class="hljs-keyword">int</span> index = start; <span class="hljs-comment">//挖坑的位置</span>    <span class="hljs-keyword">while</span> (left &lt;= right)&#123;        <span class="hljs-comment">//从右边向左边找到比标记更小的，将它转移到标记的左边</span>        <span class="hljs-keyword">while</span> (left &lt;= right)&#123;            <span class="hljs-keyword">if</span>(arr[right] &lt; pivot)&#123;                arr[left] = arr[right];                index = right;                left++;                <span class="hljs-keyword">break</span>;            &#125;            right--;        &#125;        <span class="hljs-comment">//从左向右找到比标记更大的，将它换转移到标记的右边，若上面发生了更换，那么这里也一定是把Pivot填写在上一个循环挖出的空间中；</span>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;            <span class="hljs-keyword">if</span> (arr[left] &gt; pivot)&#123;                arr[right] = arr[left];                index = left;                right--;                <span class="hljs-keyword">break</span>;            &#125;            left++;        &#125;    &#125;<span class="hljs-comment">//补上漏洞</span>    arr[index] = pivot;    <span class="hljs-keyword">return</span> index;&#125;</code></pre><ul><li>“指针交换法”：先把pivot以外的元素排好，再把pivot插入到其中相应的位置。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span>&#123;    <span class="hljs-keyword">if</span>(start &gt;= end) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> pivotIndex = partition(arr, start, end);    quickSort(arr, start, pivotIndex-<span class="hljs-number">1</span>);    quickSort(arr, pivotIndex+<span class="hljs-number">1</span>, end);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span>&#123;    <span class="hljs-keyword">int</span> pivot = arr[start];    <span class="hljs-keyword">int</span> left = start;    <span class="hljs-keyword">int</span> right = end;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-comment">//控制right指针比较并左移</span>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[right]&gt;pivot)&#123;        right--;    &#125;        <span class="hljs-comment">//控制right指针比较并右移</span>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot)&#123;            left++;        &#125;        <span class="hljs-comment">//交换left和right指向的元素</span>    <span class="hljs-keyword">if</span>(arr[left]&gt;arr[right])&#123;            <span class="hljs-keyword">int</span> p = arr[left];            arr[left] = arr[right];            arr[right] = p;        &#125;    &#125;        <span class="hljs-comment">//pivot和指针重合点交换，大概是中点的位置</span>    <span class="hljs-keyword">int</span> p = arr[left];    arr[left] = arr[start];    arr[start] = p;    <span class="hljs-keyword">return</span> left;&#125;</code></pre><ul><li>可以用“栈”重写非递归形式的快速排序：</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span>&#123;    Stack&lt;Map&lt;String, Integer&gt;&gt; quickSortStack = <span class="hljs-keyword">new</span> Stack&lt;Map&lt;String, Integer&gt;&gt;();    Map&lt;String, Integer&gt; rootParam = <span class="hljs-keyword">new</span> HashMap&lt;String, Integer&gt;();    rootParam.put(<span class="hljs-string">&quot;start&quot;</span>, start);    rootParam.put(<span class="hljs-string">&quot;end&quot;</span>, end);    quickSortStack.push(rootParam);      <span class="hljs-keyword">while</span> (!quickSortStack.isEmpty()) &#123;        Map&lt;String, Integer&gt; param = quickSortStack.pop();        <span class="hljs-keyword">int</span> pivotIndex = partition(arr, param.get(<span class="hljs-string">&quot;start&quot;</span>), param.get(<span class="hljs-string">&quot;end&quot;</span>));        <span class="hljs-keyword">if</span>(param.get(<span class="hljs-string">&quot;start&quot;</span>) &lt; pivotIndex-<span class="hljs-number">1</span>)&#123;            Map&lt;String, Integer&gt; leftParam = <span class="hljs-keyword">new</span> HashMap&lt;String, Integer&gt;();            leftParam.put(<span class="hljs-string">&quot;start&quot;</span>, param.get(<span class="hljs-string">&quot;start&quot;</span>));            leftParam.put(<span class="hljs-string">&quot;end&quot;</span>, pivotIndex-<span class="hljs-number">1</span>);            quickSortStack.push(leftParam);        &#125;          <span class="hljs-keyword">if</span>(pivotIndex+<span class="hljs-number">1</span> &lt; param.get(<span class="hljs-string">&quot;end&quot;</span>)) &#123;            Map&lt;String, Integer&gt; rightParam = <span class="hljs-keyword">new</span> HashMap&lt;String, Integer&gt;();            rightParam.put(<span class="hljs-string">&quot;start&quot;</span>, pivotIndex+<span class="hljs-number">1</span>);            rightParam.put(<span class="hljs-string">&quot;end&quot;</span>, param.get(<span class="hljs-string">&quot;end&quot;</span>));            quickSortStack.push(rightParam);        &#125;    &#125;&#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span>&#123;    <span class="hljs-keyword">int</span> pivot = arr[start];    <span class="hljs-keyword">int</span> left = start;    <span class="hljs-keyword">int</span> right = end;      <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[right]&gt;pivot)&#123;            right--;        &#125;          <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot)&#123;            left++;        &#125;          <span class="hljs-keyword">if</span>(arr[left]&gt;arr[right])&#123;            <span class="hljs-keyword">int</span> p = arr[left];            arr[left] = arr[right];            arr[right] = p;        &#125;          System.out.println(pivot);    &#125;      <span class="hljs-keyword">int</span> p = arr[left];    arr[left] = arr[start];    arr[start] = p;      <span class="hljs-keyword">return</span> left;&#125;</code></pre></li></ul><h2 id="计算机组织与结构"><a href="#计算机组织与结构" class="headerlink" title="计算机组织与结构"></a>计算机组织与结构</h2><h3 id="1-Introduction-前瞻"><a href="#1-Introduction-前瞻" class="headerlink" title="1. Introduction 前瞻"></a>1. Introduction 前瞻</h3><h4 id="1-1-结构与组织-Architecture-amp-Organization"><a href="#1-1-结构与组织-Architecture-amp-Organization" class="headerlink" title="1.1. 结构与组织 Architecture &amp; Organization"></a>1.1. 结构与组织 Architecture &amp; Organization</h4><h5 id="1-1-1-Architecture-结构"><a href="#1-1-1-Architecture-结构" class="headerlink" title="1.1.1. Architecture 结构"></a>1.1.1. Architecture 结构</h5><ul><li>对程序员可见（visible to programmer）；</li><li>对程序的逻辑加载有直接影响；</li></ul><h5 id="1-1-2-Organization-组织"><a href="#1-1-2-Organization-组织" class="headerlink" title="1.1.2 Organization 组织"></a>1.1.2 Organization 组织</h5><ul><li>对程序员不可见（encapuslated to programmer）；</li><li>操作单元和内部链接；</li></ul><h4 id="1-2-冯诺依曼架构"><a href="#1-2-冯诺依曼架构" class="headerlink" title="1.2. 冯诺依曼架构"></a>1.2. 冯诺依曼架构</h4><h5 id="1-2-1-组成部分"><a href="#1-2-1-组成部分" class="headerlink" title="1.2.1. 组成部分"></a>1.2.1. 组成部分</h5><ul><li>存储器：地址和存储的内容；</li><li>处理单元：执行信息的实际处理；</li><li>控制单元：指挥信息的处理；</li><li>输入设备：将信息送入计算机中；</li><li>输出设备：将处理结果以某种形式显示在计算机外；</li><li><img src="冯诺依曼.png" alt="冯诺依曼架构"></li></ul><h4 id="1-3-摩尔定律"><a href="#1-3-摩尔定律" class="headerlink" title="1.3. 摩尔定律"></a>1.3. 摩尔定律</h4><p>单个芯片上的晶体管数量每过18个月就会翻一倍。</p><p><img src="数据流向.png" alt="数据流向图"></p><h4 id="1-4-CPU表现（CPU-Performance）"><a href="#1-4-CPU表现（CPU-Performance）" class="headerlink" title="1.4. CPU表现（CPU Performance）"></a>1.4. CPU表现（CPU Performance）</h4><h5 id="1-3-1-系统时钟"><a href="#1-3-1-系统时钟" class="headerlink" title="1.3.1 系统时钟"></a>1.3.1 系统时钟</h5><ul><li>时钟频率（Clock rate）：计算机在进行基本操作时，一秒内的时钟周期频数。</li><li>时钟周期（Clock cycle）：CPU的一次电磁脉冲；</li><li>周期时间（Cycle time）：脉冲之间的时间；</li></ul><h5 id="1-3-2-指令加载"><a href="#1-3-2-指令加载" class="headerlink" title="1.3.2 指令加载"></a>1.3.2 指令加载</h5><ul><li><p>CPI（Cycles Per Instruction）：一条指令所经历的时钟周期数；</p></li><li><p>总CPI的计算公式：</p><script type="math/tex; mode=display">CPI = \frac{\sum_{i=1}^{n}(CPI_i×I_i)}{I_C}, I_C=\sum_{i-1}^{n}I_i</script></li><li><p>处理时间</p><script type="math/tex; mode=display">T=I_C×CPI×t</script><script type="math/tex; mode=display">T=I_C×[p+(m×k)]×t</script><p>p：从处理器到存储器之间传输消耗的时钟周期；</p></li><li><p>Million Instructions Per Second (MIPS)</p><script type="math/tex; mode=display">MIPS=\frac{I_C}{T×10^6}=\frac{f}{CPI×10^6}</script></li><li><p>Million Floating Point Operations Per Second (MFLOPS)</p><script type="math/tex; mode=display">MFLOPS=\frac{N_{floating-point op}}{T×10^6}</script></li></ul><h5 id="1-3-3-评价标准（Benchmarks）"><a href="#1-3-3-评价标准（Benchmarks）" class="headerlink" title="1.3.3 评价标准（Benchmarks）"></a>1.3.3 评价标准（Benchmarks）</h5><ul><li><p>评测系统的表现；</p></li><li><p>平均结果：</p><ul><li>算术平均值：结果之和除以总数，得到平均的结果；</li></ul><script type="math/tex; mode=display">R_A = \frac{1}{m}\sum_{i=1}^{m}R_i</script><ul><li>调和平均值：一次除以结果得到单次结果的倒数，对其求和再去除总次数得到调和平均值；</li></ul><script type="math/tex; mode=display">R_H=\frac{m}{\sum_{i=1}^{m}\frac{1}{R_i}}</script></li></ul><h3 id="2-计算机的顶层视角"><a href="#2-计算机的顶层视角" class="headerlink" title="2. 计算机的顶层视角"></a>2. 计算机的顶层视角</h3><h4 id="2-1-计算机组成元素"><a href="#2-1-计算机组成元素" class="headerlink" title="2.1. 计算机组成元素"></a>2.1. 计算机组成元素</h4><ul><li>数据和指令存储在一个可读可写存储器；</li><li>存储器可寻址；</li><li>指令的加载按一定顺序进行；</li></ul><h4 id="2-1-1-存储器"><a href="#2-1-1-存储器" class="headerlink" title="2.1.1. 存储器"></a>2.1.1. 存储器</h4><ul><li><img src="/img/内存墙.png" alt=""></li><li>Memory Wall：数据从主存到CPU之间的传输速度的发展速度难以跟得上CPU的发展速度。</li><li>解决方案：在主存和CPU之间添加一个cache来减少主存的高频访问和数据传送率；提高一次获取的信息量；</li><li><img src="/img/存储器.png" alt=""></li></ul><h5 id="2-1-1-1-约束条件"><a href="#2-1-1-1-约束条件" class="headerlink" title="2.1.1.1. 约束条件"></a>2.1.1.1. 约束条件</h5><ul><li>容量：越大越好；</li><li>速度：跟得上处理器；</li><li>成本：相比其他组件可以接受；</li></ul><h5 id="2-1-1-2-约束条件之间的关系"><a href="#2-1-1-2-约束条件之间的关系" class="headerlink" title="2.1.1.2. 约束条件之间的关系"></a>2.1.1.2. 约束条件之间的关系</h5><ul><li>访问时间越短，单位比特的成本越高；</li></ul><h5 id="2-1-1-3-解决措施"><a href="#2-1-1-3-解决措施" class="headerlink" title="2.1.1.3. 解决措施"></a>2.1.1.3. 解决措施</h5><ul><li>存储器层次结构（金字塔）；</li><li><img src="/img/存储器层次结构.png" alt=""></li></ul><h4 id="2-1-2-I-O"><a href="#2-1-2-I-O" class="headerlink" title="2.1.2. I/O"></a>2.1.2. I/O</h4><ul><li>在存储器、CPU和外部资源之间交换数据的模块；</li></ul><h5 id="2-1-2-1-Problem"><a href="#2-1-2-1-Problem" class="headerlink" title="2.1.2.1. Problem"></a>2.1.2.1. Problem</h5><ul><li>I/O 表现不能够跟得上 CPU 速度的增长；</li><li>解决方案：缓冲区；</li></ul><h4 id="2-1-3-CPU"><a href="#2-1-3-CPU" class="headerlink" title="2.1.3. CPU"></a>2.1.3. CPU</h4><h5 id="2-1-3-1-Problem"><a href="#2-1-3-1-Problem" class="headerlink" title="2.1.3.1. Problem"></a>2.1.3.1. Problem</h5><ul><li>CPU 在等待 I/O 设备时需要等待；</li><li>解决方案：<ul><li>中断：一种被其他模块打断并可能影响正常处理顺序时的机制；</li><li><img src="/img/中断机制.png" alt=""></li></ul></li><li>中断检测</li><li><img src="/img/中断处理.png" alt=""></li></ul><h5 id="2-1-3-2-多重中断（分优先级嵌套中断）"><a href="#2-1-3-2-多重中断（分优先级嵌套中断）" class="headerlink" title="2.1.3.2. 多重中断（分优先级嵌套中断）"></a>2.1.3.2. 多重中断（分优先级嵌套中断）</h5><ul><li><img src="/img/多中断.png" alt=""></li><li>还有一种执行完一个中断再执行下一个的中断；</li></ul><h5 id="2-1-3-3-Theoretical-maximum-performance"><a href="#2-1-3-3-Theoretical-maximum-performance" class="headerlink" title="2.1.3.3. Theoretical maximum performance"></a>2.1.3.3. Theoretical maximum performance</h5><p><img src="/img/处理差距.png" alt=""></p><ul><li>随着技术的发展，出现了流水线、高速缓存、多核多线程等等使得计算机性能表现突飞猛进；</li><li>时钟频率也在不断上涨，但是上涨到了一定数值就停滞了。如果时钟频率过高，单条指令的处理时间会缩短，处理能力会下降。</li></ul><h4 id="2-1-4-总线-Bus"><a href="#2-1-4-总线-Bus" class="headerlink" title="2.1.4. 总线 Bus"></a>2.1.4. 总线 Bus</h4><ul><li>连接多个设备的通路——总线；</li><li><img src="/img/总线.png" alt=""></li></ul><h5 id="2-1-4-1-数据传输类型"><a href="#2-1-4-1-数据传输类型" class="headerlink" title="2.1.4.1. 数据传输类型"></a>2.1.4.1. 数据传输类型</h5><ul><li>数据线：在系统模块之间传输数据；</li><li>地址线：指定<em>数据线上和I/O端口上</em>的数据的<strong>来源或者目的地</strong>的地址；</li><li>控制线：控制【访问】、【数据的使用】和【地址线的使用】；</li><li>数据线和地址线上的内容可以复用；控制线上的内容不能复用；</li><li><img src="/img/三种线.png" alt=""></li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="0-C-基础"><a href="#0-C-基础" class="headerlink" title="0. C++基础"></a>0. C++基础</h3><ul><li>系统开发的一种方法是把类的声明放在 header 文件中，成员函数的实现分开放在代码文件中，在函数的实现代码中通过<strong>作用域设定命令“::”</strong>，将该函数归属到某一类。</li><li>struct 的默认访问级别是public，而 class 中的默认访问级别是 private。除此之外，struct 与 class 是等价的。</li></ul><h3 id="1-算法"><a href="#1-算法" class="headerlink" title="1. 算法"></a>1. 算法</h3><h4 id="1-1-算法定义"><a href="#1-1-算法定义" class="headerlink" title="1.1. 算法定义"></a>1.1. 算法定义</h4><ul><li><strong>有输入</strong></li><li><strong>有输出</strong></li><li><strong>确定性</strong></li><li><strong>有穷性</strong></li><li><strong>能行性</strong></li></ul><h4 id="1-2-算法的性能标准"><a href="#1-2-算法的性能标准" class="headerlink" title="1.2. 算法的性能标准"></a>1.2. 算法的性能标准</h4><ul><li>正确性</li><li>可使用性</li><li>可读性</li><li>效率</li><li>健壮性</li><li>简单性</li></ul>]]></content>
    
    
    <categories>
      
      <category>WeeklyReview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WeeklyReview</tag>
      
      <tag>插入排序</tag>
      
      <tag>尾递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CoreJava-6</title>
    <link href="/2020/05/03/CoreJava-6/"/>
    <url>/2020/05/03/CoreJava-6/</url>
    
    <content type="html"><![CDATA[<h3 id="Chapter-6-接口、lambda表达式和内部类"><a href="#Chapter-6-接口、lambda表达式和内部类" class="headerlink" title="Chapter 6 接口、lambda表达式和内部类"></a>Chapter 6 接口、lambda表达式和内部类</h3><ol><li>接口是对类的一组需求描述。<ul><li>接口不能含有实例域。</li><li>实现一个接口的步骤：①将类声明为实现给定的接口。②对接口中的所有方法进行定义。</li><li>可以利用泛型为接口提供一个类型参数。</li></ul></li><li>接口的特性<ul><li>接口可以被拓展。</li><li>接口中可以包含常量。</li><li>接口中的域将被自动设为public static final。</li><li>每个类可以拥有多个接口。</li></ul></li><li><strong>一个类只能继承一个类，却可以有多个接口。</strong></li><li>默认方法，可以为接口方法提供一个默认实现。必须用default修饰符标记这样一个方法。</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(T other)</span></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;&#125;</code></pre><ol><li><strong>解决默认方法冲突</strong>。如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法。<ol><li>超类优先。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。</li><li>接口冲突。如果超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型相同的方法，必须覆盖这个方法来解决冲突。</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>Core Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Core Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CoreJava-5</title>
    <link href="/2020/04/26/CoreJava-5/"/>
    <url>/2020/04/26/CoreJava-5/</url>
    
    <content type="html"><![CDATA[<h3 id="Chapter-5-继承"><a href="#Chapter-5-继承" class="headerlink" title="Chapter 5 继承"></a>Chapter 5 继承</h3><ol><li><p>定义子类</p><ul><li>关键字extends表明正在构造的新类派生于一个已存在的类。已存在的类称为<strong>超类、基类、父类；</strong>新类称为<strong>子类、派生类或孩子类。</strong>子类的功能比超类更加丰富。</li><li>通过扩展超类定义子类的时候，仅需要指出子类与超类的不同之处。</li></ul></li><li><p>覆盖方法（override）</p><ul><li>Manager类的getSalary方法不能够直接地访问超类的私有域。只有Employee类的方法才能够访问私有部分。</li><li>super不是一个对象的引用，他只是一个指示编译器调用超类方法的指示器。<pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getSalary</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//double baseSalary = getSalary();这句也不可以，因为getSalary会循环调用；</span>    <span class="hljs-keyword">double</span> baseSalary = <span class="hljs-keyword">super</span>.gerSalary();    <span class="hljs-keyword">return</span> baseSalary + bonus;&#125;</code></pre></li></ul></li><li><p>子类构造器</p><ul><li>语句super(n, s, year, month, day)是“调用超类Employee中含有n、s、year、month、day参数的构造器”的简写形式。</li><li>Manager类不能访问Employee的私有域，所以必须利用Employee类的构造器对这部分私有域进行初始化。通过super实现对超类构造器的调用。<strong>使用super调用构造器的语句必须是子类构造器的第一条语句。</strong></li><li>没有使用super就会自动调用默认（即无参数）构造器。<pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Manager</span><span class="hljs-params">(String name, <span class="hljs-keyword">double</span> salary, <span class="hljs-keyword">int</span> year, <span class="hljs-keyword">int</span> month, <span class="hljs-keyword">int</span> day)</span></span>&#123;    <span class="hljs-keyword">super</span>(name, salary, year, month, day);    bonus = <span class="hljs-number">0</span>;&#125;</code></pre></li></ul></li><li><p>继承层次，继承并不限于一个层次。</p><ul><li>由一个公共超类派生出来的所有类的集合被称为<em>继承层次</em>。</li><li>在继承层次中，从某个特定的类到其祖先的路径被称为该类的<em>继承链</em>。</li></ul></li><li><p>多态</p><ul><li>“is-a”规则的另一种表述法是置换法则。它表明程序中出现超类的任何地方都可以用子类对象置换。</li><li>在Java中，子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换。</li></ul></li></ol><pre><code class="hljs Java">Manager[] manager = <span class="hljs-keyword">new</span> Manager[<span class="hljs-number">10</span>];Employee[] staff = managers;<span class="hljs-comment">//managers和staff引用的是同一个数组。</span></code></pre><ol><li><p><strong><em>理解方法调用</em></strong>，下面假设要调用x.f(args),隐式参数声明为一个类C的对象。</p><ul><li>编译器查看对象的声明类型和方法名。如果存在多个名字为f但参数类型不一样的方法，编译器会意义列举所有C类中名为f的方法和其超类中访问属性为public且名为f的方法（超类的私有方法不可访问）。</li><li>接下来，编译器将查看调用方法时提供的参数类型。如果在所有名为f的方法中存在一个与提供参数类型完全匹配，就选择这个方法。这个过程叫“<strong>重载解析</strong>”。允许类型转换。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报一个错误。</li><li>如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法，我们将这种方法称为<strong>静态绑定</strong>。与此对应的是，调用的方法<strong>依赖于隐式参数的实际类型</strong>，并且在运行时时间<strong>动态绑定</strong>。</li><li>当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个方法。<ul><li>假设x的实际类型是D，它是C类的子类。如果D类定义了方法f(String)，就直接调用它；否则，将在D类的超类中寻找f(String)，以此类推。</li></ul></li><li>方法表：列出了所有方法的签名和实际调用的方法。如果调用super.f(param)，编译器将对隐式参数超类的方法表进行搜索。</li><li>调用 e.getSalary() 的解析过程为：<ul><li>首先，虚拟机提取e的实际类型的方法表。</li><li>接下来，虚拟机搜索定义getSalary签名的类。此时，虚拟机已经知道应该调用哪个方法。</li><li>最后，虚拟机调用方法。</li></ul></li><li>动态绑定有一个重要的特性：无需对现存的代码进行修改，就可以对程序进行扩展。</li><li>在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别是，如果超类方法是public，子类方法一定要声明为public。</li></ul></li><li><p>阻止继承：final类和方法</p><ul><li>不允许扩展的类被称为final类。</li><li>声明格式：public final class Executive extends Manager{ … }</li><li>类中的特定方法也可以被声明为final。如果这样做，子类就不能覆盖这个方法，final类中所有的方法自动地成为final方法。</li><li>将方法或类声明为final主要目的是：确保它们不会在子类中改变语意。</li><li>如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理，这个过程被称为<em>内联</em>。如果子类中有覆盖这个方法，优化器将取消对覆盖方法的内联。</li></ul></li><li><p>强制类型转换，仅需要用一对圆括号将目标类名括起来，并放置在需要转换的对象引用之前就可以了。</p><ul><li>进行类型转换的唯一原因是：在暂时忽视对象的实际类型之后，使用对象的全部功能。</li><li>将一个子类的引用赋给一个超类变量，编译器是允许的。但将一个超类的引用赋给一个子类变量，必须进行类型转换，这样才能够通过运行时的检查。<ul><li><strong>在进行类型转换之前，先查看一下是否能够成功地转换。</strong></li><li><strong>只能在继承层次内进行类型转换</strong></li><li><strong>在将超类转换成子类之前，应该使用instanceof进行检查。</strong></li></ul></li><li>实际上，通过类型转换调整对象的类型并不是一种好的做法。因为多态性的动态绑定机制能够自动地找到对应的方法。在一般情况下，应该尽量少用类型转换和 instanceof 运算符。</li></ul></li></ol><pre><code class="hljs Java">Manager boss = <span class="hljs-keyword">new</span> Manager(...);staff[<span class="hljs-number">0</span>] = boss;staff[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Employee(...);staff[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> Employee(...);Manager boss = (Manager) staff[<span class="hljs-number">0</span>]; <span class="hljs-comment">//Allowed</span>Manager boss = (Manager) staff[<span class="hljs-number">1</span>]; <span class="hljs-comment">//Error</span><span class="hljs-keyword">if</span> (staff[<span class="hljs-number">1</span>] <span class="hljs-keyword">instanceof</span> Manager)&#123;    boss = (Manager) staff[<span class="hljs-number">1</span>];&#125; <span class="hljs-comment">//check the instance before</span></code></pre><ol><li>抽象类，从某种角度按，<em>祖先类</em>更加通用，人们只将它作为派生其他类的基类，而不作为想使用的特定的实例类。<ul><li>为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的。</li><li>许多程序员认为，在抽象类中不能包含具体方法。建议尽量通用的域和方法（不管是否是抽象的）放在超类（不管是不是抽象类）中。</li><li>扩展抽象类可以有两种选择。<ul><li>一种是在抽象类中定义部分抽象类或不定义抽象类方法，这样就必须将子类也标记为抽象类。</li><li>另一种是定义全部的抽象方法，这样一来子类就不是抽象的了。</li></ul></li><li>类即使不含抽象方法，也可以将类声明为抽象类。</li><li>抽象类不能被实例化。也就是说，如果将一个类声明为abstract，就不能创建这个类的对象。</li><li>可以定义一个抽象类的对象变量。但是它只能引用非抽象子类的实例。</li></ul></li></ol><pre><code class="hljs Java">Person p = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Vince Vu&quot;</span>, <span class="hljs-string">&quot;Economics&quot;</span>);</code></pre><ol><li>受访问保护<ul><li>子类也不能访问超类的私有域。</li><li>例如，如果超类Employee中的hireDay声明为protected，而不是私有的，Manager中的方法就可以直接访问它。不过，Manager类中的方法只能够访问Manager对象中的hireDay域，而不能访问其他Employee对象中的这个域。</li></ul></li></ol><div class="table-container"><table><thead><tr><th>修饰词</th><th>本类</th><th>同一个包的类</th><th>继承类</th><th>其他类</th></tr></thead><tbody><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr><tr><td>默认</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table></div><ol><li><p>Object类，它是Java中所有类的始祖，在Java中每个类都是由它扩展而来的。在Java中，只有基本类型不是对象。</p><ul><li>equals方法，用来检测一个对象是否等于另外一个对象。判断两个对象是否具有相同的引用（内容）。<pre><code class="hljs Java"><span class="hljs-comment">//重写equals</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object otherObject)</span></span>&#123;        <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">super</span>.equals(otherObject)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-comment">//super.equals checked that this and otherObject belong to the same class</span>        Manager other = (Manager) otherObject;        <span class="hljs-keyword">return</span> bonus == other.bonus;    &#125;&#125;</code></pre></li></ul></li><li><p>泛型数组列表ArrayList</p><ul><li>ArrayList  是一个采用类型参数的泛型类。为了指定数组列表保存的元素对象类型，需要用一对尖括号将类名括起来加在后面。</li><li>add方法可以将元素添加到数组列表中。</li><li>ensureCapacity(int num)方法，分配一个包含num个对象的内部数组。</li><li>.size()方法类似于length。</li><li>trimToSize() 将数组列表的存储容量削减到当前尺寸。</li><li>.set(i, harry)将第i个元素设置为harry。</li><li>.get()同理。</li><li>.toArray(int[] a)将其拷贝到一个数组中。</li><li>.remove(n)</li><li>将原始ArrayList赋值给一个类型化的ArrayList会得到一个警告。而一个类型化的数组传递给一个普通方法不会出现警告，并且不需要任何的类型转换。</li></ul></li><li>对象包装器与自动装箱（wrapper）<ul><li>自动装箱：list.add(3) 将自动转换成 list.add(Integer.ValueOf(3))，同样的将Integer对象赋值给一个int值的时候，会自动拆箱。</li><li>对象之间的比较要使用equals方法。</li></ul></li><li>枚举类</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Size</span></span>&#123;    SMALL(<span class="hljs-string">&quot;S&quot;</span>), MEDIUM(<span class="hljs-string">&quot;M&quot;</span>),LARGE(<span class="hljs-string">&quot;L&quot;</span>),EXTRA_LARGE(<span class="hljs-string">&quot;XL&quot;</span>);        <span class="hljs-keyword">private</span> String abbreviation;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Size</span><span class="hljs-params">(String abbreviation)</span> </span>&#123;      <span class="hljs-keyword">this</span>.abbreviation = abbreviation;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAbbreviation</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> abbreviation;    &#125;&#125;</code></pre><ol><li>Class类<ul><li>getName方法，返回类的名more字。</li><li>一个Class对象实际上表示的是一个类型，而这个类型未必一定是一种类。例如，int不是类，但int.class是一个Class类型的对象。</li><li>Class类实际上是一个泛型类。例如，Employee.class的类型是Class<Employee>。</li><li>虚拟机为每个类型管理一个Class对象。因此，可以用==运算符实现两个类对象的比较操作。</li><li>newInstance方法乐意用来动态创建一个类的实例。它会调用默认的构造器初始化新创建的对象。如果没有默认的构造器，会抛出一个异常。</li></ul></li><li><p>利用反射分析类的能力。Field、Method和Constructor分别用于描述类的域、方法和构造器。都有getName方法返回项目的名称。</p><ul><li>Field类有一个getType方法，用来返回所描述域所属类型的Class对象。</li><li>Modifier类中isPublic、isPrivate或isFinal判断方法或构造器判断是否是public、private或final。</li><li>Class的getFields、getMethods和getConstructor方法将分别返回类提供的public域、方法和构造器数组。</li></ul></li><li><p><strong>继承的设计技巧</strong></p><ol><li>将公共操作和域放在超类</li><li>不要使用受保护的域</li><li>使用继承实现”is-a”关系</li><li>除非所有继承的方法都有意义，否则不要使用继承</li><li>在覆盖方法时，不要改变预期的行为</li><li>使用多态，而非类型信息</li><li>不要过多使用反射</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>Core Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Core Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CoreJava-4</title>
    <link href="/2020/04/26/CoreJava-4/"/>
    <url>/2020/04/26/CoreJava-4/</url>
    
    <content type="html"><![CDATA[<h3 id="Chapter-4-对象与类"><a href="#Chapter-4-对象与类" class="headerlink" title="Chapter 4 对象与类"></a>Chapter 4 对象与类</h3><ol><li><p>封装：将数据和行为组合在一个包中，并对对象的使用者隐藏了数据的实现方式，对象中的数据成为实例域。</p><ul><li>实现封装的关键在于<strong>绝对不能</strong>让类中的方法直接地访问其他类的实例域。</li><li>封装的优点<ul><li>可以改变内部实现，除了该类的方法之外，不会影响其他的代码。</li><li>更改器方法可以执行错误检查，然而直接赋值不会进行这些处理。</li></ul></li></ul></li><li><p>对象</p><ul><li>对象的三个特性：<ul><li>对象的行为：可以对对象施加哪些操作，或可以对对象施加哪些方法？</li><li>对象的状态：当施加那些方法时，对象如何响应？</li><li>对象标识：如何辨别具有相同行为与状态的不同对象？</li></ul></li><li>对象的行为是用可调用的方法定义的。</li><li>每个对象都有一个唯一的<strong>身份</strong></li></ul></li><li><p>识别类</p><ul><li>从设计类开始，然后再往每个类中添加方法。</li><li>“找动词与名词”</li></ul></li><li><p>类之间的关系</p><ul><li>“依赖（use-a）”：如果一个类的方法操纵另一个类的对象，我们就说一个类依赖另一个类。<strong>应该尽可能将互相依赖的类减到最少——让类之间的耦合度最小。</strong></li><li>“聚合（has-a）”：类A的对象包含类B的对象。</li><li>“继承（is-a）”</li></ul></li><li><p>对象与对象变量：要想使用对象，就必须首先构造对象，并制定其初始状态。然后，对对象应用方法。</p><ul><li>构造器： 特殊的方法，用来构造并初始化对象。</li><li>一个对象变量并没有实际包含一个对象，而仅仅应用一个对象。deadline = birthday两个Date类的对象。</li><li>如果将方法应用到null对象上就会引发运行错误。</li><li>访问器方法——只访问对象而不修改对象的方法；修改的叫做构造器方法。</li></ul></li><li><p>Emplyee类</p><ul><li>最简单的类定义形式为：<pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassName</span></span>&#123;    field;    constructor;    method;&#125;</code></pre></li></ul></li><li><p>构造器</p><ul><li>构造器与类同名。</li><li>每个类可以有一个以上的构造器。</li><li>构造器可以有0个、1个或多个参数。</li><li>构造器没有返回值。</li><li>构造器总是伴随着new操作一起调用。</li><li><strong>不要在构造器中定义与实例域重名的局部变量</strong></li></ul></li><li><p>隐式参数与显式参数</p><ul><li>隐式参数是出现在方法名前的对象；</li><li>显式参数是方法名后面括号里的数值；</li><li>在每一个方法中，关键字</li></ul></li><li><p>一个方法可以访问所属类的所有对象的私有数据。</p></li><li><p>如果一个方法与当前实现机制非常紧密或者需要一个特别的协议以及一个特别的调用次序，最好将这样的方法设置成private的。</p><ul><li>只要方法是私有的，就可以确保它不会被外部的其他类所调用，因此可以将其删去。</li></ul></li><li><p>final实例域</p><ul><li>可以将实例域定义为final，在构建对象的时候必须将它初始化。并且在后面的操作中不能将它修改。</li><li>final修饰符大多应用于基本（primitive）类型域，或不可变类型域（类中的每个方法都不会改变其对象。）</li></ul></li><li><p>静态域： 如果将域定义为static，每个类中只有一个这样的域。而每一个对象对于所有的实例域却都有自己的一份拷贝。</p><ul><li>这个类的所有实例域将共享一个“nextID”域；</li><li>它属于类，不属于一个独立的对象；</li></ul></li><li><p>静态方法：不能向对象实施操作的方法。</p><ul><li>没有隐式的参数。静态方法是没有this参数的方法。</li><li>静态方法可以访问自身类中的静态域；</li><li>建议使用类名来调用静态方法；</li><li>在以下两种情况使用静态方法：<ul><li>一个方法不需要访问对象状态，其所需参数都是通过显示参数提供（如Math.pow）;</li><li>一个方法只需要访问类的静态域（如Employee.getNextID）；</li></ul></li></ul></li><li><p>工厂方法构造对象；</p><ul><li>将类的创建单独放到一个类里进行，这个类就叫做工厂。</li><li>不利用构造器有两个原因：<ol><li>无法命名构造器。构造器的名字必须和类名相同。但是货币的实例需要不同的名字；</li><li>当使用构造器时，无法改变所构造的对象类型。<pre><code class="hljs Java">NumberFormat currencyFormatter = NumberFormat.gerCurrencyInstance();NumberFormat percentFormatter = NumberFormat.getpercentInstance();</code></pre></li></ol></li></ul></li><li><p>main方法：<strong>不需要使用对象调用静态方法</strong></p><ul><li>例子：不需要构造Math对象就可以直接调用Math.pow。</li><li>main方法也是一个静态方法。main方法不对任何对象进行操作。事实上在程序启动时没有任何一个对象。静态的main方法将执行并创建程序所需要的对象。</li></ul></li><li><p>Java总是采用按值调用。</p><ul><li><strong>Java对对象采用的不是引用调用，实际上，对象引用是按值传递的。</strong></li><li>一个方法不能修改一个基本数据类型的参数（按值传递参数）；</li><li>一个方法可以改变一个对象的参数的状态；</li><li><strong>一个方法不能让对象参数引用一个新的对象 </strong></li></ul></li><li><p>重载：有些类可以有多个构造器。如果多个方法有相同的名字、不同的参数，便产生了重载；编译器通过用各个方法给出的参数类型与特定方法调用所使用的值的类型进行匹配来挑选出相应的方法（重载解析）。</p><ul><li>Java允许重载任何方法，不只是构造器方法。完整描述一个方法需要指出方法名以及参数类型。这叫做方法的<strong>签名</strong>。</li></ul></li><li><p>默认域初始化：数值为0、布尔值为false、对象引用为null。</p></li><li><p>无参数构造器，如果在编写一个类时没有编写构造器，系统就会提供一个无参数构造器。这个构造器将所有实数域设置为默认值。</p></li><li><p>显示域初始化，通过重载类的构造器方法，可以采用多种形式设置类的实例域的初始状态。</p></li><li><p>参数变量用同样的名字将实例域屏蔽起来。可以用this.salary的方式访问实例域。回想一下，this指示隐式参数，也就是所构造的对象。</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String name, <span class="hljs-keyword">double</span> salary)</span></span>&#123;    <span class="hljs-keyword">this</span>.name = name;    <span class="hljs-keyword">this</span>.salary = salary;&#125;</code></pre></li><li><p>调用另一个构造器。如果构造器的第一个语句形如this(…)，这个构造器将调用同一个类的另一个构造器。公共的构造器代码部分只编写一次即可。</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(<span class="hljs-keyword">double</span> s)</span></span>&#123;    <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;Emplyee #&quot;</span> + nextID, s);    nextID++; &#125;</code></pre></li><li><p>初始化块。在一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会被执行。</p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> nextID;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary;        <span class="hljs-comment">//object initialization block</span>    &#123;        id = nextID;        nextID++;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String n, <span class="hljs-keyword">double</span> s)</span></span>&#123;        <span class="hljs-keyword">this</span>.name = n;        <span class="hljs-keyword">this</span>.salary = s;    &#125;&#125;</code></pre><p>在上述示例中，无论使用哪个构造器构造对象，id域都在对象初始化模块中被初始化。<strong>运行初始化模块，然后才运行构造器的主体部分。</strong></p></li><li><p>调用构造器的具体处理步骤：</p><ol><li>所有数据域被初始化为默认值。</li><li>按照在类声明中出现的次序，一次执行所有域初始化语句和初始化块。</li><li>如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。</li><li>执行这个构造器的主体。</li></ol></li><li><p>静态初始化块</p><ul><li><strong>初始化块只调用一次（类加载时），而普通初始化块可以调用多次，随着对象的创建而加载。</strong></li><li>一个类中可以有多个静态初始化块和多个普通初始化块；静态初始化块的执行要早于普通初始化块；同一个类型的初始化块的执行顺序取决于定义的先后顺序！</li><li>在一个类中如果有多个不同的初始化块，初始化属性，构造器，执行顺序是：静态初始化块|静态属性初始化 &gt; 普通初始化块|普通属性初始化 &gt; 构造器</li></ul></li><li><p>对象析构与finalize方法</p><ul><li>Java自动回收垃圾，不支持析构器。</li><li>可以为任何一个类添加finalize方法。finalize方法在垃圾回收器清除对象之前调用。在实际应用中，不要依赖于使用finalize方法回收任何短缺的资源，这是因为很难知道这个方法什么时候才能够调用。</li></ul></li><li><p>包，Java允许使用包（package）将类组织起来。</p><ul><li>使用包的主要原因是确保类名的唯一性。</li><li>从编译器的角度来看，嵌套的包之间没有任何关系。例如，java.util包与java.util.jar包毫无关系。每一个都有独立的集合。</li></ul></li><li><p>静态导入</p><ul><li>在源文件顶部，添加一条import static java.lang.System.*;</li><li>可以更简洁比如Math.sqrt可以简写为sqrt</li></ul></li><li><p>将类放入包中，就必须将包的名字放在源文件的开头，包中定义类的代码之前。如果没有在源文件中放置package语句，这个源文件中的类就被放置在一个默认包中。</p></li><li><p>注释</p><ol><li>方法注释<ol><li>@param 变量描述</li><li>@return 描述</li><li>@throws 类描述</li></ol></li><li>通用注释<ol><li>@author 姓名</li><li>@version 版本</li><li>@since 引入特性的版本描述</li><li>@see 引用</li></ol></li><li>包注释单独在包中添加文档</li></ol></li><li><p>类设计技巧</p><ol><li>一定要保证数据私有，绝对不要破坏封装性。</li><li>一定要对数据初始化。</li><li>不要在类中使用过多的基本类型。</li><li>不是所有的域都需要独立的域访问器和域更改器。</li><li>将职责过多的类进行分解。</li><li>类名和方法名要能够体现它们的职责。</li><li>优先使用不可变的类。</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>Core Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Core Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CoreJava-3</title>
    <link href="/2020/04/26/CoreJava-3/"/>
    <url>/2020/04/26/CoreJava-3/</url>
    
    <content type="html"><![CDATA[<h3 id="Chapter-3-基本设计结构"><a href="#Chapter-3-基本设计结构" class="headerlink" title="Chapter 3 基本设计结构"></a>Chapter 3 基本设计结构</h3><ol><li><p>关键字<em>final</em>表示常量。关键字<em>final</em>表示这个变量只能被赋值一次。常量名全部使用大写。</p></li><li><p><em>static final</em>设置类常量。可在一个类的多个方法中使用。如果生命为public，即<em>public</em>，则其他类的方法也可以使用这个常量。</p></li><li><p><em>strictfp</em>关键字标记点方法必须使用严格的浮点计算来生成可再生的结果。</p></li><li><p>String 中的<em>substring</em>方法，s.substring(a, b)得到以a为index开头，到b为止但不包含b的字符串，长度为b-a。</p></li><li><p><em>join</em>方法，String.join(“/“, “S”, “M”, “L”, “XL”);得到的是字符串”S/M/L/XL”。</p></li><li><p>String类对象是不可变字符串。编译器可以让字符串共享。</p></li><li><p>检查字符串是否相等可以用.equals()方法。如果不区分大小写可以用equalsIgnoreCase方法。<em>一定不要使用==运算符来检测两个字符串是否相等。这只能确定两个字符串是否在同一个位置上</em></p></li><li><p>“”是空串，有长度有内容。null表示目前没有任何对象与该变量关联。</p></li><li><p>码点与代码单元</p></li></ol><ul><li>int[] codePoints = str.codePoints().toArray();将字符串转成一个数组。</li><li>String str = new String(codePoints, 0, codePoints.length);将码点数组转化成一个字符串。</li></ul><ol><li><p>构建字符串</p><pre><code class="hljs Java">StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();builder.append(ch);<span class="hljs-comment">// appends a single character</span>builder.append(str);<span class="hljs-comment">// appends a string</span>String completedString = builder.toString();</code></pre></li><li><p>控制台输入</p><pre><code class="hljs Java">Scanner in = <span class="hljs-keyword">new</span> Scanner(System.in);String name = in.nextLine();<span class="hljs-keyword">int</span> age = in.nextInt();</code></pre></li><li><p>文件出入与输出</p><pre><code class="hljs Java"><span class="hljs-comment">//input</span>Scanner in = <span class="hljs-keyword">new</span> Scanner(Paths.get(<span class="hljs-string">&quot;myfile.txt&quot;</span>), <span class="hljs-string">&quot;UTF-8&quot;</span>);<span class="hljs-comment">//output</span>PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(<span class="hljs-string">&quot;myfile.txt&quot;</span>), <span class="hljs-string">&quot;UTF-8&quot;</span>);</code></pre></li><li><p>Java SE 7 开始，switch中的case标签还可以是字符串字面量。</p></li><li><p>break或continue后接label, 可以在中断之后直接跳到label的位置继续执行。</p></li><li><p>大数值BigInteger实现大整数；BigDecimal实现大浮点数。</p><pre><code class="hljs Java">BigInteger a = BigInteger.valueOf(<span class="hljs-number">100</span>);<span class="hljs-comment">//将普通数值转换为大数值；</span>BigInteger c = a.add(b); <span class="hljs-comment">// c = a + b;</span>BigInteger d = c.multiply(b.add(BigInteger.valueOf(<span class="hljs-number">2</span>))); <span class="hljs-comment">// d = c * (b + 2)</span></code></pre></li><li><p>数组</p><pre><code class="hljs Java"><span class="hljs-keyword">int</span>[] a= <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100</span>];</code></pre></li></ol><ul><li>创建一个数组时，所有元素都初始化为0。boolean数组的元素会初始化为false。对象数组会初始化为null。<pre><code class="hljs Java"><span class="hljs-comment">//下面所有字符串都是null</span>String[] names = <span class="hljs-keyword">new</span> String[<span class="hljs-number">10</span>];<span class="hljs-comment">//下面所有字符串都是空串</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) names[i] = <span class="hljs-string">&quot;&quot;</span>;</code></pre></li><li>一旦创建了数组就不能改变它的大小。</li></ul><ol><li>for each 循环</li></ol><ul><li>for (variable : collection) statement<pre><code class="hljs Java">System.out.println(Arrays.toString(a));<span class="hljs-comment">//打印数组；</span></code></pre></li></ul><ol><li>数组拷贝<pre><code class="hljs Java"><span class="hljs-keyword">int</span>[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers, luckynumbers.length);</code></pre></li><li><p>Array.sort(a); 进行排序</p></li><li><p>不规则数组</p><pre><code class="hljs Java"><span class="hljs-keyword">int</span>[][] odds = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[MAX+<span class="hljs-number">1</span>][];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>; n &lt;= MAX; n+<span class="hljs-number">1</span>)    odds[n] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];<span class="hljs-comment">//以上生成的是一个三角形数组</span></code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>Core Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Core Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Emulation</title>
    <link href="/2021/02/22/Emulation/"/>
    <url>/2021/02/22/Emulation/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>virtual machine</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>19级大一上计基上机</title>
    <link href="/2020/12/14/19%E7%BA%A7%E5%A4%A7%E4%B8%80%E4%B8%8A%E8%AE%A1%E5%9F%BA%E4%B8%8A%E6%9C%BA/"/>
    <url>/2020/12/14/19%E7%BA%A7%E5%A4%A7%E4%B8%80%E4%B8%8A%E8%AE%A1%E5%9F%BA%E4%B8%8A%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h2 id="19级大一上计算系统基础上机回顾"><a href="#19级大一上计算系统基础上机回顾" class="headerlink" title="19级大一上计算系统基础上机回顾"></a>19级大一上计算系统基础上机回顾</h2><p>事先声明：个人所写版本不代表答案！仅提供思路！</p><h3 id="字典序排序"><a href="#字典序排序" class="headerlink" title="字典序排序"></a>字典序排序</h3><p><img src="/img/字典序.jpg" alt=""></p><p>这道题乍一看都能想到在考排序，然而字符串的排序和一般意义上的数字排序不同。如果是大一上没有经常练习C语言并且还有些Naive的小白同学，如何进行字典序可能就需要一些时间思考。当你解决了字典序——【逐个比较字母表顺序，若都相等比较长度】，还会遇到一个事情：字符串数组好像不能进行常规意义上的交换和赋值TAT</p><pre><code class="hljs c"><span class="hljs-keyword">char</span> s[<span class="hljs-number">100</span>][<span class="hljs-number">100</span>];<span class="hljs-comment">//wrong!!!!</span><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s1, <span class="hljs-keyword">char</span> *s2, <span class="hljs-keyword">int</span> j)</span></span>&#123;    <span class="hljs-keyword">char</span> *tmp = s[j];    s[j] = s[j+<span class="hljs-number">1</span>];    s[j+<span class="hljs-number">1</span>] = s[j];&#125;</code></pre><p>那怎么办呢，我们应该学过<strong>交换指针</strong>。我们可以额外再开一个数组<code>char *strArr[100];</code>保存的是指向相应字符串的指针。一旦需要交换两个字符串，交换<code>strArr</code>中的指针即可。</p><p>最后在进行输出的时候也是取相应的指针（原字符串数组的字符串之间的相对位置没有改变）</p><p>简单解释一下代码——基本模拟了题意；在进行字典序比较的时候，首先一一对应比较字母表序，若相等则比较长度，一旦出现逆序（前大于后）则交换；因为没有复杂度的要求，我再次使用了最简单的冒泡排序。</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strlen</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (*(s + len) != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;        len++;    &#125;    <span class="hljs-keyword">return</span> len;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">int</span> T, N;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;T);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> t=<span class="hljs-number">0</span>; t&lt;T; t++)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;N);        <span class="hljs-keyword">char</span> *strArr[<span class="hljs-number">100</span>];        <span class="hljs-keyword">char</span> str[<span class="hljs-number">100</span>][<span class="hljs-number">50</span>];        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;N; i++)&#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str[i]);            strArr[i] = str[i];        &#125;        <span class="hljs-keyword">int</span> flg;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;N<span class="hljs-number">-1</span>; i++)&#123;            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;N-i<span class="hljs-number">-1</span>; j++, flg = <span class="hljs-number">0</span>)&#123;                <span class="hljs-keyword">int</span> len1 = <span class="hljs-built_in">strlen</span>(strArr[j]);                <span class="hljs-keyword">int</span> len2 = <span class="hljs-built_in">strlen</span>(strArr[j+<span class="hljs-number">1</span>]);                <span class="hljs-keyword">int</span> test = (len1 &lt; len2)? len1 : len2;                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>; k&lt;test; k++)&#123;                    <span class="hljs-keyword">char</span> s1 = strArr[j][k];                    <span class="hljs-keyword">char</span> s2 = strArr[j+<span class="hljs-number">1</span>][k];                    <span class="hljs-keyword">if</span>(s2 &lt; s1)&#123;                        flg = <span class="hljs-number">1</span>;                        <span class="hljs-keyword">break</span>;                    &#125;                &#125;                <span class="hljs-keyword">if</span>(len2 &gt; len1 &amp;&amp; flg == <span class="hljs-number">0</span>)&#123;                    flg = <span class="hljs-number">1</span>;                &#125;                <span class="hljs-comment">//交换字符串的指针；</span>                <span class="hljs-keyword">if</span>(flg == <span class="hljs-number">1</span>)&#123;                    <span class="hljs-keyword">char</span> *tmp = strArr[j];                    strArr[j] = strArr[j+<span class="hljs-number">1</span>];                    strArr[j+<span class="hljs-number">1</span>] = tmp;                &#125;            &#125;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n%s&quot;</span>, strArr[<span class="hljs-number">0</span>], strArr[N<span class="hljs-number">-1</span>]);    &#125;&#125;</code></pre><h3 id="模拟Split函数"><a href="#模拟Split函数" class="headerlink" title="模拟Split函数"></a>模拟Split函数</h3><p><img src="/img/split.jpg" alt=""></p><p>字符串切割，也是split函数的模拟；考察的是字符串的模式匹配。同样，这里并没有考察算法，因此我们不需要过分考虑复杂度的问题。</p><p>这样以来，问题就没有那么复杂了。这里提到两种解法：Brute-Force解法（暴力解法）和KMP解法（不做过多解释，仅提供解法(._.)）</p><h4 id="Brute-Force"><a href="#Brute-Force" class="headerlink" title="Brute-Force"></a>Brute-Force</h4><p>这里主要复杂在得到结果之后的处理（x</p><p>我们首先得到模式串Target和待查找串Str以及他们的长度。对Str的每一个元素进行遍历，如下：</p><p><img src="https://pic2.zhimg.com/80/v2-4fe5612ff13a6286e1a8e50a0b06cd96_1440w.jpg?source=1940ef5c" alt=""></p><p>如果有匹配的，则记下它此时在数组中的index，然后再进行遍历输出。记得在两个模式串之间为空时，要输出”EmptyString”。</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strlen</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (*(s + len) != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;        len++;    &#125;    <span class="hljs-keyword">return</span> len;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">char</span> str[<span class="hljs-number">100</span>], target[<span class="hljs-number">100</span>];    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, str);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, target);    <span class="hljs-keyword">int</span> lenStr = <span class="hljs-built_in">strlen</span>(str);    <span class="hljs-keyword">int</span> lenTarget = <span class="hljs-built_in">strlen</span>(target);    <span class="hljs-keyword">int</span> last[<span class="hljs-number">100</span>];    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;        last[i] = <span class="hljs-number">-1</span>;    &#125;    <span class="hljs-keyword">if</span> (lenTarget &gt; lenStr) &#123; <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, str); &#125;    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">int</span> gap = lenStr - lenTarget;        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= gap; i++) &#123;            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; lenTarget; j++) &#123;                <span class="hljs-keyword">if</span> (str[i + j] != target[j]) &#123; <span class="hljs-keyword">break</span>; &#125;                <span class="hljs-keyword">if</span> (j == lenTarget - <span class="hljs-number">1</span>) &#123;                    last[i] = i + j + <span class="hljs-number">1</span>;                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; lenStr; i++) &#123;        <span class="hljs-keyword">if</span> (last[i] == <span class="hljs-number">-1</span>) &#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, *(str + i));        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (last[i] != <span class="hljs-number">-1</span> &amp;&amp; last[last[i]] != <span class="hljs-number">-1</span>) &#123;            i = last[i]<span class="hljs-number">-1</span>;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;EmptyString&quot;</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">if</span> (i != <span class="hljs-number">0</span>) &#123;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);            &#125;            i = last[i]<span class="hljs-number">-1</span>;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h4 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h4><p>仅供参考！( ´▽` )ﾉ</p><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;stdio.h&gt;</span></span>next[<span class="hljs-number">100</span>];start[<span class="hljs-number">100</span>];<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">strlen</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *s)</span> </span>&#123;    <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (*(s + len) != <span class="hljs-string">&#x27;\0&#x27;</span>) &#123;        len++;    &#125;    <span class="hljs-keyword">return</span> len;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildNext</span><span class="hljs-params">(<span class="hljs-keyword">int</span> lenPattern, <span class="hljs-keyword">char</span> *pattern)</span></span>&#123;    next[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> x = <span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> now = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (x &lt; lenPattern)&#123;        <span class="hljs-keyword">if</span>(pattern[now] == pattern[x])&#123;            now++;            x++;            next[++i] = now;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (now != <span class="hljs-number">0</span>)&#123;            now = next[now - <span class="hljs-number">1</span>];        &#125; <span class="hljs-keyword">else</span> &#123;            next[++i] = <span class="hljs-number">0</span>;            x++;        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *str, <span class="hljs-keyword">char</span>  *pattern)</span></span>&#123;    <span class="hljs-keyword">int</span> tar = <span class="hljs-number">0</span>;    <span class="hljs-keyword">int</span> position = <span class="hljs-number">0</span>;    <span class="hljs-keyword">while</span> (tar &lt; <span class="hljs-built_in">strlen</span>(str))&#123;        <span class="hljs-keyword">if</span>(str[tar] == pattern[position])&#123;            tar++;            position++;        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (position != <span class="hljs-number">0</span>)&#123;            position = next[position - <span class="hljs-number">1</span>];        &#125; <span class="hljs-keyword">else</span> &#123;            tar++;        &#125;        <span class="hljs-keyword">if</span>(position == <span class="hljs-built_in">strlen</span>(pattern))&#123;            <span class="hljs-comment">//printf(&quot;%d\n&quot;, tar-position+1);</span>            start[tar-position] = <span class="hljs-built_in">strlen</span>(pattern);            position = next[position<span class="hljs-number">-1</span>];        &#125;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-keyword">char</span> str[<span class="hljs-number">100</span>];    <span class="hljs-keyword">char</span> target[<span class="hljs-number">100</span>];    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s%s&quot;</span>, str, target);    <span class="hljs-keyword">int</span> lenStr = <span class="hljs-built_in">strlen</span>(str);    <span class="hljs-keyword">int</span> lenTarget = <span class="hljs-built_in">strlen</span>(target);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">100</span>; i++)&#123;        start[i] = <span class="hljs-number">0</span>;  <span class="hljs-comment">//初始化</span>    &#125;    buildNext(lenTarget, target);    search(str, target);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;lenStr; i++)&#123;        <span class="hljs-keyword">if</span>(start[i]!=<span class="hljs-number">0</span>)&#123;            <span class="hljs-keyword">if</span>(i != <span class="hljs-number">0</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);            i += start[i]<span class="hljs-number">-1</span>;            <span class="hljs-keyword">if</span>(start[i+<span class="hljs-number">1</span>]!=<span class="hljs-number">0</span>)&#123;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;EmptyString&quot;</span>);            &#125;            <span class="hljs-keyword">continue</span>;        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%c&quot;</span>, str[i]);    &#125;&#125;</code></pre><h2 id="希望大家注意到事情！"><a href="#希望大家注意到事情！" class="headerlink" title="希望大家注意到事情！"></a>希望大家注意到事情！</h2><ol><li><strong>首先，多多做题，别让自己的手生下来，机考非常吃熟练度！此后的各科机考也是一样</strong></li><li>多多练习和注意指针的使用！</li><li>操作字符串数组可以使用一个指针数组；</li><li>在此提供一些可以练习的题目：<ul><li>洛谷：到P2394是基础题，1165和1540是栈和队列，1015-1279是字符串，1032到1135是搜索，1102-1678是动态规划，后面是二分查找；(感谢李淳同学提供信息！)</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>计算系统基础</tag>
      
      <tag>KMP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MultiSet</title>
    <link href="/2020/12/07/MultiSet/"/>
    <url>/2020/12/07/MultiSet/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>After learning binary search trees in algorithm class, Nezzar challenges you with the following task.</p><p>Given a <strong>multiset</strong> 𝑆S which is intially emtpy, Nezzar may do one of the following operations in each round, and your algorithm should support these features.</p><ul><li>0 $x$, insert $x$ to $S$;</li><li>1 $x$, output the number of copies of $x$ in $S$, and remove exactly <strong>one copy</strong> of $x$ from $S$ if $S$ contains at least one copy of $x$;</li><li>2 $l,r$, output $∑x∈S,l&lt;x≤r$. For example, if $S={3,5,5,7},l=3,r=7$, then output should be $17$ as $5+5+7=17$.</li></ul><p>To disallow some shortcut solutions (offline solutions), Nezzar will fix a positive integer 𝑚𝑜𝑑mod, and provide input in the following way ($lans$ is $0$ initially).</p><ul><li>0 $y$ where $0≤y&lt;mod$, let $x=(y+lans)$ mod $mod$ and insert $x$ to $S$;</li><li>1 $y$ where $0≤y&lt;mod$, let $x=(y+lans)$ mod $mod$ and output the number of copies of $x$ in $S$, then remove exactly <strong>one copy</strong> of $x$ from $S$ if $S$ contains at least one copy of $x$;</li><li>2 $u,v$ where $0≤u,v&lt;mod$, let <ul><li>$l=(u+lans)$ mod $mod$ and $r=(v+lans)$ mod $mod$, swap $l$ and $r$ if $l&gt;r$, output $∑x∈S,l&lt;x≤r$ and finally update $lans$ with output.</li></ul></li></ul><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of input contains two integers $Q$ and $mod$, where $1≤Q≤5⋅10^5$ and $1≤mod≤10^13$.</p><p>Each of the following $Q$ lines contains an operation described above.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>For each type 1 and type 2 query, output one line with the required value.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code class="hljs python"><span class="hljs-number">7</span> <span class="hljs-number">15</span><span class="hljs-number">1</span> <span class="hljs-number">2</span><span class="hljs-number">0</span> <span class="hljs-number">3</span><span class="hljs-number">0</span> <span class="hljs-number">6</span><span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">7</span><span class="hljs-number">0</span> <span class="hljs-number">5</span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span></code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code class="hljs python"><span class="hljs-number">0</span><span class="hljs-number">9</span><span class="hljs-number">14</span><span class="hljs-number">0</span></code></pre><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>Initially, $S={}$.</p><p>Parameter for the first query is $x=(y+lans)$ mod $mod=2$. Hence, output for this query should be 0, and $S={}$ after first query.</p><p>Parameter for the second query is $x=(y+lans)$ mod $mod=3$. Hence, $S={3}$ after the second query.</p><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>Your algorithm should answer each query in $O(log⁡n)$ time to get accepted. If you have no idea how to debug, first write a naive algorithm (i.e., a straightforward but slow algorithm), then generate some small random test cases, finally compare the naive algorithm’s output with your final fast algorithm’s output.</p><h3 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h3><p>维护一个数据结构，使得它可以进行以下的三个操作：</p><ul><li>向一个集合内插入元素；</li><li>查询一个多重集中某元素的多少个，若存在，则在查询之后删除一个；</li><li>查询区间和；</li></ul><p>要求：每个操作都在$O(logn)$的时间内进行——【意味着我们要使用高效数据结构】。</p><h3 id="Naive-Solution"><a href="#Naive-Solution" class="headerlink" title="Naive Solution"></a>Naive Solution</h3><p>提示中说，我们可以先获得一个Naive的做法。在C++中，<code>Set</code>这个常用的容器是用红黑树来维护的，因此考虑到增和删的高效，一开始使用了这个数据结构。基本上是简单模拟了题意中的要求，并且同时维护了一个<code>map</code>用来存储对应<code>value</code>的次数。</p><ul><li>增：<code>map</code>中次数为0则在<code>set</code>中添加，否则在对于的<code>numMap</code>中+1；</li><li>删：<code>map</code>中次数为1则在<code>set</code>中删除，为0则不操作，否则在对于的<code>numMap</code>中-1；</li><li>查区间：用到了<code>upper_bound</code>因此要在<code>set</code>中添加一个最大的元素MAX防止上界的位置跑偏；</li></ul><p>很遗憾，这样的操作的“查区间”的最大时间复杂度是$O(n)$，不满足需求，在2操作较多且数据比较分散的情况下很显然会TLE；</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;cstdio&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;set&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;iterator&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;map&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> MAX 2147483647</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> Q;<span class="hljs-keyword">int</span> mod;<span class="hljs-keyword">int</span> choice;<span class="hljs-keyword">int</span> x;<span class="hljs-keyword">int</span> u, v;<span class="hljs-keyword">int</span> l, r;<span class="hljs-keyword">int</span> lans=<span class="hljs-number">0</span>;<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt;S;<span class="hljs-built_in">map</span>&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; numMap;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">multiS</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;Q, &amp;mod);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;Q; i++)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;choice);        <span class="hljs-keyword">switch</span> (choice) &#123;            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);                <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">0</span>&amp;&amp;x&lt;mod)&#123;x = (x+lans)%mod;&#125;                <span class="hljs-keyword">if</span>(S.count(x)==<span class="hljs-number">0</span>) numMap.insert(&#123;x, <span class="hljs-number">0</span>&#125;);                numMap[x]++;                S.insert(x);                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);                <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">0</span>&amp;&amp;x&lt;mod)&#123;x = (x+lans)%mod;&#125;                <span class="hljs-keyword">if</span>(numMap[x]&gt;<span class="hljs-number">0</span>)&#123;                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, numMap[x]);                &#125; <span class="hljs-keyword">else</span> &#123;                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0\n&quot;</span>);                &#125;                <span class="hljs-keyword">if</span>(numMap[x]==<span class="hljs-number">1</span>)&#123;                    S.erase(x);                &#125;                <span class="hljs-keyword">if</span>(numMap[x]&gt;<span class="hljs-number">0</span>)&#123;                    numMap[x]--;                &#125;                <span class="hljs-keyword">break</span>;            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:                <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;u, &amp;v);                <span class="hljs-keyword">if</span>(u&gt;=<span class="hljs-number">0</span>&amp;&amp;u&lt;mod)&#123;l = (u+lans)%mod;&#125;                <span class="hljs-keyword">if</span>(v&gt;=<span class="hljs-number">0</span>&amp;&amp;v&lt;mod)&#123;r = (v+lans)%mod;&#125;                <span class="hljs-keyword">if</span>(l&gt;r)&#123;                    <span class="hljs-keyword">int</span> tmp = l;                    l = r;                    r = tmp;                &#125;                <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;                <span class="hljs-built_in">pair</span>&lt;<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt;::const_iterator,<span class="hljs-built_in">set</span>&lt;<span class="hljs-keyword">int</span>&gt;::const_iterator&gt; pr;                pr = S.equal_range(l);                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> i=pr.second; i!=S.upper_bound(r); i++)&#123;                    <span class="hljs-keyword">int</span> t = numMap[*i];                    sum += (*i)*t;                &#125;                lans = sum;                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, sum);                <span class="hljs-keyword">break</span>;        &#125;    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello!&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    S.insert(MAX);    multiS();&#125;</code></pre><h3 id="维护Treap解法"><a href="#维护Treap解法" class="headerlink" title="维护Treap解法"></a>维护Treap解法</h3><blockquote><p>treap 是一种弱平衡的二叉搜索树。treap 这个单词是 tree 和 heap 的组合，表明 treap 是一种由树和堆组合形成的数据结构。treap 的每个结点上要额外储存一个值$priority$。treap 除了要满足二叉搜索树的性质之外，还需满足父节点的</p><p>$priority$大于等于两个儿子的$priority$。而$priority$是每个结点建立时随机生成的，因此 treap 是期望平衡的。</p></blockquote><p>treap 分为旋转式和无旋式两种。两种 treap 都易于编写，但无旋式 treap 的操作方式使得它天生支持维护序列、可持久化等特性。这里以重新实现 <code>set&lt;int&gt;</code> （不可重集合）为例，介绍无旋式 treap。</p><p>在众多高效数据结构中，我选择了Treap。（因为不想写红黑树，也不会用跳表）这道题使用了一个<a href="https://oi-wiki.org/ds/treap/">模板</a>——来自于课程助教。使用数组存了几个关于Treap的关键信息——<code>w[maxn]</code>存入每个结点出现的次数、<code>size</code>是以当前结点为根的树的结点之和、<code>val</code>等都是结点信息；</p><p>这个问题的关键是利用了平衡树求得了前缀和，因此可以<code>ll sum = T.querySum(T.rt, r) - T.querySum(T.rt, l);</code> 对于二叉搜索树来说，其中一种情况，左子结点全部比根节点小，右节点全部比根节点大，因此左子树+根节点就是前缀和。还有一种情况，如果根节点是父母节点的右子节点，那么父母节点也在前缀和中。因此前缀和需要我们逐层递归查找，时间复杂度为$O(n)$。所以，为了满足这个条件，我们需要将<strong>树的和</strong>记录下来。因此在增和删的操作中，我们需要维护子树和。</p><ul><li>增：在查找位置的过程中，每到一层即为当前根结点的根数和加上当前<code>x</code>的<code>value</code>。</li><li>删：我额外维护了一个set，便于判断是否向下查找。如果set中没有该数，那么不进行删除操作，如果有则在沿途减去当前<code>value</code>。并且当这个结点需要删除的同时，<code>set.erase(x)</code>。</li></ul><p>等于上面的操作将累加和摊销到了增和删的操作中；</p><p>这样，前缀和就十分好获得了（已经存储过），区间和直接就可以得到。最后不忘记更新<code>lans</code>就结束了。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;set&quot;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> maxn 1000005</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> INF (1 &lt;&lt; 30)</span><span class="hljs-keyword">int</span> n;ll mod;ll lans=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> l[maxn], r[maxn], rnd[maxn], w[maxn];ll  size[maxn], val[maxn];<span class="hljs-built_in">set</span>&lt;ll&gt;S;<span class="hljs-comment">//w是权重 //l是左子节点的索引 //r是右子结点的索引 //rnd是优先级 //val是对应的索引 //size是树的节点总数-&gt;前缀和</span><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">treap</span> &#123;</span>  <span class="hljs-keyword">int</span> sz, rt;  <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pushup</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123; size[x] = size[l[x]] + size[r[x]] + w[x]*val[x]; &#125;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lrotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;k)</span> </span>&#123;    <span class="hljs-keyword">int</span> t = r[k];    r[k] = l[t];    l[t] = k;    size[t] = size[k];    pushup(k);    k = t;  &#125;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rrotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;k)</span> </span>&#123;    <span class="hljs-keyword">int</span> t = l[k];    l[k] = r[t];    r[t] = k;    size[t] = size[k];    pushup(k);    k = t;  &#125;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;k, ll x)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!k) &#123;      sz++;      k = sz;      size[k] = x;      w[k] = <span class="hljs-number">1</span>;      val[k] = x;      rnd[k] = rand();      <span class="hljs-keyword">return</span>;    &#125;    size[k]+=x;    <span class="hljs-keyword">if</span> (val[k] == x) &#123;      w[k]++;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val[k] &lt; x) &#123;      insert(r[k], x);      <span class="hljs-keyword">if</span> (rnd[r[k]] &lt; rnd[k]) lrotate(k);    &#125; <span class="hljs-keyword">else</span> &#123;      insert(l[k], x);      <span class="hljs-keyword">if</span> (rnd[l[k]] &lt; rnd[k]) rrotate(k);    &#125;  &#125;  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">del</span><span class="hljs-params">(<span class="hljs-keyword">int</span> &amp;k, ll x)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!S.count(x))        <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span> (val[k] == x) &#123;      <span class="hljs-keyword">if</span> (w[k] &gt; <span class="hljs-number">1</span>) &#123;        w[k]--;        size[k]-=x;        <span class="hljs-keyword">return</span>;      &#125;      <span class="hljs-keyword">if</span> (l[k] == <span class="hljs-number">0</span> || r[k] == <span class="hljs-number">0</span>) &#123;          S.erase(x);          k = l[k] + r[k];      &#125;      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (rnd[l[k]] &lt; rnd[r[k]]) &#123;        rrotate(k);        del(k, x);      &#125; <span class="hljs-keyword">else</span> &#123;        lrotate(k);        del(k, x);      &#125;    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (val[k] &lt; x) &#123;      size[k]-=x;      del(r[k], x);    &#125; <span class="hljs-keyword">else</span> &#123;      size[k]-=x;      del(l[k], x);    &#125;  &#125;  <span class="hljs-function">ll <span class="hljs-title">querySum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, ll x)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!k) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (val[k] == x)      <span class="hljs-keyword">return</span> size[l[k]] + w[k]*val[k];    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &gt; val[k]) &#123;      <span class="hljs-keyword">return</span> size[l[k]] + w[k]*val[k] + querySum(r[k], x);    &#125; <span class="hljs-keyword">else</span>      <span class="hljs-keyword">return</span> querySum(l[k], x);  &#125;  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">querynum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, ll x)</span> </span>&#123;    <span class="hljs-keyword">if</span> (!k) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <span class="hljs-keyword">if</span> (x == val[k])&#123;        <span class="hljs-keyword">return</span> w[k];    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (x &lt; val[k])&#123;        <span class="hljs-keyword">return</span> querynum(l[k], x);    &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">return</span> querynum(r[k], x);    &#125;  &#125;&#125; T;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    srand(<span class="hljs-number">123</span>);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;mod);    <span class="hljs-keyword">int</span> opt;    ll x;    ll v;    ll l, r;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%lld&quot;</span>, &amp;opt, &amp;x);        <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">0</span>) &#123;            <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">0</span>&amp;&amp;x&lt;mod) x = (x + lans) % mod;            S.insert(x);            T.insert(T.rt, x);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">1</span>)&#123;            <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">0</span>&amp;&amp;x&lt;mod) x = (x + lans) % mod;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, T.querynum(T.rt, x));            T.del(T.rt, x);        &#125;        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (opt == <span class="hljs-number">2</span>) &#123;            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;v);            <span class="hljs-keyword">if</span>(x&gt;=<span class="hljs-number">0</span>&amp;&amp;x&lt;mod) l = (x+lans)%mod;            <span class="hljs-keyword">if</span>(v&gt;=<span class="hljs-number">0</span>&amp;&amp;v&lt;mod) r = (v+lans)%mod;            <span class="hljs-keyword">if</span>(l&gt;r)&#123;                ll tmp = l;                l = r;                r = tmp;            &#125;            ll sum = T.querySum(T.rt, r) - T.querySum(T.rt, l);            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, sum);            lans = sum;        &#125;    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="测试生成Python代码"><a href="#测试生成Python代码" class="headerlink" title="测试生成Python代码"></a>测试生成Python代码</h3><p>以下是debug过程中用到的生成测试数据的代码，欢迎取用( ´ ▽ ` )ﾉ！</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> cyaron <span class="hljs-keyword">import</span> *<span class="hljs-keyword">import</span> random<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">genTest</span>(<span class="hljs-params">n</span>):</span>    test_data = IO(file_prefix=<span class="hljs-built_in">str</span>(n))    t = randint(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span>)    mod = randint(<span class="hljs-number">1</span>, <span class="hljs-number">1000000</span>)    test_data.input_write(t)    test_data.input_write(<span class="hljs-string">&quot; &quot;</span>)    test_data.input_writeln(mod)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, t):        a = randint(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>)        test_data.input_write(a)        test_data.input_write(<span class="hljs-string">&quot; &quot;</span>)        test_data.input_write(randint(<span class="hljs-number">1</span>, <span class="hljs-number">1000000</span>))        <span class="hljs-keyword">if</span> a==<span class="hljs-number">2</span>:            test_data.input_write(<span class="hljs-string">&quot; &quot;</span>)            test_data.input_writeln(randint(<span class="hljs-number">1</span>, <span class="hljs-number">1000000</span>))        <span class="hljs-keyword">else</span>:            test_data.input_writeln()    test_data.output_gen(<span class="hljs-string">&quot;...&quot;</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">100</span>):        genTest(i)</code></pre>]]></content>
    
    
    <categories>
      
      <category>OJ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构与算法</tag>
      
      <tag>OJ</tag>
      
      <tag>平衡树</tag>
      
      <tag>Treap</tag>
      
      <tag>BST</tag>
      
      <tag>模板</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BalanceSegmentPainting</title>
    <link href="/2020/12/05/BalanceSegmentPainting/"/>
    <url>/2020/12/05/BalanceSegmentPainting/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>There’s a segment 𝐼=[0,𝑛] initially painted with color white. Nezzar chooses a permutation 𝑝p of [𝑛]={1,2,⋯,𝑛}, and repaint the segment in the following way.</p><ul><li>In the 𝑖-th day, he repaints segment [𝑝𝑖−1,𝑝𝑖] with color black.</li></ul><p>Define the balance of segment 𝐼 as the length of the largest continuous subsegment 𝐼′ painted <strong>in black</strong>. Nezzar challenges you to calculate the balance of segment 𝐼 right after the 𝑖-th day for <em>1</em>≤𝑖≤𝑛.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line of the input contains a single integer 𝑛 (1≤𝑛≤10<sup>6</sup>).</p><p>The following line contains 𝑛 integers 𝑝<sub>1</sub>,𝑝<sub>2</sub>,…,𝑝<sub>𝑛</sub> (1≤𝑝<sub>𝑖</sub>≤𝑛).</p><p>It is gauranteed that 𝑝<sub>1</sub>,𝑝<sub>2</sub>,…,𝑝<sub>𝑛</sub> forms a permutation of [𝑛].</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Output 𝑛 balance values in one line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code class="hljs python"><span class="hljs-number">5</span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span></code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code class="hljs python"><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span></code></pre><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>You might want to use the disjoint sets data structure.</p><h3 id="题目大意"><a href="#题目大意" class="headerlink" title="题目大意"></a>题目大意</h3><p>给定一个数组表示一段白色的布，它有$n$个格子，每天染黑一个格子，问每天最长的连续黑色段有多长？</p><ul><li>⬜️ ⬜️ ⬜️ ⬜️ ⬜️         0-day            0-balance</li><li>⬛️ ⬜️ ⬜️ ⬜️ ⬜️         1-day            1-balance            1</li><li>⬛️ ⬛️ ⬜️ ⬜️ ⬜️         2-day            2-balance            2</li><li>⬛️ ⬛️ ⬜️ ⬜️ ⬛️         3-day            2-balance            5</li><li>⬛️ ⬛️ ⬜️ ⬛️ ⬛️         4-day            2-balance            4</li><li>⬛️ ⬛️ ⬛️ ⬛️ ⬛️         5-day            5-balance            3</li></ul><p>提示中说，让我们使用并查集。这是一道很标准的并查集的模板题。只需要稍加修改就可以通过了。每个染黑的段是一个集合，每次染之和只需要查找能不能和左右两边的格子并成一个集合即可！</p><p>注意，为了减少内存的使用和时间消耗，我把每个并查集的结点数放在了根节点中，并以负数表示根节点。为了更加高效，我们还应该在查找的同时进行压缩。</p><p>应该是本次oj最容易解决的一道题了orz</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;iostream&quot;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; f;<span class="hljs-keyword">int</span> res=<span class="hljs-number">0</span>;<span class="hljs-keyword">int</span> r;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">Find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span></span>&#123;    <span class="hljs-keyword">if</span>(f[k]==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">//没被染黑</span>    <span class="hljs-keyword">if</span>(f[k]&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> k;   <span class="hljs-comment">//根节点是负数</span>    <span class="hljs-keyword">return</span> f[k]=Find(f[k]); <span class="hljs-comment">//集团染黑，同时压缩节点；</span>&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b)</span></span>&#123;    <span class="hljs-keyword">int</span> fa = Find(a);    <span class="hljs-comment">//两个都是正数</span>    <span class="hljs-keyword">int</span> fb = Find(b);    <span class="hljs-comment">//fa和fb是a和b的根的位置</span>    <span class="hljs-keyword">if</span>(fa != fb)&#123;        <span class="hljs-keyword">int</span> numA = f[fa];  <span class="hljs-comment">//这个数是负的；</span>        <span class="hljs-keyword">int</span> numB = f[fb];  <span class="hljs-comment">//也是负的；</span>        <span class="hljs-keyword">int</span> numAll = numA + numB;        f[fa] = fb;      <span class="hljs-comment">//fa的根换成了fb</span>        f[fb] = numAll;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;n);    f= <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;(n+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++)&#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;r);        f[r] = <span class="hljs-number">-1</span>;  <span class="hljs-comment">//新染色，自己是自己的根；</span>        <span class="hljs-keyword">int</span> left = Find(r<span class="hljs-number">-1</span>);  <span class="hljs-comment">//返回的是位置</span>        <span class="hljs-keyword">int</span> right = Find(r+<span class="hljs-number">1</span>);        <span class="hljs-keyword">if</span>(left&gt;<span class="hljs-number">0</span>) Union(r, left);    <span class="hljs-comment">//两个位置Union</span>        <span class="hljs-keyword">if</span>(right&gt;<span class="hljs-number">0</span>) Union(r, right);        <span class="hljs-keyword">int</span> t = -f[Find(r)];        <span class="hljs-keyword">if</span>(t &gt; res) res = t;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, res);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>OJ</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>并查集</tag>
      
      <tag>数据结构与算法</tag>
      
      <tag>OJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GodMiner</title>
    <link href="/2020/12/04/GodMiner/"/>
    <url>/2020/12/04/GodMiner/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Nezzar is addicted to game Gold Miner recently.</p><p>Gold Miner is a game in which the player is in an 𝑛×𝑛n×n grid, and the goal is to collect gold without entering forbidden area. It is known that cell (𝑖,𝑗)(i,j) is forbidden to enter if and only if $i=j$ or $i=j+1$.</p><p>In one round, Nezzar may choose two non-empty sets $X,Y⊆[n]$, and collect gold in cell $(i,j)$ for all $i∈X,j∈Y$. However, he immediately fails if there exists $i∈X$ and $j∈Y$ such that $(i,j)$ is forbidden to enter.</p><p>As a greedy miner, Nezzar would like to enter all but forbidden cells to collect gold. However, he is running out of time! <strong>He can only play the game for at most $50$ rounds.</strong> Can you design an algorithm to solve this problem for him?</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>One line containing one integer $n (2≤n≤3000)$, the size of the grid.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p><strong>Please read this part carefully, as you may fail to pass the test cases if you have formating issues.</strong></p><p>For each round with subsets $X,Y$ being chosen, output elements in $X$ <strong>increasingly</strong> in the first line, and then output elements in $Y$ <strong>increasingly</strong> in the second line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code class="hljs c++"><span class="hljs-number">3</span></code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code class="hljs c++"><span class="hljs-number">1</span><span class="hljs-number">2</span> <span class="hljs-number">3</span><span class="hljs-number">1</span> <span class="hljs-number">2</span><span class="hljs-number">3</span><span class="hljs-number">3</span><span class="hljs-number">1</span></code></pre><h3 id="Note"><a href="#Note" class="headerlink" title="Note"></a>Note</h3><p>It is <strong>allowed</strong> to enter some cells multiple times!</p><h3 id="Hint"><a href="#Hint" class="headerlink" title="Hint"></a>Hint</h3><p>Believe it or not, we can use divide-and-conquer technique to solve this task.</p><p>Let $T(n)$ denote the number of rounds we need to solve the above task with parameter $n$. Notice that $T(n)=T(n/2)+O(1)$ implies $T(n)=O(log⁡n)$, and we may need an algorithm satisfying this recurrence to solve the problem.</p><h3 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h3><p>有一个$n×n$的棋盘，在主对角线的两排是不允许开采的禁区，如下图。每一次我们可以选两个横纵坐标的集合$X$和$Y$。对于两个集合所有元素组成的点$(x, y)$进行开采。注意，这个点不可以是禁区。可以重复开采同一个点，但是总选择次数不可以超过50次（最多选100个集合）。任何有效的开采方法都会被判对。</p><p><img src="/img/DS/棋盘.png" alt="矿区"></p><h3 id="Naive-Solution"><a href="#Naive-Solution" class="headerlink" title="Naive Solution"></a>Naive Solution</h3><p>刚开始看这道题，以为这道题非常简单。因为感觉一眼就可以看出分治为左上角和右下角两个部分。然后写出了以下这样的代码：</p><ul><li>对于只有一个可开采的区域，直接返回这个开采的结果（下面的代码没写出来。。。）</li><li>对于两个的情况，开采右上角；</li><li>然后分奇偶情况，做不同的分割；</li></ul><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;iostream&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-keyword">int</span> cnt = <span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">miner</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> up, <span class="hljs-keyword">int</span> down)</span></span>&#123;    <span class="hljs-keyword">if</span>(s == <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">if</span>(s == <span class="hljs-number">2</span>) &#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, up);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, right);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;cnt=%d\n&quot;</span>, cnt++);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">int</span> tmp = (s+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;    <span class="hljs-keyword">if</span>(s%<span class="hljs-number">2</span> != <span class="hljs-number">0</span>)&#123;        miner(tmp, left, left+tmp<span class="hljs-number">-1</span>, up, down-tmp+<span class="hljs-number">1</span>);        miner(tmp, right-tmp+<span class="hljs-number">1</span>, right, up+tmp<span class="hljs-number">-1</span>, down);        <span class="hljs-comment">//右上</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;s-tmp; i++)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, up+i);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;s-tmp; i++)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, right-tmp+<span class="hljs-number">2</span>+i);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;cnt=%d\n&quot;</span>, cnt++);        <span class="hljs-comment">//左下</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;s-tmp; i++)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, up+tmp+i);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;s-tmp; i++)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, left+i);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;cnt=%d\n&quot;</span>, cnt++);    &#125;    <span class="hljs-keyword">if</span>(s%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;        miner(tmp+<span class="hljs-number">1</span>, left, left+tmp, up, up+tmp);        miner(tmp, right-tmp+<span class="hljs-number">1</span>, right, down-tmp+<span class="hljs-number">1</span>, down);        <span class="hljs-comment">//右上</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;tmp; i++)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, up+i);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;tmp<span class="hljs-number">-1</span>; i++)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, left+tmp+<span class="hljs-number">1</span>+i);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;cnt=%d\n&quot;</span>, cnt++);        <span class="hljs-comment">//左下</span>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;tmp<span class="hljs-number">-1</span>; i++)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, up+tmp+<span class="hljs-number">1</span>+i);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;tmp; i++)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, left+i);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;cnt=%d\n&quot;</span>, cnt++);    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">cin</span> &gt;&gt; n;    miner(n, <span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>, n);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>然后不出意外会发现：这么做消耗的次数比一行一行遍历还要高——因为每一个禁区边缘的区域都转化成了一个小方格去开采。印象中这样的做法大概进行了8700多次……</p><h3 id="我们需要一个更好的方法"><a href="#我们需要一个更好的方法" class="headerlink" title="我们需要一个更好的方法"></a>我们需要一个更好的方法</h3><p>这不一定是更好的方法（因为重复挖了很多方格），但是是最节省集合选择次数（上限50次）的方法。</p><p>主要的思路是——<strong>同时搜索左上、右上、左下、右下，以节省次数</strong>，这样就</p><p>因为在使用分治递归调用的过程中，无法使得每一轮的$X$和$Y$对应被打印，也无法使得不干扰的区域之间同时被搜索，因此使用了<code>vector&lt;vector&lt;int&gt;&gt; solution(50, vector&lt;int&gt;())</code>将策略存储在容器之中；因为对答案有需求，所以我们在进行遍历的时候也要从小次序开始，使用<code>push_back</code>直接把元素放入末尾即可。</p><p>对于$n$比较小的情况，比如$n \leq 7$的情况，仍然是一行一行遍历的情况次数更少；因此并没有进行操作，直接暴力<code>push_back</code>(._.)</p><p>对于$n$比较大的情况我们就不能遍历了。</p><p>我还是使用了<strong>分奇偶</strong>的思路，并同时搜索四块区域。</p><p>先以偶数$n=10$为例：</p><p><img src="/img/DS/偶挖法.png" alt=""></p><p>跟明显：左上和右下是$n = 4$的情况，右上和左下是一个完整的正方形，中间有两行十字形的区域。我的处理策略是：递归处理左上和右下的子情况，耗时：<code>miner(4)</code>；左下和右上完整的正方形：2次（整个挖去正方形）；十字形直接遍历横竖：2次；</p><script type="math/tex; mode=display">log_23000 = 11.5</script><p>那么如果每轮进行4次的话，大致会进行46次；</p><p>至于奇数，以$n=11$为例：不多解释啦，看图就能明白啦</p><p><img src="/img/DS/奇挖法.png" alt=""></p><p>至于我的代码太过丑陋，甚至实现的还和以上说的有一些不一样……(._.)</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;iostream&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<span class="hljs-keyword">int</span> n;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">solutionX</span><span class="hljs-params">(<span class="hljs-number">50</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;())</span></span>;<span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-title">solutionY</span><span class="hljs-params">(<span class="hljs-number">50</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;())</span></span>;<span class="hljs-keyword">int</span> check;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mineSq</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> up, <span class="hljs-keyword">int</span> down)</span></span>&#123;    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=up; i&lt;= down; i++)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left; i&lt;= right; i++)&#123;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, i);    &#125;    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">miner</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> up, <span class="hljs-keyword">int</span> down, <span class="hljs-keyword">int</span> opr)</span></span>&#123;    <span class="hljs-keyword">if</span>(s == <span class="hljs-number">3</span>)&#123;        solutionX[opr].push_back(up);        solutionY[opr].push_back(left+<span class="hljs-number">1</span>);        solutionY[opr].push_back(right);        opr++;        solutionX[opr].push_back(up+<span class="hljs-number">1</span>);        solutionY[opr].push_back(right);        opr++;        solutionX[opr].push_back(up+<span class="hljs-number">2</span>);        solutionY[opr].push_back(left);        opr++;        check = opr;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(s == <span class="hljs-number">4</span>)&#123;        solutionX[opr].push_back(up);        solutionY[opr].push_back(left+<span class="hljs-number">1</span>);        solutionY[opr].push_back(left+<span class="hljs-number">2</span>);        solutionY[opr].push_back(left+<span class="hljs-number">3</span>);        opr++;        solutionX[opr].push_back(up+<span class="hljs-number">1</span>);        solutionY[opr].push_back(left+<span class="hljs-number">2</span>);        solutionY[opr].push_back(left+<span class="hljs-number">3</span>);        opr++;        solutionX[opr].push_back(up+<span class="hljs-number">2</span>);        solutionY[opr].push_back(left);        solutionY[opr].push_back(left+<span class="hljs-number">3</span>);        opr++;        solutionX[opr].push_back(up+<span class="hljs-number">3</span>);        solutionY[opr].push_back(left);        solutionY[opr].push_back(left+<span class="hljs-number">1</span>);        opr++;        check = opr;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(s == <span class="hljs-number">5</span>)&#123;        solutionX[opr].push_back(up);        solutionY[opr].push_back(left+<span class="hljs-number">1</span>);        solutionY[opr].push_back(left+<span class="hljs-number">2</span>);        solutionY[opr].push_back(left+<span class="hljs-number">3</span>);        solutionY[opr].push_back(left+<span class="hljs-number">4</span>);        opr++;        solutionX[opr].push_back(up+<span class="hljs-number">1</span>);        solutionY[opr].push_back(left+<span class="hljs-number">2</span>);        solutionY[opr].push_back(left+<span class="hljs-number">3</span>);        solutionY[opr].push_back(left+<span class="hljs-number">4</span>);        opr++;        solutionX[opr].push_back(up+<span class="hljs-number">2</span>);        solutionY[opr].push_back(left);        solutionY[opr].push_back(left+<span class="hljs-number">3</span>);        solutionY[opr].push_back(left+<span class="hljs-number">4</span>);        opr++;        solutionX[opr].push_back(up+<span class="hljs-number">3</span>);        solutionY[opr].push_back(left);        solutionY[opr].push_back(left+<span class="hljs-number">1</span>);        solutionY[opr].push_back(left+<span class="hljs-number">4</span>);        opr++;        solutionX[opr].push_back(up+<span class="hljs-number">4</span>);        solutionY[opr].push_back(left);        solutionY[opr].push_back(left+<span class="hljs-number">1</span>);        solutionY[opr].push_back(left+<span class="hljs-number">2</span>);        opr++;        check = opr;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(s == <span class="hljs-number">6</span>)&#123;        solutionX[opr].push_back(up);        solutionY[opr].push_back(left+<span class="hljs-number">1</span>);        solutionY[opr].push_back(left+<span class="hljs-number">2</span>);        solutionY[opr].push_back(left+<span class="hljs-number">3</span>);        solutionY[opr].push_back(left+<span class="hljs-number">4</span>);        solutionY[opr].push_back(left+<span class="hljs-number">5</span>);        opr++;        solutionX[opr].push_back(up+<span class="hljs-number">1</span>);        solutionY[opr].push_back(left+<span class="hljs-number">2</span>);        solutionY[opr].push_back(left+<span class="hljs-number">3</span>);        solutionY[opr].push_back(left+<span class="hljs-number">4</span>);        solutionY[opr].push_back(left+<span class="hljs-number">5</span>);        opr++;        solutionX[opr].push_back(up+<span class="hljs-number">2</span>);        solutionY[opr].push_back(left);        solutionY[opr].push_back(left+<span class="hljs-number">3</span>);        solutionY[opr].push_back(left+<span class="hljs-number">4</span>);        solutionY[opr].push_back(left+<span class="hljs-number">5</span>);        opr++;        solutionX[opr].push_back(up+<span class="hljs-number">3</span>);        solutionY[opr].push_back(left);        solutionY[opr].push_back(left+<span class="hljs-number">1</span>);        solutionY[opr].push_back(left+<span class="hljs-number">4</span>);        solutionY[opr].push_back(left+<span class="hljs-number">5</span>);        opr++;        solutionX[opr].push_back(up+<span class="hljs-number">4</span>);        solutionY[opr].push_back(left);        solutionY[opr].push_back(left+<span class="hljs-number">1</span>);        solutionY[opr].push_back(left+<span class="hljs-number">2</span>);        solutionY[opr].push_back(left+<span class="hljs-number">5</span>);        opr++;        solutionX[opr].push_back(up+<span class="hljs-number">5</span>);        solutionY[opr].push_back(left);        solutionY[opr].push_back(left+<span class="hljs-number">1</span>);        solutionY[opr].push_back(left+<span class="hljs-number">2</span>);        solutionY[opr].push_back(left+<span class="hljs-number">3</span>);        opr++;        check = opr;        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(s%<span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">int</span> mid = (s+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left+mid; i&lt;=right; i++)&#123;            solutionY[opr].push_back(i);        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=up; i&lt;=up+mid<span class="hljs-number">-2</span>; i++)&#123;            solutionX[opr].push_back(i);        &#125;        opr++;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left; i&lt;=left+mid<span class="hljs-number">-2</span>; i++)&#123;            solutionY[opr].push_back(i);        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=up+mid; i&lt;=down; i++)&#123;            solutionX[opr].push_back(i);        &#125;        opr++;        solutionX[opr].push_back(up+mid<span class="hljs-number">-1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left; i&lt;=right; i++)&#123;            <span class="hljs-keyword">if</span>(i==left+mid<span class="hljs-number">-2</span> || i==left+mid<span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;            solutionY[opr].push_back(i);        &#125;        opr++;        solutionY[opr].push_back(left+mid<span class="hljs-number">-1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=up; i&lt;=down; i++)&#123;            <span class="hljs-keyword">if</span>(i==up+mid<span class="hljs-number">-1</span> || i==up+mid) <span class="hljs-keyword">continue</span>;            solutionX[opr].push_back(i);        &#125;        opr++;        miner(mid<span class="hljs-number">-1</span>, left, left+mid<span class="hljs-number">-2</span>, up, up+mid<span class="hljs-number">-2</span>, opr);        miner(mid<span class="hljs-number">-1</span>, left+mid, right, up+mid, down, opr);        <span class="hljs-keyword">return</span>;    &#125;    <span class="hljs-keyword">if</span>(s%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;        <span class="hljs-keyword">int</span> mid = s/<span class="hljs-number">2</span>;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left+mid<span class="hljs-number">-1</span>; i&lt;=right; i++)&#123;            solutionY[opr].push_back(i);        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=up; i&lt;=up+mid<span class="hljs-number">-2</span>; i++)&#123;            solutionX[opr].push_back(i);        &#125;        opr++;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left; i&lt;=left+mid; i++)&#123;            solutionY[opr].push_back(i);        &#125;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=up+mid+<span class="hljs-number">2</span>; i&lt;=down; i++)&#123;            solutionX[opr].push_back(i);        &#125;        opr++;        solutionX[opr].push_back(up+mid<span class="hljs-number">-1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left; i&lt;=right; i++)&#123;            <span class="hljs-keyword">if</span>(i==left+mid<span class="hljs-number">-2</span> || i==left+mid<span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;            solutionY[opr].push_back(i);        &#125;        opr++;        solutionX[opr].push_back(up+mid);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left; i&lt;=right; i++)&#123;            <span class="hljs-keyword">if</span>(i==left+mid || i==left+mid<span class="hljs-number">-1</span>) <span class="hljs-keyword">continue</span>;            solutionY[opr].push_back(i);        &#125;        opr++;        solutionX[opr].push_back(up+mid+<span class="hljs-number">1</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=left; i&lt;=left+mid<span class="hljs-number">-1</span>; i++)&#123;            solutionY[opr].push_back(i);        &#125;        opr++;        miner(mid<span class="hljs-number">-1</span>, left, left+mid<span class="hljs-number">-2</span>, up, up+mid<span class="hljs-number">-2</span>, opr);        miner(mid<span class="hljs-number">-1</span>, left+mid+<span class="hljs-number">1</span>, right, up+mid+<span class="hljs-number">1</span>, down, opr);        <span class="hljs-keyword">return</span>;    &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-built_in">cin</span> &gt;&gt; n;    miner(n, <span class="hljs-number">1</span>, n, <span class="hljs-number">1</span>, n, <span class="hljs-number">0</span>);    <span class="hljs-comment">//cout &lt;&lt; check &lt;&lt; endl;</span>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;check; i++)&#123;        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;solutionX[i].size(); j++)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, solutionX[i][j]);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k=<span class="hljs-number">0</span>; k&lt;solutionY[i].size(); k++)&#123;            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d &quot;</span>, solutionY[i][k]);        &#125;        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);    &#125;    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><h3 id="棋盘python生成代码"><a href="#棋盘python生成代码" class="headerlink" title="棋盘python生成代码"></a>棋盘python生成代码</h3><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">grid</span>(<span class="hljs-params">n</span>):</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):            <span class="hljs-keyword">if</span> i==j <span class="hljs-keyword">or</span> i==j+<span class="hljs-number">1</span>:                print(<span class="hljs-string">&quot;ㄨ &quot;</span>, end=<span class="hljs-string">&quot;&quot;</span>)            <span class="hljs-keyword">else</span>:                print(<span class="hljs-string">&quot;⬜ &quot;</span>, end=<span class="hljs-string">&quot;&quot;</span>)        print()<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    grid(<span class="hljs-number">11</span>)</code></pre>]]></content>
    
    
    <categories>
      
      <category>OJ</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分治</tag>
      
      <tag>Divide and Conquer</tag>
      
      <tag>数据结构与算法</tag>
      
      <tag>OJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LargeSumSubarray</title>
    <link href="/2020/12/04/LargeSumSubarray/"/>
    <url>/2020/12/04/LargeSumSubarray/</url>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>Nezzar has recently learnt how to find maximum subarray in the algorithm class. However, he finds out that in many cases, subarray with large sum is sufficient. Thus, he would like to know the number of subarrays with sum <strong>greater than</strong> $t$ for a sequence $a$.</p><p>Formally, you are given a sequence $a_1,a_2, … ,a_n$. </p><p>you are required to calculate the number of pairs $(i,j)$ such that $1 \le i \le j \le n$ and $\sum_{k=i}^j a_k &gt; t$.</p><h3 id="Input"><a href="#Input" class="headerlink" title="Input"></a>Input</h3><p>The first line contains integers $(n,t) ((1 \le n \le 10^6, -10^{15} \le t \le 10^{15}))$; that is, the length of the given sequence and the threshold. The next line contains $n$ integers $a_1,a_2, … ,a_n$ where $(-10^9 \le a_i \le 10^9)$, describing the given sequence.</p><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><p>Output one integer, the number of pairs $(i,j)$ satisfying the requirements mentioned above.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input"></a>Sample Input</h3><pre><code class="hljs python"><span class="hljs-number">5</span> <span class="hljs-number">8</span><span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">-1</span> <span class="hljs-number">4</span></code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output"></a>Sample Output</h3><pre><code class="hljs python"><span class="hljs-number">1</span></code></pre><h3 id="Hints"><a href="#Hints" class="headerlink" title="Hints"></a>Hints</h3><p>You may need to design an $O(n \log n)$ time divide-and-conquer algorithm to pass all testcases. It is recommended to use C/C++ instead of Python or Java.</p><h3 id="大致题意"><a href="#大致题意" class="headerlink" title="大致题意"></a>大致题意</h3><p>给定一串数列$a_n$和某个数$t$，求整串数列中有多少个连续的子串 which 和大于$t$。</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>首先，可以直接使用权值线段数据结构解决本题。但这并非本次OJ的出题目的，因此不多赘述（主要因为我也不会😅）</p><p>所以这次考虑的是使用前缀和分治再用尺取法。</p><p>考虑子序列和时，前缀和$sum[0], sum[1], … , sum[n]$是常用到的方法。从而使得$p$到$q$的子列和可以表示$sum[q] - sum[p]$。对于此题中的情况，我们就需要考虑使得$sum[q] - sum[p] \gt t$，就这样可以转化为$sum[q] \gt t + sum[p]$。</p><p>接下来，考虑一个普通的情况。对于一个前缀和数列$sum[0], sum[1], … , sum[n]$，将它一分为二，左边一半的每个元素逐个与右边一半的每个元素与t之和比较。如果满足$sum[q] \gt t + sum[p]$。说明成立。我们还可以通过排序使得整个过程更加简单。我们在讲数组一分为二的同时还可以进行归并排序。使用C++库函数中的<code>inplace_merge</code>，在原数组的位置并排为升序。</p><p>关于<code>inplace_merge</code>函数，它接受三个位置参数——<code>start</code>，<code>mid</code>，<code>end</code>。操作之后将<code>start</code>到<code>end</code>的位置的数组归并排序。</p><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cstdio&gt;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;algorithm&quot;</span></span><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> ll long long</span><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;ll n;ll t;ll a[<span class="hljs-number">1000001</span>];ll ans=<span class="hljs-number">0</span>;<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> l,<span class="hljs-keyword">int</span> r)</span></span>&#123;    <span class="hljs-keyword">if</span>(l==r) <span class="hljs-keyword">return</span> ;    <span class="hljs-keyword">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;    <span class="hljs-keyword">int</span> i=l,j=m+<span class="hljs-number">1</span>;    merge(l,m);merge(m+<span class="hljs-number">1</span>,r);    <span class="hljs-keyword">for</span>(;i&lt;=m;i++,ans+=r-j+<span class="hljs-number">1</span>)&#123;        <span class="hljs-keyword">for</span>(;j&lt;=r&amp;&amp;a[j]&lt;=t+a[i];) j++;    &#125;    inplace_merge(a+l,a+m+<span class="hljs-number">1</span>,a+r+<span class="hljs-number">1</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;n);    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;t);    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%lld&quot;</span>, &amp;a[i]);        a[i] += a[i - <span class="hljs-number">1</span>];    &#125;    merge(<span class="hljs-number">0</span>, n);    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%lld\n&quot;</span>, ans);    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;&#125;</code></pre><p>如何保证不找到重复的字序列？因为二分的两个部分都是已经搜索结束的，他们内部已经搜索完毕，而不会在后续被重复搜索，因此不会出现多数一次的情况。</p><p>当我们拿到了已经排好序且统计过的两部分，对左边的部分中每一个元素遍历右边部分。因为两个部分已经是升序的，因此遍历的过程中只要找到$sum[q] \gt t + sum[p]$，就可以终止循环，并且将剩余的前缀和数量加入<code>ans</code>就可以了。</p>]]></content>
    
    
    <categories>
      
      <category>OJ</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分治</tag>
      
      <tag>Divide and Conquer</tag>
      
      <tag>数据结构与算法</tag>
      
      <tag>OJ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CoreJava-6</title>
    <link href="/2020/05/03/CoreJava-6/"/>
    <url>/2020/05/03/CoreJava-6/</url>
    
    <content type="html"><![CDATA[<h3 id="Chapter-6-接口、lambda表达式和内部类"><a href="#Chapter-6-接口、lambda表达式和内部类" class="headerlink" title="Chapter 6 接口、lambda表达式和内部类"></a>Chapter 6 接口、lambda表达式和内部类</h3><ol><li>接口是对类的一组需求描述。<ul><li>接口不能含有实例域。</li><li>实现一个接口的步骤：①将类声明为实现给定的接口。②对接口中的所有方法进行定义。</li><li>可以利用泛型为接口提供一个类型参数。</li></ul></li><li>接口的特性<ul><li>接口可以被拓展。</li><li>接口中可以包含常量。</li><li>接口中的域将被自动设为public static final。</li><li>每个类可以拥有多个接口。</li></ul></li><li><strong>一个类只能继承一个类，却可以有多个接口。</strong></li><li>默认方法，可以为接口方法提供一个默认实现。必须用default修饰符标记这样一个方法。</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(T other)</span></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;&#125;</code></pre><ol><li><strong>解决默认方法冲突</strong>。如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法。<ol><li>超类优先。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。</li><li>接口冲突。如果超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型相同的方法，必须覆盖这个方法来解决冲突。</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>Core Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Core Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CoreJava-5</title>
    <link href="/2020/04/26/CoreJava-5/"/>
    <url>/2020/04/26/CoreJava-5/</url>
    
    <content type="html"><![CDATA[<h3 id="Chapter-5-继承"><a href="#Chapter-5-继承" class="headerlink" title="Chapter 5 继承"></a>Chapter 5 继承</h3><ol><li><p>定义子类</p><ul><li>关键字extends表明正在构造的新类派生于一个已存在的类。已存在的类称为<strong>超类、基类、父类；</strong>新类称为<strong>子类、派生类或孩子类。</strong>子类的功能比超类更加丰富。</li><li>通过扩展超类定义子类的时候，仅需要指出子类与超类的不同之处。</li></ul></li><li><p>覆盖方法（override）</p><ul><li>Manager类的getSalary方法不能够直接地访问超类的私有域。只有Employee类的方法才能够访问私有部分。</li><li>super不是一个对象的引用，他只是一个指示编译器调用超类方法的指示器。<pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getSalary</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//double baseSalary = getSalary();这句也不可以，因为getSalary会循环调用；</span>    <span class="hljs-keyword">double</span> baseSalary = <span class="hljs-keyword">super</span>.gerSalary();    <span class="hljs-keyword">return</span> baseSalary + bonus;&#125;</code></pre></li></ul></li><li><p>子类构造器</p><ul><li>语句super(n, s, year, month, day)是“调用超类Employee中含有n、s、year、month、day参数的构造器”的简写形式。</li><li>Manager类不能访问Employee的私有域，所以必须利用Employee类的构造器对这部分私有域进行初始化。通过super实现对超类构造器的调用。<strong>使用super调用构造器的语句必须是子类构造器的第一条语句。</strong></li><li>没有使用super就会自动调用默认（即无参数）构造器。<pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Manager</span><span class="hljs-params">(String name, <span class="hljs-keyword">double</span> salary, <span class="hljs-keyword">int</span> year, <span class="hljs-keyword">int</span> month, <span class="hljs-keyword">int</span> day)</span></span>&#123;    <span class="hljs-keyword">super</span>(name, salary, year, month, day);    bonus = <span class="hljs-number">0</span>;&#125;</code></pre></li></ul></li><li><p>继承层次，继承并不限于一个层次。</p><ul><li>由一个公共超类派生出来的所有类的集合被称为<em>继承层次</em>。</li><li>在继承层次中，从某个特定的类到其祖先的路径被称为该类的<em>继承链</em>。</li></ul></li><li><p>多态</p><ul><li>“is-a”规则的另一种表述法是置换法则。它表明程序中出现超类的任何地方都可以用子类对象置换。</li><li>在Java中，子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换。</li></ul></li></ol><pre><code class="hljs Java">Manager[] manager = <span class="hljs-keyword">new</span> Manager[<span class="hljs-number">10</span>];Employee[] staff = managers;<span class="hljs-comment">//managers和staff引用的是同一个数组。</span></code></pre><ol><li><p><strong><em>理解方法调用</em></strong>，下面假设要调用x.f(args),隐式参数声明为一个类C的对象。</p><ul><li>编译器查看对象的声明类型和方法名。如果存在多个名字为f但参数类型不一样的方法，编译器会意义列举所有C类中名为f的方法和其超类中访问属性为public且名为f的方法（超类的私有方法不可访问）。</li><li>接下来，编译器将查看调用方法时提供的参数类型。如果在所有名为f的方法中存在一个与提供参数类型完全匹配，就选择这个方法。这个过程叫“<strong>重载解析</strong>”。允许类型转换。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报一个错误。</li><li>如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法，我们将这种方法称为<strong>静态绑定</strong>。与此对应的是，调用的方法<strong>依赖于隐式参数的实际类型</strong>，并且在运行时时间<strong>动态绑定</strong>。</li><li>当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个方法。<ul><li>假设x的实际类型是D，它是C类的子类。如果D类定义了方法f(String)，就直接调用它；否则，将在D类的超类中寻找f(String)，以此类推。</li></ul></li><li>方法表：列出了所有方法的签名和实际调用的方法。如果调用super.f(param)，编译器将对隐式参数超类的方法表进行搜索。</li><li>调用 e.getSalary() 的解析过程为：<ul><li>首先，虚拟机提取e的实际类型的方法表。</li><li>接下来，虚拟机搜索定义getSalary签名的类。此时，虚拟机已经知道应该调用哪个方法。</li><li>最后，虚拟机调用方法。</li></ul></li><li>动态绑定有一个重要的特性：无需对现存的代码进行修改，就可以对程序进行扩展。</li><li>在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别是，如果超类方法是public，子类方法一定要声明为public。</li></ul></li><li><p>阻止继承：final类和方法</p><ul><li>不允许扩展的类被称为final类。</li><li>声明格式：public final class Executive extends Manager{ … }</li><li>类中的特定方法也可以被声明为final。如果这样做，子类就不能覆盖这个方法，final类中所有的方法自动地成为final方法。</li><li>将方法或类声明为final主要目的是：确保它们不会在子类中改变语意。</li><li>如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理，这个过程被称为<em>内联</em>。如果子类中有覆盖这个方法，优化器将取消对覆盖方法的内联。</li></ul></li><li><p>强制类型转换，仅需要用一对圆括号将目标类名括起来，并放置在需要转换的对象引用之前就可以了。</p><ul><li>进行类型转换的唯一原因是：在暂时忽视对象的实际类型之后，使用对象的全部功能。</li><li>将一个子类的引用赋给一个超类变量，编译器是允许的。但将一个超类的引用赋给一个子类变量，必须进行类型转换，这样才能够通过运行时的检查。<ul><li><strong>在进行类型转换之前，先查看一下是否能够成功地转换。</strong></li><li><strong>只能在继承层次内进行类型转换</strong></li><li><strong>在将超类转换成子类之前，应该使用instanceof进行检查。</strong></li></ul></li><li>实际上，通过类型转换调整对象的类型并不是一种好的做法。因为多态性的动态绑定机制能够自动地找到对应的方法。在一般情况下，应该尽量少用类型转换和 instanceof 运算符。</li></ul></li></ol><pre><code class="hljs Java">Manager boss = <span class="hljs-keyword">new</span> Manager(...);staff[<span class="hljs-number">0</span>] = boss;staff[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Employee(...);staff[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> Employee(...);Manager boss = (Manager) staff[<span class="hljs-number">0</span>]; <span class="hljs-comment">//Allowed</span>Manager boss = (Manager) staff[<span class="hljs-number">1</span>]; <span class="hljs-comment">//Error</span><span class="hljs-keyword">if</span> (staff[<span class="hljs-number">1</span>] <span class="hljs-keyword">instanceof</span> Manager)&#123;    boss = (Manager) staff[<span class="hljs-number">1</span>];&#125; <span class="hljs-comment">//check the instance before</span></code></pre><ol><li>抽象类，从某种角度按，<em>祖先类</em>更加通用，人们只将它作为派生其他类的基类，而不作为想使用的特定的实例类。<ul><li>为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的。</li><li>许多程序员认为，在抽象类中不能包含具体方法。建议尽量通用的域和方法（不管是否是抽象的）放在超类（不管是不是抽象类）中。</li><li>扩展抽象类可以有两种选择。<ul><li>一种是在抽象类中定义部分抽象类或不定义抽象类方法，这样就必须将子类也标记为抽象类。</li><li>另一种是定义全部的抽象方法，这样一来子类就不是抽象的了。</li></ul></li><li>类即使不含抽象方法，也可以将类声明为抽象类。</li><li>抽象类不能被实例化。也就是说，如果将一个类声明为abstract，就不能创建这个类的对象。</li><li>可以定义一个抽象类的对象变量。但是它只能引用非抽象子类的实例。</li></ul></li></ol><pre><code class="hljs Java">Person p = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Vince Vu&quot;</span>, <span class="hljs-string">&quot;Economics&quot;</span>);</code></pre><ol><li>受访问保护<ul><li>子类也不能访问超类的私有域。</li><li>例如，如果超类Employee中的hireDay声明为protected，而不是私有的，Manager中的方法就可以直接访问它。不过，Manager类中的方法只能够访问Manager对象中的hireDay域，而不能访问其他Employee对象中的这个域。</li></ul></li></ol><div class="table-container"><table><thead><tr><th>修饰词</th><th>本类</th><th>同一个包的类</th><th>继承类</th><th>其他类</th></tr></thead><tbody><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr><tr><td>默认</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table></div><ol><li><p>Object类，它是Java中所有类的始祖，在Java中每个类都是由它扩展而来的。在Java中，只有基本类型不是对象。</p><ul><li>equals方法，用来检测一个对象是否等于另外一个对象。判断两个对象是否具有相同的引用（内容）。<pre><code class="hljs Java"><span class="hljs-comment">//重写equals</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object otherObject)</span></span>&#123;        <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">super</span>.equals(otherObject)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-comment">//super.equals checked that this and otherObject belong to the same class</span>        Manager other = (Manager) otherObject;        <span class="hljs-keyword">return</span> bonus == other.bonus;    &#125;&#125;</code></pre></li></ul></li><li><p>泛型数组列表ArrayList</p><ul><li>ArrayList  是一个采用类型参数的泛型类。为了指定数组列表保存的元素对象类型，需要用一对尖括号将类名括起来加在后面。</li><li>add方法可以将元素添加到数组列表中。</li><li>ensureCapacity(int num)方法，分配一个包含num个对象的内部数组。</li><li>.size()方法类似于length。</li><li>trimToSize() 将数组列表的存储容量削减到当前尺寸。</li><li>.set(i, harry)将第i个元素设置为harry。</li><li>.get()同理。</li><li>.toArray(int[] a)将其拷贝到一个数组中。</li><li>.remove(n)</li><li>将原始ArrayList赋值给一个类型化的ArrayList会得到一个警告。而一个类型化的数组传递给一个普通方法不会出现警告，并且不需要任何的类型转换。</li></ul></li><li>对象包装器与自动装箱（wrapper）<ul><li>自动装箱：list.add(3) 将自动转换成 list.add(Integer.ValueOf(3))，同样的将Integer对象赋值给一个int值的时候，会自动拆箱。</li><li>对象之间的比较要使用equals方法。</li></ul></li><li>枚举类</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Size</span></span>&#123;    SMALL(<span class="hljs-string">&quot;S&quot;</span>), MEDIUM(<span class="hljs-string">&quot;M&quot;</span>),LARGE(<span class="hljs-string">&quot;L&quot;</span>),EXTRA_LARGE(<span class="hljs-string">&quot;XL&quot;</span>);        <span class="hljs-keyword">private</span> String abbreviation;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Size</span><span class="hljs-params">(String abbreviation)</span> </span>&#123;      <span class="hljs-keyword">this</span>.abbreviation = abbreviation;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAbbreviation</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> abbreviation;    &#125;&#125;</code></pre><ol><li>Class类<ul><li>getName方法，返回类的名more字。</li><li>一个Class对象实际上表示的是一个类型，而这个类型未必一定是一种类。例如，int不是类，但int.class是一个Class类型的对象。</li><li>Class类实际上是一个泛型类。例如，Employee.class的类型是Class<Employee>。</li><li>虚拟机为每个类型管理一个Class对象。因此，可以用==运算符实现两个类对象的比较操作。</li><li>newInstance方法乐意用来动态创建一个类的实例。它会调用默认的构造器初始化新创建的对象。如果没有默认的构造器，会抛出一个异常。</li></ul></li><li><p>利用反射分析类的能力。Field、Method和Constructor分别用于描述类的域、方法和构造器。都有getName方法返回项目的名称。</p><ul><li>Field类有一个getType方法，用来返回所描述域所属类型的Class对象。</li><li>Modifier类中isPublic、isPrivate或isFinal判断方法或构造器判断是否是public、private或final。</li><li>Class的getFields、getMethods和getConstructor方法将分别返回类提供的public域、方法和构造器数组。</li></ul></li><li><p><strong>继承的设计技巧</strong></p><ol><li>将公共操作和域放在超类</li><li>不要使用受保护的域</li><li>使用继承实现”is-a”关系</li><li>除非所有继承的方法都有意义，否则不要使用继承</li><li>在覆盖方法时，不要改变预期的行为</li><li>使用多态，而非类型信息</li><li>不要过多使用反射</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>Core Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Core Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CoreJava-4</title>
    <link href="/2020/04/26/CoreJava-4/"/>
    <url>/2020/04/26/CoreJava-4/</url>
    
    <content type="html"><![CDATA[<h3 id="Chapter-4-对象与类"><a href="#Chapter-4-对象与类" class="headerlink" title="Chapter 4 对象与类"></a>Chapter 4 对象与类</h3><ol><li><p>封装：将数据和行为组合在一个包中，并对对象的使用者隐藏了数据的实现方式，对象中的数据成为实例域。</p><ul><li>实现封装的关键在于<strong>绝对不能</strong>让类中的方法直接地访问其他类的实例域。</li><li>封装的优点<ul><li>可以改变内部实现，除了该类的方法之外，不会影响其他的代码。</li><li>更改器方法可以执行错误检查，然而直接赋值不会进行这些处理。</li></ul></li></ul></li><li><p>对象</p><ul><li>对象的三个特性：<ul><li>对象的行为：可以对对象施加哪些操作，或可以对对象施加哪些方法？</li><li>对象的状态：当施加那些方法时，对象如何响应？</li><li>对象标识：如何辨别具有相同行为与状态的不同对象？</li></ul></li><li>对象的行为是用可调用的方法定义的。</li><li>每个对象都有一个唯一的<strong>身份</strong></li></ul></li><li><p>识别类</p><ul><li>从设计类开始，然后再往每个类中添加方法。</li><li>“找动词与名词”</li></ul></li><li><p>类之间的关系</p><ul><li>“依赖（use-a）”：如果一个类的方法操纵另一个类的对象，我们就说一个类依赖另一个类。<strong>应该尽可能将互相依赖的类减到最少——让类之间的耦合度最小。</strong></li><li>“聚合（has-a）”：类A的对象包含类B的对象。</li><li>“继承（is-a）”</li></ul></li><li><p>对象与对象变量：要想使用对象，就必须首先构造对象，并制定其初始状态。然后，对对象应用方法。</p><ul><li>构造器： 特殊的方法，用来构造并初始化对象。</li><li>一个对象变量并没有实际包含一个对象，而仅仅应用一个对象。deadline = birthday两个Date类的对象。</li><li>如果将方法应用到null对象上就会引发运行错误。</li><li>访问器方法——只访问对象而不修改对象的方法；修改的叫做构造器方法。</li></ul></li><li><p>Emplyee类</p><ul><li>最简单的类定义形式为：<pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassName</span></span>&#123;    field;    constructor;    method;&#125;</code></pre></li></ul></li><li><p>构造器</p><ul><li>构造器与类同名。</li><li>每个类可以有一个以上的构造器。</li><li>构造器可以有0个、1个或多个参数。</li><li>构造器没有返回值。</li><li>构造器总是伴随着new操作一起调用。</li><li><strong>不要在构造器中定义与实例域重名的局部变量</strong></li></ul></li><li><p>隐式参数与显式参数</p><ul><li>隐式参数是出现在方法名前的对象；</li><li>显式参数是方法名后面括号里的数值；</li><li>在每一个方法中，关键字</li></ul></li><li><p>一个方法可以访问所属类的所有对象的私有数据。</p></li><li><p>如果一个方法与当前实现机制非常紧密或者需要一个特别的协议以及一个特别的调用次序，最好将这样的方法设置成private的。</p><ul><li>只要方法是私有的，就可以确保它不会被外部的其他类所调用，因此可以将其删去。</li></ul></li><li><p>final实例域</p><ul><li>可以将实例域定义为final，在构建对象的时候必须将它初始化。并且在后面的操作中不能将它修改。</li><li>final修饰符大多应用于基本（primitive）类型域，或不可变类型域（类中的每个方法都不会改变其对象。）</li></ul></li><li><p>静态域： 如果将域定义为static，每个类中只有一个这样的域。而每一个对象对于所有的实例域却都有自己的一份拷贝。</p><ul><li>这个类的所有实例域将共享一个“nextID”域；</li><li>它属于类，不属于一个独立的对象；</li></ul></li><li><p>静态方法：不能向对象实施操作的方法。</p><ul><li>没有隐式的参数。静态方法是没有this参数的方法。</li><li>静态方法可以访问自身类中的静态域；</li><li>建议使用类名来调用静态方法；</li><li>在以下两种情况使用静态方法：<ul><li>一个方法不需要访问对象状态，其所需参数都是通过显示参数提供（如Math.pow）;</li><li>一个方法只需要访问类的静态域（如Employee.getNextID）；</li></ul></li></ul></li><li><p>工厂方法构造对象；</p><ul><li>将类的创建单独放到一个类里进行，这个类就叫做工厂。</li><li>不利用构造器有两个原因：<ol><li>无法命名构造器。构造器的名字必须和类名相同。但是货币的实例需要不同的名字；</li><li>当使用构造器时，无法改变所构造的对象类型。<pre><code class="hljs Java">NumberFormat currencyFormatter = NumberFormat.gerCurrencyInstance();NumberFormat percentFormatter = NumberFormat.getpercentInstance();</code></pre></li></ol></li></ul></li><li><p>main方法：<strong>不需要使用对象调用静态方法</strong></p><ul><li>例子：不需要构造Math对象就可以直接调用Math.pow。</li><li>main方法也是一个静态方法。main方法不对任何对象进行操作。事实上在程序启动时没有任何一个对象。静态的main方法将执行并创建程序所需要的对象。</li></ul></li><li><p>Java总是采用按值调用。</p><ul><li><strong>Java对对象采用的不是引用调用，实际上，对象引用是按值传递的。</strong></li><li>一个方法不能修改一个基本数据类型的参数（按值传递参数）；</li><li>一个方法可以改变一个对象的参数的状态；</li><li><strong>一个方法不能让对象参数引用一个新的对象 </strong></li></ul></li><li><p>重载：有些类可以有多个构造器。如果多个方法有相同的名字、不同的参数，便产生了重载；编译器通过用各个方法给出的参数类型与特定方法调用所使用的值的类型进行匹配来挑选出相应的方法（重载解析）。</p><ul><li>Java允许重载任何方法，不只是构造器方法。完整描述一个方法需要指出方法名以及参数类型。这叫做方法的<strong>签名</strong>。</li></ul></li><li><p>默认域初始化：数值为0、布尔值为false、对象引用为null。</p></li><li><p>无参数构造器，如果在编写一个类时没有编写构造器，系统就会提供一个无参数构造器。这个构造器将所有实数域设置为默认值。</p></li><li><p>显示域初始化，通过重载类的构造器方法，可以采用多种形式设置类的实例域的初始状态。</p></li><li><p>参数变量用同样的名字将实例域屏蔽起来。可以用this.salary的方式访问实例域。回想一下，this指示隐式参数，也就是所构造的对象。</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String name, <span class="hljs-keyword">double</span> salary)</span></span>&#123;    <span class="hljs-keyword">this</span>.name = name;    <span class="hljs-keyword">this</span>.salary = salary;&#125;</code></pre></li><li><p>调用另一个构造器。如果构造器的第一个语句形如this(…)，这个构造器将调用同一个类的另一个构造器。公共的构造器代码部分只编写一次即可。</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(<span class="hljs-keyword">double</span> s)</span></span>&#123;    <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;Emplyee #&quot;</span> + nextID, s);    nextID++; &#125;</code></pre></li><li><p>初始化块。在一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会被执行。</p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> nextID;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary;        <span class="hljs-comment">//object initialization block</span>    &#123;        id = nextID;        nextID++;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String n, <span class="hljs-keyword">double</span> s)</span></span>&#123;        <span class="hljs-keyword">this</span>.name = n;        <span class="hljs-keyword">this</span>.salary = s;    &#125;&#125;</code></pre><p>在上述示例中，无论使用哪个构造器构造对象，id域都在对象初始化模块中被初始化。<strong>运行初始化模块，然后才运行构造器的主体部分。</strong></p></li><li><p>调用构造器的具体处理步骤：</p><ol><li>所有数据域被初始化为默认值。</li><li>按照在类声明中出现的次序，一次执行所有域初始化语句和初始化块。</li><li>如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。</li><li>执行这个构造器的主体。</li></ol></li><li><p>静态初始化块</p><ul><li><strong>初始化块只调用一次（类加载时），而普通初始化块可以调用多次，随着对象的创建而加载。</strong></li><li>一个类中可以有多个静态初始化块和多个普通初始化块；静态初始化块的执行要早于普通初始化块；同一个类型的初始化块的执行顺序取决于定义的先后顺序！</li><li>在一个类中如果有多个不同的初始化块，初始化属性，构造器，执行顺序是：静态初始化块|静态属性初始化 &gt; 普通初始化块|普通属性初始化 &gt; 构造器</li></ul></li><li><p>对象析构与finalize方法</p><ul><li>Java自动回收垃圾，不支持析构器。</li><li>可以为任何一个类添加finalize方法。finalize方法在垃圾回收器清除对象之前调用。在实际应用中，不要依赖于使用finalize方法回收任何短缺的资源，这是因为很难知道这个方法什么时候才能够调用。</li></ul></li><li><p>包，Java允许使用包（package）将类组织起来。</p><ul><li>使用包的主要原因是确保类名的唯一性。</li><li>从编译器的角度来看，嵌套的包之间没有任何关系。例如，java.util包与java.util.jar包毫无关系。每一个都有独立的集合。</li></ul></li><li><p>静态导入</p><ul><li>在源文件顶部，添加一条import static java.lang.System.*;</li><li>可以更简洁比如Math.sqrt可以简写为sqrt</li></ul></li><li><p>将类放入包中，就必须将包的名字放在源文件的开头，包中定义类的代码之前。如果没有在源文件中放置package语句，这个源文件中的类就被放置在一个默认包中。</p></li><li><p>注释</p><ol><li>方法注释<ol><li>@param 变量描述</li><li>@return 描述</li><li>@throws 类描述</li></ol></li><li>通用注释<ol><li>@author 姓名</li><li>@version 版本</li><li>@since 引入特性的版本描述</li><li>@see 引用</li></ol></li><li>包注释单独在包中添加文档</li></ol></li><li><p>类设计技巧</p><ol><li>一定要保证数据私有，绝对不要破坏封装性。</li><li>一定要对数据初始化。</li><li>不要在类中使用过多的基本类型。</li><li>不是所有的域都需要独立的域访问器和域更改器。</li><li>将职责过多的类进行分解。</li><li>类名和方法名要能够体现它们的职责。</li><li>优先使用不可变的类。</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>Core Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Core Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CoreJava-3</title>
    <link href="/2020/04/26/CoreJava-3/"/>
    <url>/2020/04/26/CoreJava-3/</url>
    
    <content type="html"><![CDATA[<h3 id="Chapter-3-基本设计结构"><a href="#Chapter-3-基本设计结构" class="headerlink" title="Chapter 3 基本设计结构"></a>Chapter 3 基本设计结构</h3><ol><li><p>关键字<em>final</em>表示常量。关键字<em>final</em>表示这个变量只能被赋值一次。常量名全部使用大写。</p></li><li><p><em>static final</em>设置类常量。可在一个类的多个方法中使用。如果生命为public，即<em>public</em>，则其他类的方法也可以使用这个常量。</p></li><li><p><em>strictfp</em>关键字标记点方法必须使用严格的浮点计算来生成可再生的结果。</p></li><li><p>String 中的<em>substring</em>方法，s.substring(a, b)得到以a为index开头，到b为止但不包含b的字符串，长度为b-a。</p></li><li><p><em>join</em>方法，String.join(“/“, “S”, “M”, “L”, “XL”);得到的是字符串”S/M/L/XL”。</p></li><li><p>String类对象是不可变字符串。编译器可以让字符串共享。</p></li><li><p>检查字符串是否相等可以用.equals()方法。如果不区分大小写可以用equalsIgnoreCase方法。<em>一定不要使用==运算符来检测两个字符串是否相等。这只能确定两个字符串是否在同一个位置上</em></p></li><li><p>“”是空串，有长度有内容。null表示目前没有任何对象与该变量关联。</p></li><li><p>码点与代码单元</p></li></ol><ul><li>int[] codePoints = str.codePoints().toArray();将字符串转成一个数组。</li><li>String str = new String(codePoints, 0, codePoints.length);将码点数组转化成一个字符串。</li></ul><ol><li><p>构建字符串</p><pre><code class="hljs Java">StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();builder.append(ch);<span class="hljs-comment">// appends a single character</span>builder.append(str);<span class="hljs-comment">// appends a string</span>String completedString = builder.toString();</code></pre></li><li><p>控制台输入</p><pre><code class="hljs Java">Scanner in = <span class="hljs-keyword">new</span> Scanner(System.in);String name = in.nextLine();<span class="hljs-keyword">int</span> age = in.nextInt();</code></pre></li><li><p>文件出入与输出</p><pre><code class="hljs Java"><span class="hljs-comment">//input</span>Scanner in = <span class="hljs-keyword">new</span> Scanner(Paths.get(<span class="hljs-string">&quot;myfile.txt&quot;</span>), <span class="hljs-string">&quot;UTF-8&quot;</span>);<span class="hljs-comment">//output</span>PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(<span class="hljs-string">&quot;myfile.txt&quot;</span>), <span class="hljs-string">&quot;UTF-8&quot;</span>);</code></pre></li><li><p>Java SE 7 开始，switch中的case标签还可以是字符串字面量。</p></li><li><p>break或continue后接label, 可以在中断之后直接跳到label的位置继续执行。</p></li><li><p>大数值BigInteger实现大整数；BigDecimal实现大浮点数。</p><pre><code class="hljs Java">BigInteger a = BigInteger.valueOf(<span class="hljs-number">100</span>);<span class="hljs-comment">//将普通数值转换为大数值；</span>BigInteger c = a.add(b); <span class="hljs-comment">// c = a + b;</span>BigInteger d = c.multiply(b.add(BigInteger.valueOf(<span class="hljs-number">2</span>))); <span class="hljs-comment">// d = c * (b + 2)</span></code></pre></li><li><p>数组</p><pre><code class="hljs Java"><span class="hljs-keyword">int</span>[] a= <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100</span>];</code></pre></li></ol><ul><li>创建一个数组时，所有元素都初始化为0。boolean数组的元素会初始化为false。对象数组会初始化为null。<pre><code class="hljs Java"><span class="hljs-comment">//下面所有字符串都是null</span>String[] names = <span class="hljs-keyword">new</span> String[<span class="hljs-number">10</span>];<span class="hljs-comment">//下面所有字符串都是空串</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) names[i] = <span class="hljs-string">&quot;&quot;</span>;</code></pre></li><li>一旦创建了数组就不能改变它的大小。</li></ul><ol><li>for each 循环</li></ol><ul><li>for (variable : collection) statement<pre><code class="hljs Java">System.out.println(Arrays.toString(a));<span class="hljs-comment">//打印数组；</span></code></pre></li></ul><ol><li>数组拷贝<pre><code class="hljs Java"><span class="hljs-keyword">int</span>[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers, luckynumbers.length);</code></pre></li><li><p>Array.sort(a); 进行排序</p></li><li><p>不规则数组</p><pre><code class="hljs Java"><span class="hljs-keyword">int</span>[][] odds = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[MAX+<span class="hljs-number">1</span>][];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>; n &lt;= MAX; n+<span class="hljs-number">1</span>)    odds[n] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];<span class="hljs-comment">//以上生成的是一个三角形数组</span></code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>Core Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Core Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

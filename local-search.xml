<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>TOEFL-writing-notes</title>
    <link href="/2020/10/20/TOEFL-writing-notes/"/>
    <url>/2020/10/20/TOEFL-writing-notes/</url>
    
    <content type="html"><![CDATA[<h2 id="Getting-Started"><a href="#Getting-Started" class="headerlink" title="Getting Started"></a>Getting Started</h2><div class="table-container"><table><thead><tr><th style="text-align:center">注意事项</th><th style="text-align:center">综合写作</th><th style="text-align:center">独立写作</th></tr></thead><tbody><tr><td style="text-align:center">形式</td><td style="text-align:center">读+听+写</td><td style="text-align:center">写</td></tr><tr><td style="text-align:center">时间</td><td style="text-align:center">20min</td><td style="text-align:center">30min</td></tr><tr><td style="text-align:center">字数</td><td style="text-align:center">150~225</td><td style="text-align:center">&gt;300</td></tr><tr><td style="text-align:center">题材</td><td style="text-align:center">Academic</td><td style="text-align:center">Non-Academic</td></tr><tr><td style="text-align:center">观点</td><td style="text-align:center">Objective</td><td style="text-align:center">Subjective</td></tr></tbody></table></div><h3 id="1-综合写作考试流程"><a href="#1-综合写作考试流程" class="headerlink" title="1. 综合写作考试流程"></a>1. 综合写作考试流程</h3><p>Wrting Based on reading and listening.</p><p>Step1: You will have <strong>3</strong> minute to read a passage.</p><ul><li>Structure: 总分结构，四段式<ul><li>一个总论点+三个分论点+理由细节</li></ul></li></ul><p>Step2: listening (阅读消失)</p><ul><li><p>You will hear a lecture for 2 minutes.</p></li><li><p>Tips: 听力与阅读的关系</p><ol><li>话题相同，观点相反</li><li>一一对应的反驳</li></ol></li></ul><p>Step3: Writing （阅读重现）</p><ul><li>Finish your essay in 20 minutes.</li><li>字数要求：150～225</li></ul><p>怎么写？</p><ul><li>第一段：阅读说了什么，听力不同意；</li><li>第二段：听力不同意阅读的第一个理由 + 听力细节；</li><li>第三段：听力不同意阅读的第二个理由 + 听力细节；</li><li>第四段：听力不同意阅读的第三个理由 + 听力细节；</li></ul><h3 id="2-独立写作"><a href="#2-独立写作" class="headerlink" title="2. 独立写作"></a>2. 独立写作</h3><p>Writing Based on Knowledge and experience.</p><p>Finish your essay in 30 minutes.</p><p>字数要求：300+</p>]]></content>
    
    
    
    <tags>
      
      <tag>TOEFL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>week5-Grade2-fall</title>
    <link href="/2020/10/19/week5-Grade2-fall/"/>
    <url>/2020/10/19/week5-Grade2-fall/</url>
    
    <content type="html"><![CDATA[<h2 id="算法分析与设计"><a href="#算法分析与设计" class="headerlink" title="算法分析与设计"></a>算法分析与设计</h2><h3 id="1-并查集"><a href="#1-并查集" class="headerlink" title="1. 并查集"></a>1. 并查集</h3><h4 id="1-0-等价关系"><a href="#1-0-等价关系" class="headerlink" title="1.0 等价关系"></a>1.0 等价关系</h4><ul><li><p>自反性</p><script type="math/tex; mode=display">a \equiv a</script></li><li><p>对称性</p><script type="math/tex; mode=display">a \equiv b \Rightarrow b \equiv a</script></li><li><p>传递性</p><script type="math/tex; mode=display">a \equiv b, b \equiv c \Rightarrow a \equiv c</script></li><li><p>等价关系形成了一个划分——互不相交。</p></li></ul><h4 id="1-1-动态等价关系"><a href="#1-1-动态等价关系" class="headerlink" title="1.1 动态等价关系"></a>1.1 动态等价关系</h4><ul><li>判断是否等价；</li><li>合并两个等价关系；</li></ul><h3 id="1-2-Union-Find-的数据结构"><a href="#1-2-Union-Find-的数据结构" class="headerlink" title="1.2 Union-Find 的数据结构"></a>1.2 Union-Find 的数据结构</h3><ul><li>使用一棵树表示一个子集，子集中的元素互相等价。</li><li>真个集合划分称为互不相交的子集。</li><li>实现上：<ul><li>使用数组记住每个元素（结点）的父亲结点（的编号）。</li><li>树的根结点的父亲结点为-1。</li></ul></li></ul><h2 id="计算机组织与结构"><a href="#计算机组织与结构" class="headerlink" title="计算机组织与结构"></a>计算机组织与结构</h2><h3 id="1-内存"><a href="#1-内存" class="headerlink" title="1. 内存"></a>1. 内存</h3>]]></content>
    
    
    
    <tags>
      
      <tag>WeeklyReview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>brief-introduction-of-VM</title>
    <link href="/2020/10/16/brief-introduction-of-VM/"/>
    <url>/2020/10/16/brief-introduction-of-VM/</url>
    
    <content type="html"><![CDATA[<h1 id="Brief-Introduction-of-VM"><a href="#Brief-Introduction-of-VM" class="headerlink" title="Brief Introduction of VM"></a>Brief Introduction of VM</h1><h2 id="1-虚拟机简介"><a href="#1-虚拟机简介" class="headerlink" title="1. 虚拟机简介"></a>1. 虚拟机简介</h2><p>虚拟机是一个计算系统。计算系统的最终目标是执行预先编程的逻辑。</p><h3 id="1-1-虚拟机类型"><a href="#1-1-虚拟机类型" class="headerlink" title="1.1 虚拟机类型"></a>1.1 虚拟机类型</h3><ul><li>1⃣️ <strong>完整指令集架构（ISA）虚拟机</strong>，提供<strong>完整的计算机系统ISA模拟或虚拟化</strong>。（例如VitualBox、QEMU等等）</li><li>2⃣️ <strong>应用程序二进制接口（ABI）虚拟机</strong>，<strong>提供客户进程ABI模拟</strong>。</li><li>3⃣️ <strong>虚拟ISA虚拟机</strong>，提供一个运行时引擎，以便虚拟ISA编码的应用程序在其上执行。虚拟ISA通常定义了一套高层的、规模有限的ISA语义，所以不需要虚拟机模拟完整的计算机系统。（例如JVM等等）</li><li>4⃣️ <strong>语言虚拟机</strong>，提供一个运行时引擎来执行以客户语言编写的程序。程序通常以源码形式提供给虚拟机，并没有预先完成编译为机器码。运行时引擎需要解释或翻译程序等。（例如Lisp、Ruby的运行时引擎）</li></ul><p>前两种虚拟机有时被称为“模拟器”。另外两种虚拟机是语言运行时引擎。</p><h3 id="1-2-为什么需要虚拟机"><a href="#1-2-为什么需要虚拟机" class="headerlink" title="1.2 为什么需要虚拟机"></a>1.2 为什么需要虚拟机</h3><ul><li><p>虚拟机改善了（计算机）安全性、（程序）效率和（应用程序）可移植性。</p></li><li><p>对于安全语言（提供了内存安全、运算安全和控制安全特性），虚拟机上必要的。通过安全语言，能尽早安全地捕获程序bug或运行错误。</p><ul><li>内存安全：确保内存中某类型的数据总是遵循对这种类型的限制。</li><li>运算安全：确保对某种类型数据的运算总是遵循对这种类型的限制。</li><li>控制安全：确保代码执行流既不会卡住也不会跑飞。</li></ul><p>安全语言本身并不能满足所有的安全需求。（例如，程序需要虚拟机为它分配一块带有类型的内存，例如某种类型的对象）如果没有虚拟机，安全语言必须引入非安全的操作支持。</p></li><li><p>虚拟机为安全语言的代码和数据提供“托管”。</p></li><li><p>因为安全语言能在编译时或运行时尽早安全地捕获程序中的BUG。因此，提高了开发者的生产率。</p></li></ul><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ul><li>应用程序提供给JVM之后，<strong>JVM的类加载器加载并解析初始类文件，然后把项目放在内存中相应的数据结构中。接下来，JVM把所有的符号饮用解析到直接引用的内存地址。类初始化之后（即调用初始化器之后），JVM调用初始类的main()方法来执行这个应用程序。</strong></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>VM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>week4_Grade2_fall</title>
    <link href="/2020/10/16/week4-Grade2-fall/"/>
    <url>/2020/10/16/week4-Grade2-fall/</url>
    
    <content type="html"><![CDATA[<h2 id="计算机组织与结构"><a href="#计算机组织与结构" class="headerlink" title="计算机组织与结构"></a>计算机组织与结构</h2><h3 id="1-编程作业分析【尽可能不使用API】"><a href="#1-编程作业分析【尽可能不使用API】" class="headerlink" title="1. 编程作业分析【尽可能不使用API】"></a>1. 编程作业分析【尽可能不使用API】</h3><h4 id="1-1-整数int转化为二进制形式"><a href="#1-1-整数int转化为二进制形式" class="headerlink" title="1.1 整数int转化为二进制形式"></a>1.1 整数int转化为二进制形式</h4><ul><li>整数有32位，其中第一位（最左位）位符号位。</li><li>负数的符号位为“1”，与相对应的正数之间的关系为“取反加一”。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">intToBinary</span><span class="hljs-params">(String numStr)</span> </span>&#123;  <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span></span>  <span class="hljs-keyword">int</span> num = Integer.parseInt(numStr);  <span class="hljs-keyword">int</span> sign = <span class="hljs-number">0</span>;  <span class="hljs-keyword">if</span>(num &lt; <span class="hljs-number">0</span>)&#123;    sign = <span class="hljs-number">1</span>;    num = -num;  &#125;  <span class="hljs-keyword">char</span>[] binaryStr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">32</span>];  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">31</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;    <span class="hljs-keyword">if</span>(num % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;      binaryStr[i] = <span class="hljs-string">&#x27;0&#x27;</span>;    &#125; <span class="hljs-keyword">else</span> &#123;      binaryStr[i] = <span class="hljs-string">&#x27;1&#x27;</span>;    &#125;    num /= <span class="hljs-number">2</span>;  &#125;  <span class="hljs-comment">//deal with negative numbers</span>  <span class="hljs-keyword">if</span>(sign == <span class="hljs-number">1</span>)&#123;    <span class="hljs-keyword">int</span> index = <span class="hljs-number">31</span>;    <span class="hljs-keyword">int</span> flg = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(; index&gt;=<span class="hljs-number">0</span>; index--)&#123;      <span class="hljs-keyword">if</span> (flg == <span class="hljs-number">1</span>)&#123;        binaryStr[index] = (binaryStr[index]==<span class="hljs-string">&#x27;1&#x27;</span>)? <span class="hljs-string">&#x27;0&#x27;</span>:<span class="hljs-string">&#x27;1&#x27;</span>;      &#125;      <span class="hljs-keyword">if</span>(binaryStr[index]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;        flg = <span class="hljs-number">1</span>;      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> String.valueOf(binaryStr);&#125;</code></pre><p>​       以上的操作比较简单，主要是把整数字符串转换为整数，再进行“除二取余”的操作。特别的，对于负数再进行一次“取反加一”的操作。这里没有直接用取反操作符，而是使用了<strong>“从末尾的0起到第一个1不变，下一位到起始处取反”</strong>的操作。</p><h4 id="1-2-二进制形式转化为整数int"><a href="#1-2-二进制形式转化为整数int" class="headerlink" title="1.2 二进制形式转化为整数int"></a>1.2 二进制形式转化为整数int</h4><ul><li>与上面的操作相对应。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">binaryToInt</span><span class="hljs-params">(String binStr)</span> </span>&#123;  <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span></span>  <span class="hljs-keyword">char</span>[] bits = binStr.toCharArray();  <span class="hljs-keyword">char</span> sign = bits[<span class="hljs-number">0</span>];  <span class="hljs-keyword">if</span>(sign == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;    <span class="hljs-keyword">int</span> index = <span class="hljs-number">31</span>;    <span class="hljs-keyword">int</span> flg = <span class="hljs-number">0</span>;    <span class="hljs-keyword">for</span>(; index&gt;=<span class="hljs-number">0</span>; index--)&#123;      <span class="hljs-keyword">if</span> (flg == <span class="hljs-number">1</span>)&#123;        bits[index] = (bits[index]==<span class="hljs-string">&#x27;1&#x27;</span>)? <span class="hljs-string">&#x27;0&#x27;</span>:<span class="hljs-string">&#x27;1&#x27;</span>;      &#125;      <span class="hljs-keyword">if</span>(bits[index]==<span class="hljs-string">&#x27;1&#x27;</span>)&#123;        flg = <span class="hljs-number">1</span>;      &#125;    &#125;  &#125;  <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>;  <span class="hljs-keyword">int</span> num = <span class="hljs-number">1</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">31</span>; i&gt;=<span class="hljs-number">0</span>; i--)&#123;    <span class="hljs-keyword">if</span>(bits[i] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;      ans += num;    &#125;    num &lt;&lt;= <span class="hljs-number">1</span>;  &#125;  <span class="hljs-keyword">if</span>(sign == <span class="hljs-string">&#x27;1&#x27;</span>) ans = -ans;  <span class="hljs-keyword">return</span> String.valueOf(ans);&#125;</code></pre><p>​       对1.1中的操作进行逆操纵，先对负数取反加一。然后根据</p><script type="math/tex; mode=display">S = \sum_{i=0}^{n}2^i×s</script><p>求得int的绝对值，在最后根据符号位补上符号。</p><h4 id="1-3-浮点数转二进制【最麻烦的部分】"><a href="#1-3-浮点数转二进制【最麻烦的部分】" class="headerlink" title="1.3 浮点数转二进制【最麻烦的部分】"></a>1.3 浮点数转二进制【最麻烦的部分】</h4><ul><li>浮点数的二进制表示有三个部分——符号（sign）、阶码（exponent）、尾数（fraction）</li><li>浮点数有规格化和非规格化之分；</li><li>在编写的过程中最好参考表格：</li><li><img src="/img/浮点数解释.png" alt=""></li><li>相信有更好的写法！</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">floatToBinary</span><span class="hljs-params">(String floatStr)</span> </span>&#123;  <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span></span>  String sign = <span class="hljs-string">&quot;0&quot;</span>;  String expStr;  String fracStr;  <span class="hljs-keyword">int</span> exponent = <span class="hljs-number">127</span>;  <span class="hljs-keyword">float</span> num = Float.parseFloat(floatStr);  <span class="hljs-keyword">if</span>(num &lt; <span class="hljs-number">0</span>)&#123;    sign = <span class="hljs-string">&quot;1&quot;</span>;    num = -num;  &#125;  <span class="hljs-keyword">while</span> (num-<span class="hljs-number">2</span> &gt; <span class="hljs-number">0</span>)&#123;    num /= <span class="hljs-number">2</span>;    exponent++;    <span class="hljs-keyword">if</span>(exponent == <span class="hljs-number">255</span>) <span class="hljs-keyword">break</span>;  &#125;  <span class="hljs-keyword">while</span> (num-<span class="hljs-number">1</span> &lt; <span class="hljs-number">0</span>)&#123;    num *= <span class="hljs-number">2</span>;    exponent--;    <span class="hljs-keyword">if</span>(exponent &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">break</span>;  &#125;    <span class="hljs-keyword">if</span>(exponent &lt; <span class="hljs-number">1</span>)&#123;    expStr = <span class="hljs-string">&quot;00000000&quot;</span>;  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (exponent == <span class="hljs-number">255</span>)&#123;    expStr = <span class="hljs-string">&quot;11111111&quot;</span>;  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">int</span> expTmp = exponent;    StringBuilder expBuilder = <span class="hljs-keyword">new</span> StringBuilder();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">8</span>; i++)&#123;      <span class="hljs-keyword">if</span>(expTmp % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;        expBuilder.insert(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;1&quot;</span>);      &#125; <span class="hljs-keyword">else</span> &#123;        expBuilder.insert(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;0&quot;</span>);      &#125;      expTmp /= <span class="hljs-number">2</span>;    &#125;    expStr = expBuilder.toString();  &#125;  <span class="hljs-keyword">double</span> f = num - <span class="hljs-number">1</span>;  StringBuilder fracBuilder = <span class="hljs-keyword">new</span> StringBuilder();  <span class="hljs-keyword">if</span>(exponent == <span class="hljs-number">255</span>)&#123;    fracBuilder.append(<span class="hljs-string">&quot;00000000000000000000000&quot;</span>);  &#125; <span class="hljs-keyword">else</span> &#123;    <span class="hljs-keyword">if</span>(exponent == <span class="hljs-number">0</span>)&#123;      f = num / <span class="hljs-number">2</span>;    &#125;    <span class="hljs-keyword">while</span> (f &gt; <span class="hljs-number">0</span>)&#123;      f *= <span class="hljs-number">2</span>;      <span class="hljs-keyword">if</span>(f &gt;= <span class="hljs-number">1</span>)&#123;        fracBuilder.append(<span class="hljs-string">&quot;1&quot;</span>);        f -= <span class="hljs-number">1</span>;      &#125; <span class="hljs-keyword">else</span> &#123;        fracBuilder.append(<span class="hljs-string">&quot;0&quot;</span>);      &#125;    &#125;    <span class="hljs-keyword">int</span> pending = <span class="hljs-number">23</span>-fracBuilder.length();    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;pending; i++)&#123;      fracBuilder.append(<span class="hljs-string">&quot;0&quot;</span>);    &#125;  &#125;  fracStr = fracBuilder.toString();  String ans = sign + expStr + fracStr;  <span class="hljs-comment">//下面几行有点奇怪，貌似是为了过oj而加入的，实际上不应该存在。</span>  <span class="hljs-keyword">if</span>(ans.equals(<span class="hljs-string">&quot;01111111100000000000000000000000&quot;</span>))&#123;    ans = <span class="hljs-string">&quot;+Inf&quot;</span>;  &#125;  <span class="hljs-keyword">if</span>(ans.equals(<span class="hljs-string">&quot;11111111100000000000000000000000&quot;</span>))&#123;    ans = <span class="hljs-string">&quot;-Inf&quot;</span>;  &#125;  <span class="hljs-keyword">return</span> ans;&#125;</code></pre><p>在这段代码中可以看到许多的特判（负数、无穷、溢出等等）。并且用到了许多浮点数比较（这是不好的习惯，但是不得已而为之）。</p><p>主要思路是：</p><p>1⃣️ 首先将负数的符号位设置好，并取它的绝对值。</p><p>2⃣️ 以规格化浮点数为界限，将<strong>整数部分大于等于2（即不是1的）</strong>和<strong>整数部分小于1（即也不是1的，而是0的）</strong>的进行规约。在这里需要注意的是，阶码是有上下界限的，一旦达到255或0，需要终止循环，这个时候得到的数值很可能是【无穷】、【0】、【非规格化浮点数】等等。</p><p>3⃣️ 算阶码部分：如果阶码=0直接置为“00000000”，阶码为255直接置为“11111111”，其余的按照转换为无符号整数的方法直接转化。</p><p>4⃣️ 规约结束，取浮点数的小数部分。在这里需要注意！有一个坑：对于2<sup>-127</sup>来说，它是非规格化的，需要用 2<sup>-126</sup>×0.5来表示。<em>【对于其他的非规格化数也同样如此，因为-126的缘故，我们在上面一步中的规约对于非规格化数其实是多乘来一个2。这样做的目的是使非规格化数和规格化数能够平滑过度】</em>因此，我们需要一个特判，如果阶码为0，那么我们需要把数次乘2之后的num除以一个2，<strong>为了补上-127转化到-126的坑</strong>。然后再进行尾数部分的转化——“乘二取整”，最后补齐23位。对于阶码为255的数，直接将尾数置为全0（无穷）。</p><p>5⃣️ 最后一步修正，将符号位、阶码和尾数三部分字符串组合起来，将正负无穷分别以“+Inf”和“-Inf”的形式表示。</p><h4 id="1-4-二进制转化为浮点数"><a href="#1-4-二进制转化为浮点数" class="headerlink" title="1.4 二进制转化为浮点数"></a>1.4 二进制转化为浮点数</h4><ul><li>这个题有点问题，明明是float，在oj判断的时候精度用的是double【吐槽】。但思路整体上是一样。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">binaryToFloat</span><span class="hljs-params">(String binStr)</span> </span>&#123;  <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span></span>  String sign = binStr.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);  String exponent = binStr.substring(<span class="hljs-number">1</span>, <span class="hljs-number">9</span>);  String fraction = binStr.substring(<span class="hljs-number">9</span>, <span class="hljs-number">32</span>);  String ans = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">if</span>(exponent.equals(<span class="hljs-string">&quot;00000000&quot;</span>) &amp;&amp; fraction.equals(<span class="hljs-string">&quot;00000000000000000000000&quot;</span>))&#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;0.0&quot;</span>;  &#125;  <span class="hljs-keyword">int</span> exp = str2int(exponent, <span class="hljs-number">8</span>);  <span class="hljs-keyword">double</span> frac = <span class="hljs-number">0.0</span>;  <span class="hljs-keyword">if</span>( exp &gt; <span class="hljs-number">0</span> &amp;&amp; exp &lt; <span class="hljs-number">255</span> )&#123;    frac += str2flt(fraction);    frac += <span class="hljs-number">1</span>;    ans = Double.toString((frac * Math.pow(<span class="hljs-number">2</span>, exp-<span class="hljs-number">127</span>)));  &#125;  <span class="hljs-keyword">if</span>( exp == <span class="hljs-number">255</span> &amp;&amp; fraction.equals(<span class="hljs-string">&quot;00000000000000000000000&quot;</span>))&#123;    ans = <span class="hljs-string">&quot;Inf&quot;</span>;    <span class="hljs-keyword">if</span>(sign.equals(<span class="hljs-string">&quot;0&quot;</span>))&#123;      ans = <span class="hljs-string">&quot;+&quot;</span> + ans;    &#125;  &#125;  <span class="hljs-keyword">if</span>( exp == <span class="hljs-number">255</span> &amp;&amp; !fraction.equals(<span class="hljs-string">&quot;00000000000000000000000&quot;</span>))&#123;    ans = <span class="hljs-string">&quot;NaN&quot;</span>;  &#125;  <span class="hljs-keyword">if</span>( exp == <span class="hljs-number">0</span> )&#123;    frac += str2flt(fraction);    ans = Double.toString((frac * Math.pow(<span class="hljs-number">2</span>, exp-<span class="hljs-number">126</span>)));  &#125;  <span class="hljs-keyword">if</span>(sign.equals(<span class="hljs-string">&quot;1&quot;</span>))&#123;    ans = <span class="hljs-string">&quot;-&quot;</span> + ans;  &#125;  <span class="hljs-keyword">return</span> ans;&#125;</code></pre><p>主要思路：</p><p>1⃣️ 特判0；</p><p>2⃣️ 在这里封装了两个函数：将字符串转化为无符号整数，和字符串转化为浮点数。用到的就是之前的“除二取余”和“乘二取整”。</p><p>3⃣️ 根据符号位判断正负。</p><p>4⃣️ 这里的逻辑就简单了很多，根据表判断就可以——规格化数的时候是 2<sup>-127</sup>×(1.<em>f</em>)；正负无穷返回+/-Inf；还有NaN和非规格化数，最后不要忘记补上符号。</p><h4 id="1-5-十进制转化为NBCD"><a href="#1-5-十进制转化为NBCD" class="headerlink" title="1.5 十进制转化为NBCD"></a>1.5 十进制转化为NBCD</h4><ul><li>0～9对应0000～1001，正号用1100，负号用1101。</li><li>共有32位，即8个四位组合，如果不够需要补齐。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">decimalToNBCD</span><span class="hljs-params">(String decimal)</span> </span>&#123;  <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span></span>  <span class="hljs-keyword">char</span>[] numLst = decimal.toCharArray();  StringBuilder ansBuilder = <span class="hljs-keyword">new</span> StringBuilder();  <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;  <span class="hljs-keyword">if</span>(numLst[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;-&#x27;</span>)&#123;    ansBuilder.append(<span class="hljs-string">&quot;1101&quot;</span>);    i = <span class="hljs-number">1</span>;  &#125; <span class="hljs-keyword">else</span> &#123;    ansBuilder.append(<span class="hljs-string">&quot;1100&quot;</span>);  &#125;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">0</span>; j&lt;<span class="hljs-number">7</span>-numLst.length+i;j++)&#123;    ansBuilder.append(<span class="hljs-string">&quot;0000&quot;</span>);  &#125;  String BCD = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">for</span>(; i&lt;numLst.length; i++)&#123;    <span class="hljs-keyword">switch</span> (numLst[i])&#123;      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;0&#x27;</span>:        BCD = <span class="hljs-string">&quot;0000&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;1&#x27;</span>:        BCD = <span class="hljs-string">&quot;0001&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;2&#x27;</span>:        BCD = <span class="hljs-string">&quot;0010&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;3&#x27;</span>:        BCD = <span class="hljs-string">&quot;0011&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;4&#x27;</span>:        BCD = <span class="hljs-string">&quot;0100&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;5&#x27;</span>:        BCD = <span class="hljs-string">&quot;0101&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;6&#x27;</span>:        BCD = <span class="hljs-string">&quot;0110&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;7&#x27;</span>:        BCD = <span class="hljs-string">&quot;0111&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;8&#x27;</span>:        BCD = <span class="hljs-string">&quot;1000&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;9&#x27;</span>:        BCD = <span class="hljs-string">&quot;1001&quot;</span>; <span class="hljs-keyword">break</span>;    &#125;    ansBuilder.append(BCD);  &#125;  <span class="hljs-keyword">return</span> ansBuilder.toString();&#125;</code></pre><p>主要思路：单纯根据每个数字和符号取对应的BCD表示，需要注意的是补上0000满足位数的要求。总体来说相对简单。</p><h4 id="1-6-NBCD转化为十进制数"><a href="#1-6-NBCD转化为十进制数" class="headerlink" title="1.6 NBCD转化为十进制数"></a>1.6 NBCD转化为十进制数</h4><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">NBCDToDecimal</span><span class="hljs-params">(String NBCDStr)</span> </span>&#123;  <span class="hljs-comment">//<span class="hljs-doctag">TODO:</span></span>  StringBuilder strBuilder = <span class="hljs-keyword">new</span> StringBuilder();  String BCD = <span class="hljs-string">&quot;&quot;</span>;  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;NBCDStr.length()-<span class="hljs-number">3</span>; i+=<span class="hljs-number">4</span>)&#123;    String swt = NBCDStr.substring(i, i+<span class="hljs-number">4</span>);    <span class="hljs-keyword">switch</span> (swt)&#123;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;0000&quot;</span>:        BCD = <span class="hljs-string">&quot;0&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;0001&quot;</span>:        BCD = <span class="hljs-string">&quot;1&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;0010&quot;</span>:        BCD = <span class="hljs-string">&quot;2&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;0011&quot;</span>:        BCD = <span class="hljs-string">&quot;3&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;0100&quot;</span>:        BCD = <span class="hljs-string">&quot;4&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;0101&quot;</span>:        BCD = <span class="hljs-string">&quot;5&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;0110&quot;</span>:        BCD = <span class="hljs-string">&quot;6&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;0111&quot;</span>:        BCD = <span class="hljs-string">&quot;7&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;1000&quot;</span>:        BCD = <span class="hljs-string">&quot;8&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;1001&quot;</span>:        BCD = <span class="hljs-string">&quot;9&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;1100&quot;</span>:        BCD = <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-keyword">break</span>;      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;1101&quot;</span>:        BCD = <span class="hljs-string">&quot;-&quot;</span>; <span class="hljs-keyword">break</span>;    &#125;    strBuilder.append(BCD);  &#125;  <span class="hljs-keyword">while</span> (strBuilder.indexOf(<span class="hljs-string">&quot;0&quot;</span>)==<span class="hljs-number">0</span> &amp;&amp; strBuilder.length()&gt;<span class="hljs-number">1</span>)&#123;    strBuilder.delete(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);  &#125;  <span class="hljs-keyword">while</span> (strBuilder.indexOf(<span class="hljs-string">&quot;-&quot;</span>)==<span class="hljs-number">0</span> &amp;&amp; strBuilder.indexOf(<span class="hljs-string">&quot;0&quot;</span>)==<span class="hljs-number">1</span> &amp;&amp; strBuilder.length()&gt;<span class="hljs-number">1</span>)&#123;    strBuilder.delete(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);  &#125;  <span class="hljs-keyword">return</span> strBuilder.toString();&#125;</code></pre><p>主要思路：每四个进行对应，将其转化为十进制的字符串。需要注意的是！因为32位的NBCD码要求，一些数字字符串中会有无用的0产生。需要将它们去除掉，在这里我使用的是——【对正数：第一位为0就去掉；对负数：当第一位为‘-’，第二位为0就去掉第二位的0。进行循环。】</p><p>总体来说，这次的作业有不少细节需要注意，会有一些小的细节的坑需要规避。比如浮点数转化为二进制字符串，如果不对太大的数字进行无穷的转换，就很可能在代码中产生死循环。以及负数的考虑：负数乘2再减1在数轴上会越来越偏离原点，导致死循环！还有规格化数到非规格化数到跳跃也是值得注意的重难点。</p><h2 id="算法设计与分析"><a href="#算法设计与分析" class="headerlink" title="算法设计与分析"></a>算法设计与分析</h2><h3 id="1-Hashing"><a href="#1-Hashing" class="headerlink" title="1. Hashing"></a>1. Hashing</h3><ul><li>Hashing的开销——几乎常量时间：O(1+α)</li></ul><h4 id="1-1-Collision-Handling"><a href="#1-1-Collision-Handling" class="headerlink" title="1.1 Collision Handling"></a>1.1 Collision Handling</h4><h5 id="1-1-Closed-Address"><a href="#1-1-Closed-Address" class="headerlink" title="1.1 Closed Address"></a>1.1 Closed Address</h5><ul><li><p>list在某一个空间的平均长度为<em>n</em>/<em>m</em>；</p></li><li><p>总共开销：Θ(1+ <em>n</em>/<em>m</em>)</p></li><li><p><strong>分析</strong>：对于一次成功的搜索，x<sub>i</sub>的可能性为1/n。对于给定的x<sub>i</sub>，被检测到的元素为<em>t+1</em>次（<em>t</em>是被插入同一个区域的元素数）。对于任意j，x<sub>j</sub>被插入同一个地方的可能性是<em>1/m</em>，因此花销为：</p><script type="math/tex; mode=display">1+\frac{1}{n}\sum_{i=1}^n(1+\sum_{j=i+1}^{n}\frac{1}{m})</script><p>1/m的和是“在要搜索的元素之前的链表中的元素数量”。计算结果大致是：</p><script type="math/tex; mode=display">\Theta(1+\alpha)</script></li></ul><h5 id="1-2-Open-Address"><a href="#1-2-Open-Address" class="headerlink" title="1.2 Open Address"></a>1.2 Open Address</h5><ul><li>不使用链表，所有的元素都存在哈希表中。</li><li>用”rehashing”来解决冲突。</li></ul><h5 id="1-3-Array-Doubling"><a href="#1-3-Array-Doubling" class="headerlink" title="1.3 Array Doubling"></a>1.3 Array Doubling</h5><ul><li><p>allocate a block of size <em>2size</em>; move all item into new table;</p></li><li><p>花销：size</p></li><li><p>执行n次操作，总共花销：</p><script type="math/tex; mode=display">\sum_{i=1}^nc_i{\leq}n+\sum_{j=0}^{log{n}}2^j<3n</script></li><li><p>每一个doubling的操作可以均摊到前面的每一次插入，足够多的准备。（均摊分析）</p></li></ul><h5 id="1-4-Amortized-Analysis"><a href="#1-4-Amortized-Analysis" class="headerlink" title="1.4 Amortized Analysis"></a>1.4 Amortized Analysis</h5><ul><li><em>amortized cost = actual cost + accounting cost</em></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>WeeklyReview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>week3_Grade2_fall</title>
    <link href="/2020/09/26/week3-Grade2-fall/"/>
    <url>/2020/09/26/week3-Grade2-fall/</url>
    
    <content type="html"><![CDATA[<h2 id="算法设计与分析"><a href="#算法设计与分析" class="headerlink" title="算法设计与分析"></a>算法设计与分析</h2><h3 id="1-红黑树"><a href="#1-红黑树" class="headerlink" title="1. 红黑树"></a>1. 红黑树</h3><p><a href="https://www.jianshu.com/p/e136ec79235c">30张图彻底理解红黑树</a></p><h4 id="1-1-红黑树定义"><a href="#1-1-红黑树定义" class="headerlink" title="1.1 红黑树定义"></a>1.1 红黑树定义</h4><ul><li>基本限制：<ul><li>满足二叉搜索树；</li><li>每个节点要么是黑色的，要么是红色的；</li><li>所有的外部节点都是黑色的（每个叶子结点【NIL】是黑色）；</li><li>颜色限制：红色结点没有红色的子节点（每个红色结点的两个子节点一定都是黑色的）；</li><li>黑色高度限制：每个从给定结点u到外部节点的路径的黑色长度相等。（任意一结点到每个叶子结点到路径都包含数量相同的黑结点）<ul><li>推论：如果一个结点存在黑子节点，那么该结点肯定有两个子节点；</li></ul></li><li>根结点是黑色的；</li></ul></li><li>ARB tree (Almost-red-black tree)<ul><li>根结点是红色的；</li></ul></li><li>递归定义<ul><li>约定高度为h的红黑树为RB<sub>h</sub>，高度为h的Almost-red-black Tree为ARB<sub>h</sub></li><li>一个二叉树是ARB<sub>h</sub>，那么<ul><li>根结点是红色的；</li><li>左右子树都是RB<sub>h-1</sub></li></ul></li><li>一个二叉树是RB<sub>h</sub>，那么<ul><li>根结点是黑色的；</li><li>左右子树是RB<sub>h-1</sub>或ARB<sub>h</sub></li></ul></li></ul></li></ul><h4 id="1-2-红黑树的插入"><a href="#1-2-红黑树的插入" class="headerlink" title="1.2 红黑树的插入"></a>1.2 红黑树的插入</h4><ul><li>```c++<br>RBtree rbtInset(RBtree oldRBtree, Element newElement){<br>  InsReturn ans = rbtIns(oldRBtree, newNode);<br>  if(ans.newTree.color != black){<pre><code>ans.newTree.color = black; //黑高度增加的途径。</code></pre>  }<br>  return ans.newTree;<br>}<pre><code class="hljs xl">- **插入红色结点不会影响黑色高度限制**；【每次插入都不改变黑高度】- 簇：一个黑色结点和所有可从该黑色结点经由非黑色边达到的红色结点组成的集合，称为**簇**。- 冲突簇（Critical cluster）：起因于<span class="hljs-number">3</span>或<span class="hljs-number">4</span>个红色结点的颜色冲突。如果存在一个从根结点开始到达某结点的通路的长度大于<span class="hljs-number">1</span>，那么这个簇称为**冲突簇**。因为一个簇中的所有边都是非黑边，那么存在一条长度为<span class="hljs-number">2</span>的通路说明簇中一个红色结点与另一个红色结点之间有一条边。- 颜色漂移（Color flip）：冲突簇的根结点和它的子结点变换颜色，当没有新的冲突簇出现时，插入结束。（教材原话：We perform a *<span class="hljs-built_in">color</span> flip* <span class="hljs-keyword">with</span> the root of the cluster, call it *r*, <span class="hljs-built_in">and</span> its two children.）对于三个结点的冲突簇情况不能使用颜色漂移。【三个结点的情况使得中间那个结点变为黑色】  - ```c++    void rb_tree_main::colorFlip(rb_tree * old_tree)&#123;      <span class="hljs-comment">//修改根结点的颜色</span>      <span class="hljs-function"><span class="hljs-title">if</span>(old_tree-&gt;</span><span class="hljs-built_in">color</span> == color_black)&#123;        <span class="hljs-function"><span class="hljs-title">old_tree</span>-&gt;</span><span class="hljs-built_in">color</span> = color_red;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-function"><span class="hljs-title">old_tree</span>-&gt;</span><span class="hljs-built_in">color</span> = color_black;      &#125;            <span class="hljs-comment">//修改根的左子结点的颜色</span>      <span class="hljs-function"><span class="hljs-title">if</span>(old_tree-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span>-&gt;</span><span class="hljs-built_in">color</span> == color_black)&#123;        <span class="hljs-function"><span class="hljs-title">old_tree</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span>-&gt;</span><span class="hljs-built_in">color</span> = color_red;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-function"><span class="hljs-title">old_tree</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">left</span>-&gt;</span><span class="hljs-built_in">color</span> = color_black;      &#125;            <span class="hljs-comment">//修改根的右子节点的颜色</span>      <span class="hljs-function"><span class="hljs-title">if</span>(old_tree-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span>-&gt;</span><span class="hljs-built_in">color</span> == color_clack)&#123;        <span class="hljs-function"><span class="hljs-title">old_tree</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span>-&gt;</span><span class="hljs-built_in">color</span> = color_red;      &#125; <span class="hljs-keyword">else</span> &#123;        <span class="hljs-function"><span class="hljs-title">old_tree</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">right</span>-&gt;</span><span class="hljs-built_in">color</span> = color_black;      &#125;    &#125;</code></pre></li></ul><h4 id="1-3-修正红黑树（RepairLeft-和-RepairRight）"><a href="#1-3-修正红黑树（RepairLeft-和-RepairRight）" class="headerlink" title="1.3 修正红黑树（RepairLeft 和 RepairRight）"></a>1.3 修正红黑树（RepairLeft 和 RepairRight）</h4><ul><li><p>ok：不需要修正；</p><ul><li>```c++<br>if(ansLeft.status == status.ok){<br>  ans.new_tree = old_tree;<br>  ans.status = status.ok;<br>  return ans<br>}<br>old_tree-&gt;left = ansLeft.new_tree;<pre><code class="hljs fortran">- rbr：不要调整；要将返回值存入相应的field。  - ```c++    <span class="hljs-keyword">if</span>(ansLeft<span class="hljs-number">.</span><span class="hljs-keyword">status</span> == <span class="hljs-keyword">status</span><span class="hljs-number">.</span>rbr)&#123;      ans<span class="hljs-number">.</span>new_tree = old_tree;      ans<span class="hljs-number">.</span><span class="hljs-keyword">status</span> = <span class="hljs-keyword">status</span><span class="hljs-number">.</span>ok;    &#125;</code></pre></li></ul></li><li><p>brb：如果父结点是黑色的，不修正；否则需要向上调整（若当前不调整，返回的状态为rrb）</p><ul><li>```c++<br>if(ansLeft.status == status.brb){<br>  ans.new_tree = old_tree;<br>  if(old_tree-&gt;color == color_black){<pre><code>ans.status = status.ok;</code></pre>  } else {<pre><code>ans.status = status_rrb;</code></pre>  }<br>}<pre><code class="hljs maxima">- rrb：【**当前的父结点的颜色一定为黑色**】根据oldTree的右（左）子节点的情况进行调整（分别对应<span class="hljs-number">4</span>-node和<span class="hljs-number">3</span>-node两种颜色冲突的情况）；  - ```c++    <span class="hljs-keyword">if</span>(ansLeft.<span class="hljs-built_in">status</span> == <span class="hljs-built_in">status</span>.rrb)&#123;     <span class="hljs-keyword">if</span>(old_tree-&gt;right-&gt;<span class="hljs-built_in">color</span> == color_red)&#123;       colorFlip(old_tree);       ans.new_tree = old_tree;       ans.<span class="hljs-built_in">status</span> = <span class="hljs-built_in">status</span>.brb;     &#125; <span class="hljs-keyword">else</span> &#123;       ans.new_tree = rebalLeft(old_tree, ansLeft.<span class="hljs-built_in">status</span>);       ans.<span class="hljs-built_in">status</span> = rbr;     &#125;    &#125;</code></pre></li></ul></li><li><p>brr：和rrb的处理情况类似；</p></li><li><p>所有的处理都不会对黑高度造成影响；</p></li></ul><h4 id="1-4-红黑树的删除"><a href="#1-4-红黑树的删除" class="headerlink" title="1.4 红黑树的删除"></a>1.4 红黑树的删除</h4><ul><li>只有一个子节点的结点可以直接删除；</li><li><strong>保持颜色限制，调整高度。</strong><ul><li>删除红色结点，黑高度不变，没有任何影响；</li><li>删除黑色结点，该结点所在的子树的黑高度减少了1，需要进行修正。<strong>并且这种修正可能导致更高的子树的黑高度降低，需要继续修正。</strong></li></ul></li><li>删除时，将该结点与它在中序遍历之后的后一个结点互换。删除互换后的该结点。将该结点的右结点代替被删除的集合。</li></ul><h3 id="2-渐进复杂性"><a href="#2-渐进复杂性" class="headerlink" title="2. 渐进复杂性"></a>2. 渐进复杂性</h3><h4 id="2-1-Ο"><a href="#2-1-Ο" class="headerlink" title="2.1 Ο"></a>2.1 <em>Ο</em></h4><ul><li><p>复杂度的上界（包含）</p></li><li><p>判断是否包含在<em>Ο</em>的时候可以使用【洛必达法则】。</p></li><li><p>对数复杂度小于幂函数复杂度！</p></li><li><script type="math/tex; mode=display">logn \in O(n^{\alpha}) ,{\forall}{\alpha}>0</script></li><li><p>幂函数复杂度小于指数复杂度！</p></li><li><script type="math/tex; mode=display">n^k \in O(c^n) ,{\forall}c>0</script></li><li><p>阶乘用斯特林公式处理：</p></li><li><script type="math/tex; mode=display">n!≈\sqrt{2{\pi}n}(\frac{n}{e})^n</script></li></ul><h4 id="2-2-Ω"><a href="#2-2-Ω" class="headerlink" title="2.2 Ω"></a>2.2 Ω</h4><ul><li>复杂度的下界（包含）</li></ul><h4 id="2-3-Θ"><a href="#2-3-Θ" class="headerlink" title="2.3 Θ"></a>2.3 Θ</h4><ul><li>复杂度上界与下界的交集——大致相同于真实复杂度；</li></ul><h4 id="2-4-Ο-Ω-Θ的性质"><a href="#2-4-Ο-Ω-Θ的性质" class="headerlink" title="2.4 Ο, Ω, Θ的性质"></a>2.4 <em>Ο</em>, Ω, Θ的性质</h4><ul><li><p><em>Ο</em>是一个等价关系——有传递性、对称性和自反性；</p></li><li><script type="math/tex; mode=display">O(f+g) = O(max(f,g))</script></li></ul><h4 id="2-5-o-和-ω"><a href="#2-5-o-和-ω" class="headerlink" title="2.5 o 和 ω"></a>2.5 o 和 ω</h4><ul><li>f与它的上界（下界）之间有一段不可忽视的距离。（不能大致相等）不光表示小于（大于），也表示f达不到g。</li></ul><h4 id="2-6-分治递归"><a href="#2-6-分治递归" class="headerlink" title="2.6 分治递归"></a>2.6 分治递归</h4><ul><li><p>将规模为n的问题分解成a个规模为n/b的子问题并递归地求解，并且分解/合成的总开销是f(n)的。</p></li><li><script type="math/tex; mode=display">T(n) = aT(\frac{n}{b})+f(n)</script></li><li><p>主定理：</p><ul><li><script type="math/tex; mode=display">f(n){\in}O(𝑛^{log_𝑏⁡{𝑎−𝜀}})，T(n)\in(𝑛^{log_𝑏⁡𝑎})</script></li><li><script type="math/tex; mode=display">f(n){\in}{\Theta}(𝑛^{log_𝑏⁡{𝑎}})，T(n){\in}{\Theta}(f(n)log(n))</script></li><li><p>具体见《算法导论》。</p></li><li>特别的一个特殊情况：</li></ul><script type="math/tex; mode=display">f(m)\in\Theta(m^Elog^a(m))</script><p>​       它的解为：</p><script type="math/tex; mode=display">T(n)\in\Theta(n^Elog^{a+1}(n))</script></li></ul><h2 id="计算机组成与设计"><a href="#计算机组成与设计" class="headerlink" title="计算机组成与设计"></a>计算机组成与设计</h2><h3 id="1-Carry-Look-Ahead-Adder"><a href="#1-Carry-Look-Ahead-Adder" class="headerlink" title="1. Carry Look Ahead Adder"></a>1. Carry Look Ahead Adder</h3><ul><li>Gate Latency<ul><li>AND：1</li><li>OR：1</li><li>XOR：3</li><li>计算CarryOut需要2个延迟</li></ul></li><li><img src="/img/加法器.png" alt="加法器及其延迟"></li><li>再上图中，计算<em>XY</em>和<em>X+Y</em>（即<em>P</em>和<em>G</em>）需要1个延迟，计算所有的<em>C</em>需要两个延迟，计算所有的<em>S</em>又需要3个延迟。（注：根据之前的推导，任意<em>C<sub>n</sub></em>都可以用<em>P、G、C<sub>n</sub></em>来表示）</li></ul><h3 id="2-Partial-Carry-Look-Ahead-Adder"><a href="#2-Partial-Carry-Look-Ahead-Adder" class="headerlink" title="2. Partial Carry Look Ahead Adder"></a>2. Partial Carry Look Ahead Adder</h3><ul><li><p><img src="/img/部分加法器.png" alt="部分加法器及其延迟"></p></li><li><p>在第一个时间周期内计算出所有的<em>P</em>和<em>G</em>，最右边的第一个CLA计算出<em>C8</em>需要3个延迟，往后的<em>C16</em>和<em>C24</em>都需要两个时间周期，最后计算最后的<em>C</em>和<em>S</em>还需要5个延迟。</p></li></ul><h3 id="3-Addition"><a href="#3-Addition" class="headerlink" title="3. Addition"></a>3. Addition</h3><p><em>overflow</em> = C<sub>n</sub>⊕C<sub>n-1</sub> ? Why?</p><p>证明和分析：如果overflow为0，只有两种情况——正数加正数得到负数和负数加负数得到正数。所以我们可以通过符号位来判断：<em>overflow</em> = X<sub>n</sub>Y<sub>n</sub>~S<sub>n</sub>+~X<sub>n</sub>~Y<sub>n</sub>S<sub>n</sub>，当X<sub>n</sub>Y<sub>n</sub>同时为1的时候，S<sub>n</sub>若为0则溢出。当X<sub>n</sub>Y<sub>n</sub>同时为0的时候，S<sub>n</sub>若为1则溢出。</p><h3 id="4-Subtraction"><a href="#4-Subtraction" class="headerlink" title="4. Subtraction"></a>4. Subtraction</h3><h3 id="5-Multiplication"><a href="#5-Multiplication" class="headerlink" title="5. Multiplication"></a>5. Multiplication</h3><ul><li><p>大概步骤：</p><ul><li>每一步计算部分和；</li><li>右移部分和；</li><li>如果<em>Y<sub>i</sub>=0</em>的话，只移动；</li></ul></li><li><p>Booth算法</p></li><li><script type="math/tex; mode=display">P_{i+1}=2^{-1}×(P_i+X×(Y_i-Y_{i+1}))</script><ul><li>初识情况令Y<sub>0</sub> = 0.</li><li>根据 <em>Y<sub>i+1</sub> - Y<sub>i</sub></em> 来判断是 <em>+X，-X，+0</em></li><li>右移部分和；</li><li>重复第二步和第三步；</li></ul></li><li><p>为了使结果正确，每一步应当使用算数右移。补充上去的符号位在计算出结果的符号位会被舍去。</p></li></ul><h3 id="6-Division"><a href="#6-Division" class="headerlink" title="6. Division"></a>6. Division</h3><ul><li>将被除数（remainder）的左边补上<em>n</em>位的<strong>符号位</strong>，除数左边补上<em>n</em>位的0，每一次将除数减被除数，再右移除数一位，若差大于等于0，则在此处的商置为1，将商左移一位。（原始版本）<ul><li>（remainder和quotient合在一起）依然是用division减remainder（前面的n位），如果是异号则用加法。</li></ul></li><li><strong>余数一定和被除数同号</strong>（用除数不断去逼近被除数，但是不能越过它）</li><li>当除数和被除数异号的时候，每次操作的减法变为<em>加法</em>。</li><li>若每次的加法或减法溢出，则做逆操作使得被除数恢复（recover）。</li><li>如果被除数和除数的异号的，我们需要对商修正——取反加一。</li><li><img src="/img/除法.png" alt="除法符号表"></li><li><strong>将错就错版本</strong>：<ul><li>符号扩展n位，然后存储在余数-商寄存器；</li><li>如果被除数和除数有相同的符号做减法，否则做加法：<ul><li>如果余数和除数有相同的符号，<em>Q<sub>n</sub></em>为1，反之为0。</li></ul></li><li>如果余数和除数有相同的符号，那么 <em>R<sub>i+1</sub> = 2R<sub>i</sub> - Y</em> ，否则 <em>R<sub>i+1</sub> = 2R<sub>i</sub> + Y</em> （注：有相同符号说明不需要补上之前错减的操作，继续-Y就可以；若不同说明需要减去之前的操作，因为前面已经错减了，左移*2之后，加上一个Y就可以）<ul><li>如果新的余数和除数有相同的符号，将商置为1，否则置为0。</li></ul></li><li>重复。</li></ul></li></ul><h3 id="7-浮点数运算"><a href="#7-浮点数运算" class="headerlink" title="7. 浮点数运算"></a>7. 浮点数运算</h3><ul><li>对阶</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>WeeklyReview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TOEFL_reading_notes</title>
    <link href="/2020/09/22/TOEFL-reading-notes/"/>
    <url>/2020/09/22/TOEFL-reading-notes/</url>
    
    <content type="html"><![CDATA[<h3 id="题型一：Vocabulary-Questions"><a href="#题型一：Vocabulary-Questions" class="headerlink" title="题型一：Vocabulary Questions"></a>题型一：Vocabulary Questions</h3><p>only one of those meanings is relevant.</p><h4 id="做题方法"><a href="#做题方法" class="headerlink" title="做题方法"></a>做题方法</h4><ul><li>认识要选对；</li><li>没有不认识的；</li><li>求同：沾边就对；不存异：不做同义词辨析。</li></ul><h4 id="练习方法"><a href="#练习方法" class="headerlink" title="练习方法"></a>练习方法</h4><p>题干一个词 + 选项四个词 =&gt; 查英文词典记住；</p><h3 id="题型二：Sentence-Simplification-Questions"><a href="#题型二：Sentence-Simplification-Questions" class="headerlink" title="题型二：Sentence Simplification Questions"></a>题型二：Sentence Simplification Questions</h3><p>essential meaning.</p><h4 id="做题方法-1"><a href="#做题方法-1" class="headerlink" title="做题方法"></a>做题方法</h4><ol><li><p>确定题干句子的逻辑关系：</p><ul><li><p>逻辑关系词：1. 连词，2. 副词</p></li><li><p>感情色彩</p></li></ul></li><li><p>确定和逻辑关系相关的语义；</p></li><li>选择逻辑或者相关语义一致的选项；</li></ol><ul><li>常考逻辑：因果、比较、否定、最高级<ul><li>Because / so;</li><li>Lead to / cause;</li><li>encourage;</li><li>be responsible for;</li></ul></li><li>转折：but / while / whereas</li><li>让步：though / despite / albeit</li><li>条件：if / unless</li><li>并列：and / as well as</li></ul><p>逻辑作用的对象：</p><ul><li>因果：原因、结果；</li><li>比较：主题、对象；</li><li>否定、最高级</li></ul><p><strong>原则最简化 </strong> &amp;&amp;  <strong>先逻辑，后语意</strong></p><h3 id="题型三：Factual-Information-Questions"><a href="#题型三：Factual-Information-Questions" class="headerlink" title="题型三：Factual Information Questions"></a>题型三：Factual Information Questions</h3><p>explicitly stated <strong>明确提及</strong>            mentioned only in part of the passage.</p><p>Often the relevant information is in one or two sentences. <strong>在文章某一部分一到两句话明确提及的事实信息。</strong></p><h4 id="做题方法-2"><a href="#做题方法-2" class="headerlink" title="做题方法"></a>做题方法</h4><ul><li>先读一段文章，后做该段的题；</li><li>顺序：事实信息 ——&gt; 题干 ——&gt; 一到两句话 ——&gt; 选项 ——&gt; 排除（选对的）</li><li>干扰选项：① 答非所问；② 无中生有；③ 虚假比较；</li></ul><ol><li><p>定位【缩小阅读范围】</p><ul><li><p>定位方法：</p><p>a. 名词 &gt; 动词、形容词、副词；</p><p>b. 特殊 &gt; 普通；</p><p>​        特殊情况：</p><p>​                ① 题干定位线索在段落中多次出现；</p><p>​                ② 线索是 title 或 topic 用选项定位排除法；</p><p>c. 对名词修饰也在定位范围内；</p><p>d. 特殊疑问词（where/when/why/how）.</p></li></ul></li><li><p>精读：单词\语法\逻辑</p></li><li><p>同义改写：原文和选项之间同意信息点的对应；</p><ul><li>选项和原文信息点对应更多更重要的是正确选项</li></ul></li></ol><p><strong><em>切忌：过度推断；生活经验</em></strong></p><p>典型错误选项：</p><ul><li>答非所问：题干定位线索和题目问题不一致，题干中出现表示因果关系的逻辑关系词；Because/so/since/for/as a result of … 基于因果关系，扩大阅读范围。</li><li>无中生有：选项改变了原文动作主题和对象、感情色彩、动名词搭配、并列连词、否定词；</li><li>虚假比较：选项中出现了原文中没有的比较级、最高级、绝对化（absolute/extreme/definite/total/entire/all/every/any/never）、范围扩张（some/many/plenty/majority/major/most of）</li><li>优先认定包含虚假比较的选项为错误选项，如果原文有一一对应则该选项为正确选项；</li></ul><h3 id="题型四：Negative-Factual-Information-Questions"><a href="#题型四：Negative-Factual-Information-Questions" class="headerlink" title="题型四：Negative Factual Information Questions"></a>题型四：Negative Factual Information Questions</h3><h4 id="做题方法："><a href="#做题方法：" class="headerlink" title="做题方法："></a>做题方法：</h4><ul><li>定位</li><li>精读</li><li>排除</li><li>对应规则：<ul><li>对应原文集中举例：注意平行结构；</li><li>对应原文分散举例：选项排除法；</li><li>段落中存在多项并列的内容，往往有排除题；</li></ul></li></ul><h3 id="题型五：Inference-Questions"><a href="#题型五：Inference-Questions" class="headerlink" title="题型五：Inference Questions"></a>题型五：Inference Questions</h3><p>正确答案不在文章中提及。</p><h4 id="做题方法：-1"><a href="#做题方法：-1" class="headerlink" title="做题方法："></a>做题方法：</h4><ul><li>定位</li><li>精读</li><li>排除</li><li>因果推断：结果 ≈ 原因</li></ul><h3 id="题型七：Insert-Text-Question"><a href="#题型七：Insert-Text-Question" class="headerlink" title="题型七：Insert Text Question"></a>题型七：Insert Text Question</h3><p>grammatical connections.</p><p>时间压力大，不按文章顺序出</p><p>指代、逻辑、重复</p><h4 id="做题方法：-2"><a href="#做题方法：-2" class="headerlink" title="做题方法："></a>做题方法：</h4><ul><li>线索提取 =&gt; 题干</li><li>线索匹配 =&gt; 原文</li><li>连贯性检查 =&gt; 题干 + 原文</li></ul><p>代词：代词所在句子位于被指代名字所在句子的后面。</p><p>逻辑：</p><ul><li>词性：<ul><li>conj. ——&gt; 句子内 ——&gt; 简化；</li><li>adv. ——&gt; 句间 ——&gt; 插入；</li></ul></li><li>感情色彩：A but B<ul><li>正面：因果（感情色彩一致）</li><li>反面：转折、让步、比较；</li></ul></li></ul><p>重复信息：</p><ul><li>标志词：<ul><li>that is to say / that is / namely / in other words 换句话说；</li><li>in fact / indeed : give extra details to the topic just mentioned.；</li><li>similarly / likewise : 相似的，相同的；</li><li>举例：for example 观点 =&gt; 细节（例子）</li></ul></li><li>无标志词：同义词、同义替换；</li><li>“观点阐述”原则：概括、抽象在前；具体，细节在后；</li></ul><h5 id="题干-——-gt-找线索"><a href="#题干-——-gt-找线索" class="headerlink" title="题干 ——&gt; 找线索"></a>题干 ——&gt; 找线索</h5><ul><li>指代 ——&gt; pron. 往后放</li><li>逻辑 ——&gt; 正/反 往反放；</li><li>重复 ——&gt; 往后放；</li></ul><h3 id="题型八：Rhetorical-Purpose-Question"><a href="#题型八：Rhetorical-Purpose-Question" class="headerlink" title="题型八：Rhetorical Purpose Question"></a>题型八：Rhetorical Purpose Question</h3><p>{具体信息，段落功能，段落关系}</p><h4 id="做题方法：-3"><a href="#做题方法：-3" class="headerlink" title="做题方法："></a>做题方法：</h4><ol><li>定位</li><li>当前句是观点，是答案；</li><li>当前句不是观点，看前一句；</li><li>前一句也不是观点，看段落主旨句；</li></ol><p>当前句包含明确举例词的时候，看前一句</p><p>当前句中没有明确举例词的时候，判断：</p><ul><li>举例主题是具体细节内容；</li><li>和前一句话没有观点冲突；</li></ul><h5 id="目的题："><a href="#目的题：" class="headerlink" title="目的题："></a>目的题：</h5><p>当前句</p><ul><li>举例词——前一句</li><li>无举例词<ul><li>具体/无冲突——前一句</li><li>冲突——当前句</li></ul></li></ul><h5 id="段落功能"><a href="#段落功能" class="headerlink" title="段落功能"></a>段落功能</h5><p>What is the purpose/function/organization of the paragraph?</p><p>What is the relationship between Para1. and the rest of the passage in the larger discussion of xxx?</p><p>正确选项：main idea + 紧密相关的重要内容；</p><h5 id="段落关系"><a href="#段落关系" class="headerlink" title="段落关系"></a>段落关系</h5><p>Relationship between p1 and p2?</p><ol><li>阅读范围：两句话——前段末句和后段首句；</li><li>关系类型：顺承；转折/对比；举例解释<ul><li>顺承 =&gt; 语意链接；</li><li>转折/对比 =&gt; 逻辑关系词 however/on the contrary</li><li>举例 =&gt; for example</li><li>解释：explain/illustrate/elaborate/interpret</li></ul></li><li>判断方式<ul><li>变化：change/move/shift/migration/become/deteriorate/diminish</li><li>重要：important/significant</li><li>影响：effect/influence/impact</li><li>关系：relate/connect</li></ul></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>TOEFL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>week2_Grade2_fall</title>
    <link href="/2020/09/18/week2-Grade2-fall/"/>
    <url>/2020/09/18/week2-Grade2-fall/</url>
    
    <content type="html"><![CDATA[<h2 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h2><p>​        上个期末考试期结束，就打算每周做一个小的总结，一是方便后续的总复习，而来能够 push 自己按时按计划复习。本学期主要学习的课程有《计组》、《算法》、《数据结构》、《数据科学基础》还有《线代》。数学课的内容重点在于刷题，不会像其他课一样总结主要概念和框架，可能会总结一些偏重难点。尽量 push 自己在每天都补充一些内容，以便于在一周的周六内发布。</p><h2 id="算法设计与分析"><a href="#算法设计与分析" class="headerlink" title="算法设计与分析"></a>算法设计与分析</h2><h3 id="0-尾递归"><a href="#0-尾递归" class="headerlink" title="0. 尾递归"></a>0. 尾递归</h3><p>我们常常用尾递归的方式将递归转化为迭代。</p><h4 id="0-0-回顾-SICP-中-Scheme-的尾递归"><a href="#0-0-回顾-SICP-中-Scheme-的尾递归" class="headerlink" title="0.0. 回顾 SICP 中 Scheme 的尾递归"></a>0.0. 回顾 SICP 中 Scheme 的尾递归</h4><p>因为函数式语言的最大特征之一是无法赋值，因此无法使用过程式语言中的 for 或者 while 循环来实现迭代。为了减小开销使得递归的效率更高，Scheme 引入了尾递归。(调用之后释放空间，与传统递归不同)</p><pre><code class="hljs scheme">(<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">fact</span> n)  (<span class="hljs-name"><span class="hljs-builtin-name">define</span></span> (<span class="hljs-name">fact-tail</span> n result)    (<span class="hljs-name"><span class="hljs-builtin-name">if</span></span> (<span class="hljs-name"><span class="hljs-builtin-name">&lt;=</span></span> n <span class="hljs-number">1</span>)        result        (<span class="hljs-name">fact-tail</span> (<span class="hljs-name"><span class="hljs-builtin-name">-</span></span> n <span class="hljs-number">1</span>) (<span class="hljs-name"><span class="hljs-builtin-name">*</span></span> n result))))  (<span class="hljs-name">fact-tail</span> n <span class="hljs-number">1</span>))</code></pre><p>Scheme 中的递归会使用一个辅助函数。每调用一次辅助函数之后，函数不需要在返回到调用者的函数，而是直接带着 result 调用后续的函数。</p><h4 id="0-1-尾递归的基本概念"><a href="#0-1-尾递归的基本概念" class="headerlink" title="0.1. 尾递归的基本概念"></a>0.1. 尾递归的基本概念</h4><ul><li>尾递归：一个递归函数仅仅在运算的最后才递归调用自身，并且调用后直接返回。</li><li><p>尾递归转换为迭代的方法：</p><ul><li>将每个参数转换为变量声明；</li><li>将函数体转换为一个循环体，并且对于基本情况直接返回相应的结果；递归调用时，首先计算新的参数并赋予相关的变量，后面跟上 continue 的语句。</li></ul></li><li><p>e.g.</p><pre><code class="hljs C">Euclid_recursion(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)&#123;<span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> m;    <span class="hljs-keyword">else</span> &#123;        <span class="hljs-keyword">int</span> rem = m % n;        <span class="hljs-keyword">return</span> Euclid_Recursion(n, rem);    &#125;&#125;Euclid_tailRecursion(<span class="hljs-keyword">int</span> m1, <span class="hljs-keyword">int</span> n1)&#123;    <span class="hljs-keyword">int</span> m = m1;    <span class="hljs-keyword">int</span> n = n1;    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)&#123;<span class="hljs-comment">//while(true)模式，一般情况下可以转换为for循环。</span>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> m;        <span class="hljs-keyword">else</span> &#123;            <span class="hljs-keyword">int</span> tmp = n;            n = m % n;            m = n;        &#125;    &#125;&#125;</code></pre></li></ul><h3 id="1-排序问题和排序算法-1"><a href="#1-排序问题和排序算法-1" class="headerlink" title="1. 排序问题和排序算法-1"></a>1. 排序问题和排序算法-1</h3><h4 id="1-1-插入排序（Insertion-Sort"><a href="#1-1-插入排序（Insertion-Sort" class="headerlink" title="1. 1. 插入排序（Insertion Sort)"></a>1. 1. 插入排序（Insertion Sort)</h4><h5 id="1-1-1-插入排序的基本内涵和实现"><a href="#1-1-1-插入排序的基本内涵和实现" class="headerlink" title="1.1.1. 插入排序的基本内涵和实现"></a>1.1.1. 插入排序的基本内涵和实现</h5><ul><li><p>基本情况：n == 1时，不需要排序。</p></li><li><p>递归情况：n &gt; 1时，分成两组——任意数 v 和其余的n-1个数；然后递归地排好剩下的n-1个数，再将v插入到已经排序完成的数列的适当位置，得到排序完成的数组。</p></li><li><p>如何插入？(下面的Insert_Abs就是插入算法)</p><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] Insert_Abs(<span class="hljs-keyword">int</span> v, <span class="hljs-keyword">int</span>[] list)&#123;<span class="hljs-keyword">if</span>(list.length() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> v;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (v &lt;= Head(list)) <span class="hljs-keyword">return</span> &#123;v&#125; + list;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> Head(list) + Insert_Abs(v, Tail(list));&#125;</code></pre></li><li><p>实现</p><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] insert(<span class="hljs-keyword">int</span>[] A)&#123;    <span class="hljs-keyword">int</span> i, j;    <span class="hljs-keyword">int</span> len = A.length;    <span class="hljs-keyword">int</span> target;    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">1</span>; i&lt;len-<span class="hljs-number">1</span>; i++)&#123;        j = i;        target = A[i];<span class="hljs-comment">//等价于ppt中推导时所用到的v</span>        <span class="hljs-keyword">while</span>(j&gt;<span class="hljs-number">0</span> &amp;&amp; target&lt;A[j-<span class="hljs-number">1</span>])&#123;<span class="hljs-comment">//一旦target比前面的元素大，那么就插入它的后面</span>            A[j] = A[--j];<span class="hljs-comment">//否则将元素后移一位，空出位置给target。</span>        &#125;<span class="hljs-comment">//这个算法的实现和课上所讲的略有不同</span>        A[j] = target;<span class="hljs-comment">//这个算法是从前向后插入，课上是从后向前</span>    &#125;    <span class="hljs-keyword">return</span> A;&#125;</code></pre></li></ul><h5 id="1-1-2-插入排序-Insert-函数的循环不变式"><a href="#1-1-2-插入排序-Insert-函数的循环不变式" class="headerlink" title="1.1.2. 插入排序 Insert 函数的循环不变式"></a>1.1.2. 插入排序 Insert 函数的循环不变式</h5><ul><li>初始情况下，从start+1到end是排好序的；</li><li>在经过一次操作之后，从start到end是排好序；</li><li>循环一定是可以终止在 i = len-1的；</li></ul><h5 id="1-1-3-最坏情况分析"><a href="#1-1-3-最坏情况分析" class="headerlink" title="1.1.3. 最坏情况分析"></a>1.1.3. 最坏情况分析</h5><ul><li><p>最坏情况：逆序</p></li><li><p>时间复杂度：Ο(n<sup>2</sup>)</p></li><li><p>平均情况：对于每一个 i ，对应会有 j 个比较次数（内循环）。</p><script type="math/tex; mode=display">\frac{1}{i+1}\sum_{j=1}^{i}j + \frac{1}{i+1}(i) = \frac{i}{2}+1-\frac{1}{i+1}</script><p>求和之后，仍是 Ο(n<sup>2</sup>)。</p></li></ul><h4 id="1-2-快速排序"><a href="#1-2-快速排序" class="headerlink" title="1.2. 快速排序"></a>1.2. 快速排序</h4><h5 id="1-2-1-基本思路和实现"><a href="#1-2-1-基本思路和实现" class="headerlink" title="1.2.1 基本思路和实现"></a>1.2.1 基本思路和实现</h5><ul><li><p>按照某个数进行划分，小于这个数的作为一部分，大于这个数的作为另一部分。</p></li><li><p>采用分划算法 Partition(v, list) 将list分划成两个list：smallerList中的值都小于v，biggerList中都大于等于v。</p></li><li><p>有关实现：</p><ul><li>Partition 函数分割后的值仍然存放在这个区域。</li><li>QuickSort 之后得到的数据仍然存放在相同的区域。</li></ul></li><li><p>以下是“挖坑法”：（均在数组的原地址空间内进行改动）</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span>&#123;  <span class="hljs-keyword">if</span>(end &lt;= start) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> pivotIndex = partition(arr, start, end);    quickSort(arr, start, pivotIndex-<span class="hljs-number">1</span>);    quickSort(arr, pivotIndex+<span class="hljs-number">1</span>, end);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span>&#123;    <span class="hljs-keyword">int</span> pivot = arr[start];    <span class="hljs-keyword">int</span> left = start;    <span class="hljs-keyword">int</span> right = end;    <span class="hljs-keyword">int</span> index = start; <span class="hljs-comment">//挖坑的位置</span>    <span class="hljs-keyword">while</span> (left &lt;= right)&#123;        <span class="hljs-comment">//从右边向左边找到比标记更小的，将它转移到标记的左边</span>        <span class="hljs-keyword">while</span> (left &lt;= right)&#123;            <span class="hljs-keyword">if</span>(arr[right] &lt; pivot)&#123;                arr[left] = arr[right];                index = right;                left++;                <span class="hljs-keyword">break</span>;            &#125;            right--;        &#125;        <span class="hljs-comment">//从左向右找到比标记更大的，将它换转移到标记的右边，若上面发生了更换，那么这里也一定是把Pivot填写在上一个循环挖出的空间中；</span>        <span class="hljs-keyword">while</span> (left &lt;= right) &#123;            <span class="hljs-keyword">if</span> (arr[left] &gt; pivot)&#123;                arr[right] = arr[left];                index = left;                right--;                <span class="hljs-keyword">break</span>;            &#125;            left++;        &#125;    &#125;<span class="hljs-comment">//补上漏洞</span>    arr[index] = pivot;    <span class="hljs-keyword">return</span> index;&#125;</code></pre><ul><li>“指针交换法”：先把pivot以外的元素排好，再把pivot插入到其中相应的位置。</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span>&#123;    <span class="hljs-keyword">if</span>(start &gt;= end) <span class="hljs-keyword">return</span>;    <span class="hljs-keyword">int</span> pivotIndex = partition(arr, start, end);    quickSort(arr, start, pivotIndex-<span class="hljs-number">1</span>);    quickSort(arr, pivotIndex+<span class="hljs-number">1</span>, end);&#125;<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span>&#123;    <span class="hljs-keyword">int</span> pivot = arr[start];    <span class="hljs-keyword">int</span> left = start;    <span class="hljs-keyword">int</span> right = end;    <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-comment">//控制right指针比较并左移</span>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[right]&gt;pivot)&#123;        right--;    &#125;        <span class="hljs-comment">//控制right指针比较并右移</span>        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot)&#123;            left++;        &#125;        <span class="hljs-comment">//交换left和right指向的元素</span>    <span class="hljs-keyword">if</span>(arr[left]&gt;arr[right])&#123;            <span class="hljs-keyword">int</span> p = arr[left];            arr[left] = arr[right];            arr[right] = p;        &#125;    &#125;        <span class="hljs-comment">//pivot和指针重合点交换，大概是中点的位置</span>    <span class="hljs-keyword">int</span> p = arr[left];    arr[left] = arr[start];    arr[start] = p;    <span class="hljs-keyword">return</span> left;&#125;</code></pre><ul><li>可以用“栈”重写非递归形式的快速排序：</li></ul><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span>&#123;    Stack&lt;Map&lt;String, Integer&gt;&gt; quickSortStack = <span class="hljs-keyword">new</span> Stack&lt;Map&lt;String, Integer&gt;&gt;();    Map&lt;String, Integer&gt; rootParam = <span class="hljs-keyword">new</span> HashMap&lt;String, Integer&gt;();    rootParam.put(<span class="hljs-string">&quot;start&quot;</span>, start);    rootParam.put(<span class="hljs-string">&quot;end&quot;</span>, end);    quickSortStack.push(rootParam);      <span class="hljs-keyword">while</span> (!quickSortStack.isEmpty()) &#123;        Map&lt;String, Integer&gt; param = quickSortStack.pop();        <span class="hljs-keyword">int</span> pivotIndex = partition(arr, param.get(<span class="hljs-string">&quot;start&quot;</span>), param.get(<span class="hljs-string">&quot;end&quot;</span>));        <span class="hljs-keyword">if</span>(param.get(<span class="hljs-string">&quot;start&quot;</span>) &lt; pivotIndex-<span class="hljs-number">1</span>)&#123;            Map&lt;String, Integer&gt; leftParam = <span class="hljs-keyword">new</span> HashMap&lt;String, Integer&gt;();            leftParam.put(<span class="hljs-string">&quot;start&quot;</span>, param.get(<span class="hljs-string">&quot;start&quot;</span>));            leftParam.put(<span class="hljs-string">&quot;end&quot;</span>, pivotIndex-<span class="hljs-number">1</span>);            quickSortStack.push(leftParam);        &#125;          <span class="hljs-keyword">if</span>(pivotIndex+<span class="hljs-number">1</span> &lt; param.get(<span class="hljs-string">&quot;end&quot;</span>)) &#123;            Map&lt;String, Integer&gt; rightParam = <span class="hljs-keyword">new</span> HashMap&lt;String, Integer&gt;();            rightParam.put(<span class="hljs-string">&quot;start&quot;</span>, pivotIndex+<span class="hljs-number">1</span>);            rightParam.put(<span class="hljs-string">&quot;end&quot;</span>, param.get(<span class="hljs-string">&quot;end&quot;</span>));            quickSortStack.push(rightParam);        &#125;    &#125;&#125;  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span></span>&#123;    <span class="hljs-keyword">int</span> pivot = arr[start];    <span class="hljs-keyword">int</span> left = start;    <span class="hljs-keyword">int</span> right = end;      <span class="hljs-keyword">while</span> (left &lt; right) &#123;        <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[right]&gt;pivot)&#123;            right--;        &#125;          <span class="hljs-keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt;= pivot)&#123;            left++;        &#125;          <span class="hljs-keyword">if</span>(arr[left]&gt;arr[right])&#123;            <span class="hljs-keyword">int</span> p = arr[left];            arr[left] = arr[right];            arr[right] = p;        &#125;          System.out.println(pivot);    &#125;      <span class="hljs-keyword">int</span> p = arr[left];    arr[left] = arr[start];    arr[start] = p;      <span class="hljs-keyword">return</span> left;&#125;</code></pre></li></ul><h2 id="计算机组织与结构"><a href="#计算机组织与结构" class="headerlink" title="计算机组织与结构"></a>计算机组织与结构</h2><h3 id="1-Introduction-前瞻"><a href="#1-Introduction-前瞻" class="headerlink" title="1. Introduction 前瞻"></a>1. Introduction 前瞻</h3><h4 id="1-1-结构与组织-Architecture-amp-Organization"><a href="#1-1-结构与组织-Architecture-amp-Organization" class="headerlink" title="1.1. 结构与组织 Architecture &amp; Organization"></a>1.1. 结构与组织 Architecture &amp; Organization</h4><h5 id="1-1-1-Architecture-结构"><a href="#1-1-1-Architecture-结构" class="headerlink" title="1.1.1. Architecture 结构"></a>1.1.1. Architecture 结构</h5><ul><li>对程序员可见（visible to programmer）；</li><li>对程序的逻辑加载有直接影响；</li></ul><h5 id="1-1-2-Organization-组织"><a href="#1-1-2-Organization-组织" class="headerlink" title="1.1.2 Organization 组织"></a>1.1.2 Organization 组织</h5><ul><li>对程序员不可见（encapuslated to programmer）；</li><li>操作单元和内部链接；</li></ul><h4 id="1-2-冯诺依曼架构"><a href="#1-2-冯诺依曼架构" class="headerlink" title="1.2. 冯诺依曼架构"></a>1.2. 冯诺依曼架构</h4><h5 id="1-2-1-组成部分"><a href="#1-2-1-组成部分" class="headerlink" title="1.2.1. 组成部分"></a>1.2.1. 组成部分</h5><ul><li>存储器：地址和存储的内容；</li><li>处理单元：执行信息的实际处理；</li><li>控制单元：指挥信息的处理；</li><li>输入设备：将信息送入计算机中；</li><li>输出设备：将处理结果以某种形式显示在计算机外；</li><li><img src="冯诺依曼.png" alt="冯诺依曼架构"></li></ul><h4 id="1-3-摩尔定律"><a href="#1-3-摩尔定律" class="headerlink" title="1.3. 摩尔定律"></a>1.3. 摩尔定律</h4><p>单个芯片上的晶体管数量每过18个月就会翻一倍。</p><p><img src="数据流向.png" alt="数据流向图"></p><h4 id="1-4-CPU表现（CPU-Performance）"><a href="#1-4-CPU表现（CPU-Performance）" class="headerlink" title="1.4. CPU表现（CPU Performance）"></a>1.4. CPU表现（CPU Performance）</h4><h5 id="1-3-1-系统时钟"><a href="#1-3-1-系统时钟" class="headerlink" title="1.3.1 系统时钟"></a>1.3.1 系统时钟</h5><ul><li>时钟频率（Clock rate）：计算机在进行基本操作时，一秒内的时钟周期频数。</li><li>时钟周期（Clock cycle）：CPU的一次电磁脉冲；</li><li>周期时间（Cycle time）：脉冲之间的时间；</li></ul><h5 id="1-3-2-指令加载"><a href="#1-3-2-指令加载" class="headerlink" title="1.3.2 指令加载"></a>1.3.2 指令加载</h5><ul><li><p>CPI（Cycles Per Instruction）：一条指令所经历的时钟周期数；</p></li><li><p>总CPI的计算公式：</p><script type="math/tex; mode=display">CPI = \frac{\sum_{i=1}^{n}(CPI_i×I_i)}{I_C}, I_C=\sum_{i-1}^{n}I_i</script></li><li><p>处理时间</p><script type="math/tex; mode=display">T=I_C×CPI×t</script><script type="math/tex; mode=display">T=I_C×[p+(m×k)]×t</script><p>p：从处理器到存储器之间传输消耗的时钟周期；</p></li><li><p>Million Instructions Per Second (MIPS)</p><script type="math/tex; mode=display">MIPS=\frac{I_C}{T×10^6}=\frac{f}{CPI×10^6}</script></li><li><p>Million Floating Point Operations Per Second (MFLOPS)</p><script type="math/tex; mode=display">MFLOPS=\frac{N_{floating-point op}}{T×10^6}</script></li></ul><h5 id="1-3-3-评价标准（Benchmarks）"><a href="#1-3-3-评价标准（Benchmarks）" class="headerlink" title="1.3.3 评价标准（Benchmarks）"></a>1.3.3 评价标准（Benchmarks）</h5><ul><li><p>评测系统的表现；</p></li><li><p>平均结果：</p><ul><li>算术平均值：结果之和除以总数，得到平均的结果；</li></ul><script type="math/tex; mode=display">R_A = \frac{1}{m}\sum_{i=1}^{m}R_i</script><ul><li>调和平均值：一次除以结果得到单次结果的倒数，对其求和再去除总次数得到调和平均值；</li></ul><script type="math/tex; mode=display">R_H=\frac{m}{\sum_{i=1}^{m}\frac{1}{R_i}}</script></li></ul><h3 id="2-计算机的顶层视角"><a href="#2-计算机的顶层视角" class="headerlink" title="2. 计算机的顶层视角"></a>2. 计算机的顶层视角</h3><h4 id="2-1-计算机组成元素"><a href="#2-1-计算机组成元素" class="headerlink" title="2.1. 计算机组成元素"></a>2.1. 计算机组成元素</h4><ul><li>数据和指令存储在一个可读可写存储器；</li><li>存储器可寻址；</li><li>指令的加载按一定顺序进行；</li></ul><h4 id="2-1-1-存储器"><a href="#2-1-1-存储器" class="headerlink" title="2.1.1. 存储器"></a>2.1.1. 存储器</h4><ul><li><img src="/img/内存墙.png" alt=""></li><li>Memory Wall：数据从主存到CPU之间的传输速度的发展速度难以跟得上CPU的发展速度。</li><li>解决方案：在主存和CPU之间添加一个cache来减少主存的高频访问和数据传送率；提高一次获取的信息量；</li><li><img src="/img/存储器.png" alt=""></li></ul><h5 id="2-1-1-1-约束条件"><a href="#2-1-1-1-约束条件" class="headerlink" title="2.1.1.1. 约束条件"></a>2.1.1.1. 约束条件</h5><ul><li>容量：越大越好；</li><li>速度：跟得上处理器；</li><li>成本：相比其他组件可以接受；</li></ul><h5 id="2-1-1-2-约束条件之间的关系"><a href="#2-1-1-2-约束条件之间的关系" class="headerlink" title="2.1.1.2. 约束条件之间的关系"></a>2.1.1.2. 约束条件之间的关系</h5><ul><li>访问时间越短，单位比特的成本越高；</li></ul><h5 id="2-1-1-3-解决措施"><a href="#2-1-1-3-解决措施" class="headerlink" title="2.1.1.3. 解决措施"></a>2.1.1.3. 解决措施</h5><ul><li>存储器层次结构（金字塔）；</li><li><img src="/img/存储器层次结构.png" alt=""></li></ul><h4 id="2-1-2-I-O"><a href="#2-1-2-I-O" class="headerlink" title="2.1.2. I/O"></a>2.1.2. I/O</h4><ul><li>在存储器、CPU和外部资源之间交换数据的模块；</li></ul><h5 id="2-1-2-1-Problem"><a href="#2-1-2-1-Problem" class="headerlink" title="2.1.2.1. Problem"></a>2.1.2.1. Problem</h5><ul><li>I/O 表现不能够跟得上 CPU 速度的增长；</li><li>解决方案：缓冲区；</li></ul><h4 id="2-1-3-CPU"><a href="#2-1-3-CPU" class="headerlink" title="2.1.3. CPU"></a>2.1.3. CPU</h4><h5 id="2-1-3-1-Problem"><a href="#2-1-3-1-Problem" class="headerlink" title="2.1.3.1. Problem"></a>2.1.3.1. Problem</h5><ul><li>CPU 在等待 I/O 设备时需要等待；</li><li>解决方案：<ul><li>中断：一种被其他模块打断并可能影响正常处理顺序时的机制；</li><li><img src="/img/中断机制.png" alt=""></li></ul></li><li>中断检测</li><li><img src="/img/中断处理.png" alt=""></li></ul><h5 id="2-1-3-2-多重中断（分优先级嵌套中断）"><a href="#2-1-3-2-多重中断（分优先级嵌套中断）" class="headerlink" title="2.1.3.2. 多重中断（分优先级嵌套中断）"></a>2.1.3.2. 多重中断（分优先级嵌套中断）</h5><ul><li><img src="/img/多中断.png" alt=""></li><li>还有一种执行完一个中断再执行下一个的中断；</li></ul><h5 id="2-1-3-3-Theoretical-maximum-performance"><a href="#2-1-3-3-Theoretical-maximum-performance" class="headerlink" title="2.1.3.3. Theoretical maximum performance"></a>2.1.3.3. Theoretical maximum performance</h5><p><img src="/img/处理差距.png" alt=""></p><ul><li>随着技术的发展，出现了流水线、高速缓存、多核多线程等等使得计算机性能表现突飞猛进；</li><li>时钟频率也在不断上涨，但是上涨到了一定数值就停滞了。如果时钟频率过高，单条指令的处理时间会缩短，处理能力会下降。</li></ul><h4 id="2-1-4-总线-Bus"><a href="#2-1-4-总线-Bus" class="headerlink" title="2.1.4. 总线 Bus"></a>2.1.4. 总线 Bus</h4><ul><li>连接多个设备的通路——总线；</li><li><img src="/img/总线.png" alt=""></li></ul><h5 id="2-1-4-1-数据传输类型"><a href="#2-1-4-1-数据传输类型" class="headerlink" title="2.1.4.1. 数据传输类型"></a>2.1.4.1. 数据传输类型</h5><ul><li>数据线：在系统模块之间传输数据；</li><li>地址线：指定<em>数据线上和I/O端口上</em>的数据的<strong>来源或者目的地</strong>的地址；</li><li>控制线：控制【访问】、【数据的使用】和【地址线的使用】；</li><li>数据线和地址线上的内容可以复用；控制线上的内容不能复用；</li><li><img src="/img/三种线.png" alt=""></li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="0-C-基础"><a href="#0-C-基础" class="headerlink" title="0. C++基础"></a>0. C++基础</h3><ul><li>系统开发的一种方法是把类的声明放在 header 文件中，成员函数的实现分开放在代码文件中，在函数的实现代码中通过<strong>作用域设定命令“::”</strong>，将该函数归属到某一类。</li><li>struct 的默认访问级别是public，而 class 中的默认访问级别是 private。除此之外，struct 与 class 是等价的。</li></ul><h3 id="1-算法"><a href="#1-算法" class="headerlink" title="1. 算法"></a>1. 算法</h3><h4 id="1-1-算法定义"><a href="#1-1-算法定义" class="headerlink" title="1.1. 算法定义"></a>1.1. 算法定义</h4><ul><li><strong>有输入</strong></li><li><strong>有输出</strong></li><li><strong>确定性</strong></li><li><strong>有穷性</strong></li><li><strong>能行性</strong></li></ul><h4 id="1-2-算法的性能标准"><a href="#1-2-算法的性能标准" class="headerlink" title="1.2. 算法的性能标准"></a>1.2. 算法的性能标准</h4><ul><li>正确性</li><li>可使用性</li><li>可读性</li><li>效率</li><li>健壮性</li><li>简单性</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>WeeklyReview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CoreJava-6</title>
    <link href="/2020/05/03/CoreJava-6/"/>
    <url>/2020/05/03/CoreJava-6/</url>
    
    <content type="html"><![CDATA[<h3 id="Chapter-6-接口、lambda表达式和内部类"><a href="#Chapter-6-接口、lambda表达式和内部类" class="headerlink" title="Chapter 6 接口、lambda表达式和内部类"></a>Chapter 6 接口、lambda表达式和内部类</h3><ol><li>接口是对类的一组需求描述。<ul><li>接口不能含有实例域。</li><li>实现一个接口的步骤：①将类声明为实现给定的接口。②对接口中的所有方法进行定义。</li><li>可以利用泛型为接口提供一个类型参数。</li></ul></li><li>接口的特性<ul><li>接口可以被拓展。</li><li>接口中可以包含常量。</li><li>接口中的域将被自动设为public static final。</li><li>每个类可以拥有多个接口。</li></ul></li><li><strong>一个类只能继承一个类，却可以有多个接口。</strong></li><li>默认方法，可以为接口方法提供一个默认实现。必须用default修饰符标记这样一个方法。</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(T other)</span></span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; &#125;&#125;</code></pre><ol><li><strong>解决默认方法冲突</strong>。如果先在一个接口中将一个方法定义为默认方法，然后又在超类或另一个接口中定义了同样的方法。<ol><li>超类优先。如果超类提供了一个具体方法，同名而且有相同参数类型的默认方法会被忽略。</li><li>接口冲突。如果超接口提供了一个默认方法，另一个接口提供了一个同名而且参数类型相同的方法，必须覆盖这个方法来解决冲突。</li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Core Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CoreJava-5</title>
    <link href="/2020/04/26/CoreJava-5/"/>
    <url>/2020/04/26/CoreJava-5/</url>
    
    <content type="html"><![CDATA[<h3 id="Chapter-5-继承"><a href="#Chapter-5-继承" class="headerlink" title="Chapter 5 继承"></a>Chapter 5 继承</h3><ol><li><p>定义子类</p><ul><li>关键字extends表明正在构造的新类派生于一个已存在的类。已存在的类称为<strong>超类、基类、父类；</strong>新类称为<strong>子类、派生类或孩子类。</strong>子类的功能比超类更加丰富。</li><li>通过扩展超类定义子类的时候，仅需要指出子类与超类的不同之处。</li></ul></li><li><p>覆盖方法（override）</p><ul><li>Manager类的getSalary方法不能够直接地访问超类的私有域。只有Employee类的方法才能够访问私有部分。</li><li>super不是一个对象的引用，他只是一个指示编译器调用超类方法的指示器。<pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getSalary</span><span class="hljs-params">()</span></span>&#123;    <span class="hljs-comment">//double baseSalary = getSalary();这句也不可以，因为getSalary会循环调用；</span>    <span class="hljs-keyword">double</span> baseSalary = <span class="hljs-keyword">super</span>.gerSalary();    <span class="hljs-keyword">return</span> baseSalary + bonus;&#125;</code></pre></li></ul></li><li><p>子类构造器</p><ul><li>语句super(n, s, year, month, day)是“调用超类Employee中含有n、s、year、month、day参数的构造器”的简写形式。</li><li>Manager类不能访问Employee的私有域，所以必须利用Employee类的构造器对这部分私有域进行初始化。通过super实现对超类构造器的调用。<strong>使用super调用构造器的语句必须是子类构造器的第一条语句。</strong></li><li>没有使用super就会自动调用默认（即无参数）构造器。<pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Manager</span><span class="hljs-params">(String name, <span class="hljs-keyword">double</span> salary, <span class="hljs-keyword">int</span> year, <span class="hljs-keyword">int</span> month, <span class="hljs-keyword">int</span> day)</span></span>&#123;    <span class="hljs-keyword">super</span>(name, salary, year, month, day);    bonus = <span class="hljs-number">0</span>;&#125;</code></pre></li></ul></li><li><p>继承层次，继承并不限于一个层次。</p><ul><li>由一个公共超类派生出来的所有类的集合被称为<em>继承层次</em>。</li><li>在继承层次中，从某个特定的类到其祖先的路径被称为该类的<em>继承链</em>。</li></ul></li><li><p>多态</p><ul><li>“is-a”规则的另一种表述法是置换法则。它表明程序中出现超类的任何地方都可以用子类对象置换。</li><li>在Java中，子类数组的引用可以转换成超类数组的引用，而不需要采用强制类型转换。</li></ul></li></ol><pre><code class="hljs Java">Manager[] manager = <span class="hljs-keyword">new</span> Manager[<span class="hljs-number">10</span>];Employee[] staff = managers;<span class="hljs-comment">//managers和staff引用的是同一个数组。</span></code></pre><ol><li><p><strong><em>理解方法调用</em></strong>，下面假设要调用x.f(args),隐式参数声明为一个类C的对象。</p><ul><li>编译器查看对象的声明类型和方法名。如果存在多个名字为f但参数类型不一样的方法，编译器会意义列举所有C类中名为f的方法和其超类中访问属性为public且名为f的方法（超类的私有方法不可访问）。</li><li>接下来，编译器将查看调用方法时提供的参数类型。如果在所有名为f的方法中存在一个与提供参数类型完全匹配，就选择这个方法。这个过程叫“<strong>重载解析</strong>”。允许类型转换。如果编译器没有找到与参数类型匹配的方法，或者发现经过类型转换后有多个方法与之匹配，就会报一个错误。</li><li>如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法，我们将这种方法称为<strong>静态绑定</strong>。与此对应的是，调用的方法<strong>依赖于隐式参数的实际类型</strong>，并且在运行时时间<strong>动态绑定</strong>。</li><li>当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象的实际类型最合适的那个方法。<ul><li>假设x的实际类型是D，它是C类的子类。如果D类定义了方法f(String)，就直接调用它；否则，将在D类的超类中寻找f(String)，以此类推。</li></ul></li><li>方法表：列出了所有方法的签名和实际调用的方法。如果调用super.f(param)，编译器将对隐式参数超类的方法表进行搜索。</li><li>调用 e.getSalary() 的解析过程为：<ul><li>首先，虚拟机提取e的实际类型的方法表。</li><li>接下来，虚拟机搜索定义getSalary签名的类。此时，虚拟机已经知道应该调用哪个方法。</li><li>最后，虚拟机调用方法。</li></ul></li><li>动态绑定有一个重要的特性：无需对现存的代码进行修改，就可以对程序进行扩展。</li><li>在覆盖一个方法的时候，子类方法不能低于超类方法的可见性。特别是，如果超类方法是public，子类方法一定要声明为public。</li></ul></li><li><p>阻止继承：final类和方法</p><ul><li>不允许扩展的类被称为final类。</li><li>声明格式：public final class Executive extends Manager{ … }</li><li>类中的特定方法也可以被声明为final。如果这样做，子类就不能覆盖这个方法，final类中所有的方法自动地成为final方法。</li><li>将方法或类声明为final主要目的是：确保它们不会在子类中改变语意。</li><li>如果一个方法没有被覆盖并且很短，编译器就能够对它进行优化处理，这个过程被称为<em>内联</em>。如果子类中有覆盖这个方法，优化器将取消对覆盖方法的内联。</li></ul></li><li><p>强制类型转换，仅需要用一对圆括号将目标类名括起来，并放置在需要转换的对象引用之前就可以了。</p><ul><li>进行类型转换的唯一原因是：在暂时忽视对象的实际类型之后，使用对象的全部功能。</li><li>将一个子类的引用赋给一个超类变量，编译器是允许的。但将一个超类的引用赋给一个子类变量，必须进行类型转换，这样才能够通过运行时的检查。<ul><li><strong>在进行类型转换之前，先查看一下是否能够成功地转换。</strong></li><li><strong>只能在继承层次内进行类型转换</strong></li><li><strong>在将超类转换成子类之前，应该使用instanceof进行检查。</strong></li></ul></li><li>实际上，通过类型转换调整对象的类型并不是一种好的做法。因为多态性的动态绑定机制能够自动地找到对应的方法。在一般情况下，应该尽量少用类型转换和 instanceof 运算符。</li></ul></li></ol><pre><code class="hljs Java">Manager boss = <span class="hljs-keyword">new</span> Manager(...);staff[<span class="hljs-number">0</span>] = boss;staff[<span class="hljs-number">1</span>] = <span class="hljs-keyword">new</span> Employee(...);staff[<span class="hljs-number">2</span>] = <span class="hljs-keyword">new</span> Employee(...);Manager boss = (Manager) staff[<span class="hljs-number">0</span>]; <span class="hljs-comment">//Allowed</span>Manager boss = (Manager) staff[<span class="hljs-number">1</span>]; <span class="hljs-comment">//Error</span><span class="hljs-keyword">if</span> (staff[<span class="hljs-number">1</span>] <span class="hljs-keyword">instanceof</span> Manager)&#123;    boss = (Manager) staff[<span class="hljs-number">1</span>];&#125; <span class="hljs-comment">//check the instance before</span></code></pre><ol><li>抽象类，从某种角度按，<em>祖先类</em>更加通用，人们只将它作为派生其他类的基类，而不作为想使用的特定的实例类。<ul><li>为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的。</li><li>许多程序员认为，在抽象类中不能包含具体方法。建议尽量通用的域和方法（不管是否是抽象的）放在超类（不管是不是抽象类）中。</li><li>扩展抽象类可以有两种选择。<ul><li>一种是在抽象类中定义部分抽象类或不定义抽象类方法，这样就必须将子类也标记为抽象类。</li><li>另一种是定义全部的抽象方法，这样一来子类就不是抽象的了。</li></ul></li><li>类即使不含抽象方法，也可以将类声明为抽象类。</li><li>抽象类不能被实例化。也就是说，如果将一个类声明为abstract，就不能创建这个类的对象。</li><li>可以定义一个抽象类的对象变量。但是它只能引用非抽象子类的实例。</li></ul></li></ol><pre><code class="hljs Java">Person p = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;Vince Vu&quot;</span>, <span class="hljs-string">&quot;Economics&quot;</span>);</code></pre><ol><li>受访问保护<ul><li>子类也不能访问超类的私有域。</li><li>例如，如果超类Employee中的hireDay声明为protected，而不是私有的，Manager中的方法就可以直接访问它。不过，Manager类中的方法只能够访问Manager对象中的hireDay域，而不能访问其他Employee对象中的这个域。</li></ul></li></ol><div class="table-container"><table><thead><tr><th>修饰词</th><th>本类</th><th>同一个包的类</th><th>继承类</th><th>其他类</th></tr></thead><tbody><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr><tr><td>默认</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr></tbody></table></div><ol><li><p>Object类，它是Java中所有类的始祖，在Java中每个类都是由它扩展而来的。在Java中，只有基本类型不是对象。</p><ul><li>equals方法，用来检测一个对象是否等于另外一个对象。判断两个对象是否具有相同的引用（内容）。<pre><code class="hljs Java"><span class="hljs-comment">//重写equals</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Employee</span></span>&#123;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object otherObject)</span></span>&#123;        <span class="hljs-keyword">if</span>(!<span class="hljs-keyword">super</span>.equals(otherObject)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-comment">//super.equals checked that this and otherObject belong to the same class</span>        Manager other = (Manager) otherObject;        <span class="hljs-keyword">return</span> bonus == other.bonus;    &#125;&#125;</code></pre></li></ul></li><li><p>泛型数组列表ArrayList</p><ul><li>ArrayList  是一个采用类型参数的泛型类。为了指定数组列表保存的元素对象类型，需要用一对尖括号将类名括起来加在后面。</li><li>add方法可以将元素添加到数组列表中。</li><li>ensureCapacity(int num)方法，分配一个包含num个对象的内部数组。</li><li>.size()方法类似于length。</li><li>trimToSize() 将数组列表的存储容量削减到当前尺寸。</li><li>.set(i, harry)将第i个元素设置为harry。</li><li>.get()同理。</li><li>.toArray(int[] a)将其拷贝到一个数组中。</li><li>.remove(n)</li><li>将原始ArrayList赋值给一个类型化的ArrayList会得到一个警告。而一个类型化的数组传递给一个普通方法不会出现警告，并且不需要任何的类型转换。</li></ul></li><li>对象包装器与自动装箱（wrapper）<ul><li>自动装箱：list.add(3) 将自动转换成 list.add(Integer.ValueOf(3))，同样的将Integer对象赋值给一个int值的时候，会自动拆箱。</li><li>对象之间的比较要使用equals方法。</li></ul></li><li>枚举类</li></ol><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Size</span></span>&#123;    SMALL(<span class="hljs-string">&quot;S&quot;</span>), MEDIUM(<span class="hljs-string">&quot;M&quot;</span>),LARGE(<span class="hljs-string">&quot;L&quot;</span>),EXTRA_LARGE(<span class="hljs-string">&quot;XL&quot;</span>);        <span class="hljs-keyword">private</span> String abbreviation;        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Size</span><span class="hljs-params">(String abbreviation)</span> </span>&#123;      <span class="hljs-keyword">this</span>.abbreviation = abbreviation;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAbbreviation</span><span class="hljs-params">()</span></span>&#123;        <span class="hljs-keyword">return</span> abbreviation;    &#125;&#125;</code></pre><ol><li>Class类<ul><li>getName方法，返回类的名more字。</li><li>一个Class对象实际上表示的是一个类型，而这个类型未必一定是一种类。例如，int不是类，但int.class是一个Class类型的对象。</li><li>Class类实际上是一个泛型类。例如，Employee.class的类型是Class<Employee>。</li><li>虚拟机为每个类型管理一个Class对象。因此，可以用==运算符实现两个类对象的比较操作。</li><li>newInstance方法乐意用来动态创建一个类的实例。它会调用默认的构造器初始化新创建的对象。如果没有默认的构造器，会抛出一个异常。</li></ul></li><li><p>利用反射分析类的能力。Field、Method和Constructor分别用于描述类的域、方法和构造器。都有getName方法返回项目的名称。</p><ul><li>Field类有一个getType方法，用来返回所描述域所属类型的Class对象。</li><li>Modifier类中isPublic、isPrivate或isFinal判断方法或构造器判断是否是public、private或final。</li><li>Class的getFields、getMethods和getConstructor方法将分别返回类提供的public域、方法和构造器数组。</li></ul></li><li><p><strong>继承的设计技巧</strong></p><ol><li>将公共操作和域放在超类</li><li>不要使用受保护的域</li><li>使用继承实现”is-a”关系</li><li>除非所有继承的方法都有意义，否则不要使用继承</li><li>在覆盖方法时，不要改变预期的行为</li><li>使用多态，而非类型信息</li><li>不要过多使用反射</li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Core Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CoreJava-4</title>
    <link href="/2020/04/26/CoreJava-4/"/>
    <url>/2020/04/26/CoreJava-4/</url>
    
    <content type="html"><![CDATA[<h3 id="Chapter-4-对象与类"><a href="#Chapter-4-对象与类" class="headerlink" title="Chapter 4 对象与类"></a>Chapter 4 对象与类</h3><ol><li><p>封装：将数据和行为组合在一个包中，并对对象的使用者隐藏了数据的实现方式，对象中的数据成为实例域。</p><ul><li>实现封装的关键在于<strong>绝对不能</strong>让类中的方法直接地访问其他类的实例域。</li><li>封装的优点<ul><li>可以改变内部实现，除了该类的方法之外，不会影响其他的代码。</li><li>更改器方法可以执行错误检查，然而直接赋值不会进行这些处理。</li></ul></li></ul></li><li><p>对象</p><ul><li>对象的三个特性：<ul><li>对象的行为：可以对对象施加哪些操作，或可以对对象施加哪些方法？</li><li>对象的状态：当施加那些方法时，对象如何响应？</li><li>对象标识：如何辨别具有相同行为与状态的不同对象？</li></ul></li><li>对象的行为是用可调用的方法定义的。</li><li>每个对象都有一个唯一的<strong>身份</strong></li></ul></li><li><p>识别类</p><ul><li>从设计类开始，然后再往每个类中添加方法。</li><li>“找动词与名词”</li></ul></li><li><p>类之间的关系</p><ul><li>“依赖（use-a）”：如果一个类的方法操纵另一个类的对象，我们就说一个类依赖另一个类。<strong>应该尽可能将互相依赖的类减到最少——让类之间的耦合度最小。</strong></li><li>“聚合（has-a）”：类A的对象包含类B的对象。</li><li>“继承（is-a）”</li></ul></li><li><p>对象与对象变量：要想使用对象，就必须首先构造对象，并制定其初始状态。然后，对对象应用方法。</p><ul><li>构造器： 特殊的方法，用来构造并初始化对象。</li><li>一个对象变量并没有实际包含一个对象，而仅仅应用一个对象。deadline = birthday两个Date类的对象。</li><li>如果将方法应用到null对象上就会引发运行错误。</li><li>访问器方法——只访问对象而不修改对象的方法；修改的叫做构造器方法。</li></ul></li><li><p>Emplyee类</p><ul><li>最简单的类定义形式为：<pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassName</span></span>&#123;    field;    constructor;    method;&#125;</code></pre></li></ul></li><li><p>构造器</p><ul><li>构造器与类同名。</li><li>每个类可以有一个以上的构造器。</li><li>构造器可以有0个、1个或多个参数。</li><li>构造器没有返回值。</li><li>构造器总是伴随着new操作一起调用。</li><li><strong>不要在构造器中定义与实例域重名的局部变量</strong></li></ul></li><li><p>隐式参数与显式参数</p><ul><li>隐式参数是出现在方法名前的对象；</li><li>显式参数是方法名后面括号里的数值；</li><li>在每一个方法中，关键字</li></ul></li><li><p>一个方法可以访问所属类的所有对象的私有数据。</p></li><li><p>如果一个方法与当前实现机制非常紧密或者需要一个特别的协议以及一个特别的调用次序，最好将这样的方法设置成private的。</p><ul><li>只要方法是私有的，就可以确保它不会被外部的其他类所调用，因此可以将其删去。</li></ul></li><li><p>final实例域</p><ul><li>可以将实例域定义为final，在构建对象的时候必须将它初始化。并且在后面的操作中不能将它修改。</li><li>final修饰符大多应用于基本（primitive）类型域，或不可变类型域（类中的每个方法都不会改变其对象。）</li></ul></li><li><p>静态域： 如果将域定义为static，每个类中只有一个这样的域。而每一个对象对于所有的实例域却都有自己的一份拷贝。</p><ul><li>这个类的所有实例域将共享一个“nextID”域；</li><li>它属于类，不属于一个独立的对象；</li></ul></li><li><p>静态方法：不能向对象实施操作的方法。</p><ul><li>没有隐式的参数。静态方法是没有this参数的方法。</li><li>静态方法可以访问自身类中的静态域；</li><li>建议使用类名来调用静态方法；</li><li>在以下两种情况使用静态方法：<ul><li>一个方法不需要访问对象状态，其所需参数都是通过显示参数提供（如Math.pow）;</li><li>一个方法只需要访问类的静态域（如Employee.getNextID）；</li></ul></li></ul></li><li><p>工厂方法构造对象；</p><ul><li>将类的创建单独放到一个类里进行，这个类就叫做工厂。</li><li>不利用构造器有两个原因：<ol><li>无法命名构造器。构造器的名字必须和类名相同。但是货币的实例需要不同的名字；</li><li>当使用构造器时，无法改变所构造的对象类型。<pre><code class="hljs Java">NumberFormat currencyFormatter = NumberFormat.gerCurrencyInstance();NumberFormat percentFormatter = NumberFormat.getpercentInstance();</code></pre></li></ol></li></ul></li><li><p>main方法：<strong>不需要使用对象调用静态方法</strong></p><ul><li>例子：不需要构造Math对象就可以直接调用Math.pow。</li><li>main方法也是一个静态方法。main方法不对任何对象进行操作。事实上在程序启动时没有任何一个对象。静态的main方法将执行并创建程序所需要的对象。</li></ul></li><li><p>Java总是采用按值调用。</p><ul><li><strong>Java对对象采用的不是引用调用，实际上，对象引用是按值传递的。</strong></li><li>一个方法不能修改一个基本数据类型的参数（按值传递参数）；</li><li>一个方法可以改变一个对象的参数的状态；</li><li><strong>一个方法不能让对象参数引用一个新的对象 </strong></li></ul></li><li><p>重载：有些类可以有多个构造器。如果多个方法有相同的名字、不同的参数，便产生了重载；编译器通过用各个方法给出的参数类型与特定方法调用所使用的值的类型进行匹配来挑选出相应的方法（重载解析）。</p><ul><li>Java允许重载任何方法，不只是构造器方法。完整描述一个方法需要指出方法名以及参数类型。这叫做方法的<strong>签名</strong>。</li></ul></li><li><p>默认域初始化：数值为0、布尔值为false、对象引用为null。</p></li><li><p>无参数构造器，如果在编写一个类时没有编写构造器，系统就会提供一个无参数构造器。这个构造器将所有实数域设置为默认值。</p></li><li><p>显示域初始化，通过重载类的构造器方法，可以采用多种形式设置类的实例域的初始状态。</p></li><li><p>参数变量用同样的名字将实例域屏蔽起来。可以用this.salary的方式访问实例域。回想一下，this指示隐式参数，也就是所构造的对象。</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String name, <span class="hljs-keyword">double</span> salary)</span></span>&#123;    <span class="hljs-keyword">this</span>.name = name;    <span class="hljs-keyword">this</span>.salary = salary;&#125;</code></pre></li><li><p>调用另一个构造器。如果构造器的第一个语句形如this(…)，这个构造器将调用同一个类的另一个构造器。公共的构造器代码部分只编写一次即可。</p><pre><code class="hljs Java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(<span class="hljs-keyword">double</span> s)</span></span>&#123;    <span class="hljs-keyword">this</span>(<span class="hljs-string">&quot;Emplyee #&quot;</span> + nextID, s);    nextID++; &#125;</code></pre></li><li><p>初始化块。在一个类的声明中，可以包含多个代码块。只要构造类的对象，这些块就会被执行。</p><pre><code class="hljs Java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Employee</span></span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> nextID;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> id;    <span class="hljs-keyword">private</span> String name;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> salary;        <span class="hljs-comment">//object initialization block</span>    &#123;        id = nextID;        nextID++;    &#125;        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Employee</span><span class="hljs-params">(String n, <span class="hljs-keyword">double</span> s)</span></span>&#123;        <span class="hljs-keyword">this</span>.name = n;        <span class="hljs-keyword">this</span>.salary = s;    &#125;&#125;</code></pre><p>在上述示例中，无论使用哪个构造器构造对象，id域都在对象初始化模块中被初始化。<strong>运行初始化模块，然后才运行构造器的主体部分。</strong></p></li><li><p>调用构造器的具体处理步骤：</p><ol><li>所有数据域被初始化为默认值。</li><li>按照在类声明中出现的次序，一次执行所有域初始化语句和初始化块。</li><li>如果构造器第一行调用了第二个构造器，则执行第二个构造器主体。</li><li>执行这个构造器的主体。</li></ol></li><li><p>静态初始化块</p><ul><li><strong>初始化块只调用一次（类加载时），而普通初始化块可以调用多次，随着对象的创建而加载。</strong></li><li>一个类中可以有多个静态初始化块和多个普通初始化块；静态初始化块的执行要早于普通初始化块；同一个类型的初始化块的执行顺序取决于定义的先后顺序！</li><li>在一个类中如果有多个不同的初始化块，初始化属性，构造器，执行顺序是：静态初始化块|静态属性初始化 &gt; 普通初始化块|普通属性初始化 &gt; 构造器</li></ul></li><li><p>对象析构与finalize方法</p><ul><li>Java自动回收垃圾，不支持析构器。</li><li>可以为任何一个类添加finalize方法。finalize方法在垃圾回收器清除对象之前调用。在实际应用中，不要依赖于使用finalize方法回收任何短缺的资源，这是因为很难知道这个方法什么时候才能够调用。</li></ul></li><li><p>包，Java允许使用包（package）将类组织起来。</p><ul><li>使用包的主要原因是确保类名的唯一性。</li><li>从编译器的角度来看，嵌套的包之间没有任何关系。例如，java.util包与java.util.jar包毫无关系。每一个都有独立的集合。</li></ul></li><li><p>静态导入</p><ul><li>在源文件顶部，添加一条import static java.lang.System.*;</li><li>可以更简洁比如Math.sqrt可以简写为sqrt</li></ul></li><li><p>将类放入包中，就必须将包的名字放在源文件的开头，包中定义类的代码之前。如果没有在源文件中放置package语句，这个源文件中的类就被放置在一个默认包中。</p></li><li><p>注释</p><ol><li>方法注释<ol><li>@param 变量描述</li><li>@return 描述</li><li>@throws 类描述</li></ol></li><li>通用注释<ol><li>@author 姓名</li><li>@version 版本</li><li>@since 引入特性的版本描述</li><li>@see 引用</li></ol></li><li>包注释单独在包中添加文档</li></ol></li><li><p>类设计技巧</p><ol><li>一定要保证数据私有，绝对不要破坏封装性。</li><li>一定要对数据初始化。</li><li>不要在类中使用过多的基本类型。</li><li>不是所有的域都需要独立的域访问器和域更改器。</li><li>将职责过多的类进行分解。</li><li>类名和方法名要能够体现它们的职责。</li><li>优先使用不可变的类。</li></ol></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Core Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CoreJava-3</title>
    <link href="/2020/04/26/CoreJava-3/"/>
    <url>/2020/04/26/CoreJava-3/</url>
    
    <content type="html"><![CDATA[<h3 id="Chapter-3-基本设计结构"><a href="#Chapter-3-基本设计结构" class="headerlink" title="Chapter 3 基本设计结构"></a>Chapter 3 基本设计结构</h3><ol><li><p>关键字<em>final</em>表示常量。关键字<em>final</em>表示这个变量只能被赋值一次。常量名全部使用大写。</p></li><li><p><em>static final</em>设置类常量。可在一个类的多个方法中使用。如果生命为public，即<em>public</em>，则其他类的方法也可以使用这个常量。</p></li><li><p><em>strictfp</em>关键字标记点方法必须使用严格的浮点计算来生成可再生的结果。</p></li><li><p>String 中的<em>substring</em>方法，s.substring(a, b)得到以a为index开头，到b为止但不包含b的字符串，长度为b-a。</p></li><li><p><em>join</em>方法，String.join(“/“, “S”, “M”, “L”, “XL”);得到的是字符串”S/M/L/XL”。</p></li><li><p>String类对象是不可变字符串。编译器可以让字符串共享。</p></li><li><p>检查字符串是否相等可以用.equals()方法。如果不区分大小写可以用equalsIgnoreCase方法。<em>一定不要使用==运算符来检测两个字符串是否相等。这只能确定两个字符串是否在同一个位置上</em></p></li><li><p>“”是空串，有长度有内容。null表示目前没有任何对象与该变量关联。</p></li><li><p>码点与代码单元</p></li></ol><ul><li>int[] codePoints = str.codePoints().toArray();将字符串转成一个数组。</li><li>String str = new String(codePoints, 0, codePoints.length);将码点数组转化成一个字符串。</li></ul><ol><li><p>构建字符串</p><pre><code class="hljs Java">StringBuilder builder = <span class="hljs-keyword">new</span> StringBuilder();builder.append(ch);<span class="hljs-comment">// appends a single character</span>builder.append(str);<span class="hljs-comment">// appends a string</span>String completedString = builder.toString();</code></pre></li><li><p>控制台输入</p><pre><code class="hljs Java">Scanner in = <span class="hljs-keyword">new</span> Scanner(System.in);String name = in.nextLine();<span class="hljs-keyword">int</span> age = in.nextInt();</code></pre></li><li><p>文件出入与输出</p><pre><code class="hljs Java"><span class="hljs-comment">//input</span>Scanner in = <span class="hljs-keyword">new</span> Scanner(Paths.get(<span class="hljs-string">&quot;myfile.txt&quot;</span>), <span class="hljs-string">&quot;UTF-8&quot;</span>);<span class="hljs-comment">//output</span>PrintWriter out = <span class="hljs-keyword">new</span> PrintWriter(<span class="hljs-string">&quot;myfile.txt&quot;</span>), <span class="hljs-string">&quot;UTF-8&quot;</span>);</code></pre></li><li><p>Java SE 7 开始，switch中的case标签还可以是字符串字面量。</p></li><li><p>break或continue后接label, 可以在中断之后直接跳到label的位置继续执行。</p></li><li><p>大数值BigInteger实现大整数；BigDecimal实现大浮点数。</p><pre><code class="hljs Java">BigInteger a = BigInteger.valueOf(<span class="hljs-number">100</span>);<span class="hljs-comment">//将普通数值转换为大数值；</span>BigInteger c = a.add(b); <span class="hljs-comment">// c = a + b;</span>BigInteger d = c.multiply(b.add(BigInteger.valueOf(<span class="hljs-number">2</span>))); <span class="hljs-comment">// d = c * (b + 2)</span></code></pre></li><li><p>数组</p><pre><code class="hljs Java"><span class="hljs-keyword">int</span>[] a= <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">100</span>];</code></pre></li></ol><ul><li>创建一个数组时，所有元素都初始化为0。boolean数组的元素会初始化为false。对象数组会初始化为null。<pre><code class="hljs Java"><span class="hljs-comment">//下面所有字符串都是null</span>String[] names = <span class="hljs-keyword">new</span> String[<span class="hljs-number">10</span>];<span class="hljs-comment">//下面所有字符串都是空串</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) names[i] = <span class="hljs-string">&quot;&quot;</span>;</code></pre></li><li>一旦创建了数组就不能改变它的大小。</li></ul><ol><li>for each 循环</li></ol><ul><li>for (variable : collection) statement<pre><code class="hljs Java">System.out.println(Arrays.toString(a));<span class="hljs-comment">//打印数组；</span></code></pre></li></ul><ol><li>数组拷贝<pre><code class="hljs Java"><span class="hljs-keyword">int</span>[] copiedLuckyNumbers = Arrays.copyOf(luckyNumbers, luckynumbers.length);</code></pre></li><li><p>Array.sort(a); 进行排序</p></li><li><p>不规则数组</p><pre><code class="hljs Java"><span class="hljs-keyword">int</span>[][] odds = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[MAX+<span class="hljs-number">1</span>][];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n = <span class="hljs-number">0</span>; n &lt;= MAX; n+<span class="hljs-number">1</span>)    odds[n] = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];<span class="hljs-comment">//以上生成的是一个三角形数组</span></code></pre></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Core Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
